{"ast":null,"code":"import React from \"react\";\nimport ReactDOM from \"react-dom\";\nconst PUBLISH = 0;\nconst SUBSCRIBE = 1;\nconst RESET = 2;\nconst VALUE = 4;\nfunction compose(a, b) {\n  return arg => a(b(arg));\n}\nfunction thrush(arg, proc) {\n  return proc(arg);\n}\nfunction curry2to1(proc, arg1) {\n  return arg2 => proc(arg1, arg2);\n}\nfunction curry1to0(proc, arg) {\n  return () => proc(arg);\n}\nfunction tap(arg, proc) {\n  proc(arg);\n  return arg;\n}\nfunction tup() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  return args;\n}\nfunction call(proc) {\n  proc();\n}\nfunction always(value) {\n  return () => value;\n}\nfunction joinProc() {\n  for (var _len2 = arguments.length, procs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    procs[_key2] = arguments[_key2];\n  }\n  return () => {\n    procs.map(call);\n  };\n}\nfunction isDefined(arg) {\n  return arg !== void 0;\n}\nfunction noop() {}\nfunction subscribe(emitter, subscription) {\n  return emitter(SUBSCRIBE, subscription);\n}\nfunction publish(publisher, value) {\n  publisher(PUBLISH, value);\n}\nfunction reset(emitter) {\n  emitter(RESET);\n}\nfunction getValue(depot) {\n  return depot(VALUE);\n}\nfunction connect(emitter, publisher) {\n  return subscribe(emitter, curry2to1(publisher, PUBLISH));\n}\nfunction handleNext(emitter, subscription) {\n  const unsub = emitter(SUBSCRIBE, value => {\n    unsub();\n    subscription(value);\n  });\n  return unsub;\n}\nfunction stream() {\n  const subscriptions = [];\n  return (action, arg) => {\n    switch (action) {\n      case RESET:\n        subscriptions.splice(0, subscriptions.length);\n        return;\n      case SUBSCRIBE:\n        subscriptions.push(arg);\n        return () => {\n          const indexOf = subscriptions.indexOf(arg);\n          if (indexOf > -1) {\n            subscriptions.splice(indexOf, 1);\n          }\n        };\n      case PUBLISH:\n        subscriptions.slice().forEach(subscription => {\n          subscription(arg);\n        });\n        return;\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction statefulStream(initial) {\n  let value = initial;\n  const innerSubject = stream();\n  return (action, arg) => {\n    switch (action) {\n      case SUBSCRIBE:\n        const subscription = arg;\n        subscription(value);\n        break;\n      case PUBLISH:\n        value = arg;\n        break;\n      case VALUE:\n        return value;\n    }\n    return innerSubject(action, arg);\n  };\n}\nfunction eventHandler(emitter) {\n  let unsub;\n  let currentSubscription;\n  const cleanup = () => unsub && unsub();\n  return function (action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (subscription) {\n          if (currentSubscription === subscription) {\n            return;\n          }\n          cleanup();\n          currentSubscription = subscription;\n          unsub = subscribe(emitter, subscription);\n          return unsub;\n        } else {\n          cleanup();\n          return noop;\n        }\n      case RESET:\n        cleanup();\n        currentSubscription = null;\n        return;\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction streamFromEmitter(emitter) {\n  return tap(stream(), stream2 => connect(emitter, stream2));\n}\nfunction statefulStreamFromEmitter(emitter, initial) {\n  return tap(statefulStream(initial), stream2 => connect(emitter, stream2));\n}\nfunction combineOperators() {\n  for (var _len3 = arguments.length, operators = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    operators[_key3] = arguments[_key3];\n  }\n  return subscriber => {\n    return operators.reduceRight(thrush, subscriber);\n  };\n}\nfunction pipe(source) {\n  for (var _len4 = arguments.length, operators = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    operators[_key4 - 1] = arguments[_key4];\n  }\n  const project = combineOperators(...operators);\n  return (action, subscription) => {\n    switch (action) {\n      case SUBSCRIBE:\n        return subscribe(source, project(subscription));\n      case RESET:\n        reset(source);\n        return;\n    }\n  };\n}\nfunction defaultComparator(previous, next) {\n  return previous === next;\n}\nfunction distinctUntilChanged() {\n  let comparator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultComparator;\n  let current;\n  return done => next => {\n    if (!comparator(current, next)) {\n      current = next;\n      done(next);\n    }\n  };\n}\nfunction filter(predicate) {\n  return done => value => {\n    predicate(value) && done(value);\n  };\n}\nfunction map(project) {\n  return done => compose(done, project);\n}\nfunction mapTo(value) {\n  return done => () => done(value);\n}\nfunction scan(scanner, initial) {\n  return done => value => done(initial = scanner(initial, value));\n}\nfunction skip(times) {\n  return done => value => {\n    times > 0 ? times-- : done(value);\n  };\n}\nfunction throttleTime(interval) {\n  let currentValue = null;\n  let timeout;\n  return done => value => {\n    currentValue = value;\n    if (timeout) {\n      return;\n    }\n    timeout = setTimeout(() => {\n      timeout = void 0;\n      done(currentValue);\n    }, interval);\n  };\n}\nfunction debounceTime(interval) {\n  let currentValue;\n  let timeout;\n  return done => value => {\n    currentValue = value;\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(() => {\n      done(currentValue);\n    }, interval);\n  };\n}\nfunction withLatestFrom() {\n  for (var _len5 = arguments.length, sources = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    sources[_key5] = arguments[_key5];\n  }\n  const values = new Array(sources.length);\n  let called = 0;\n  let pendingCall = null;\n  const allCalled = Math.pow(2, sources.length) - 1;\n  sources.forEach((source, index) => {\n    const bit = Math.pow(2, index);\n    subscribe(source, value => {\n      const prevCalled = called;\n      called = called | bit;\n      values[index] = value;\n      if (prevCalled !== allCalled && called === allCalled && pendingCall) {\n        pendingCall();\n        pendingCall = null;\n      }\n    });\n  });\n  return done => value => {\n    const call2 = () => done([value].concat(values));\n    if (called === allCalled) {\n      call2();\n    } else {\n      pendingCall = call2;\n    }\n  };\n}\nfunction merge() {\n  for (var _len6 = arguments.length, sources = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    sources[_key6] = arguments[_key6];\n  }\n  return function (action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        return joinProc(...sources.map(source => subscribe(source, subscription)));\n      case RESET:\n        return;\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction duc(source) {\n  let comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultComparator;\n  return pipe(source, distinctUntilChanged(comparator));\n}\nfunction combineLatest() {\n  const innerSubject = stream();\n  for (var _len7 = arguments.length, emitters = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n    emitters[_key7] = arguments[_key7];\n  }\n  const values = new Array(emitters.length);\n  let called = 0;\n  const allCalled = Math.pow(2, emitters.length) - 1;\n  emitters.forEach((source, index) => {\n    const bit = Math.pow(2, index);\n    subscribe(source, value => {\n      values[index] = value;\n      called = called | bit;\n      if (called === allCalled) {\n        publish(innerSubject, values);\n      }\n    });\n  });\n  return function (action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (called === allCalled) {\n          subscription(values);\n        }\n        return subscribe(innerSubject, subscription);\n      case RESET:\n        return reset(innerSubject);\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction system(constructor) {\n  let dependencies = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let {\n    singleton\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    singleton: true\n  };\n  return {\n    id: id(),\n    constructor,\n    dependencies,\n    singleton\n  };\n}\nconst id = () => Symbol();\nfunction init(systemSpec) {\n  const singletons = /* @__PURE__ */new Map();\n  const _init = _ref => {\n    let {\n      id: id2,\n      constructor,\n      dependencies,\n      singleton\n    } = _ref;\n    if (singleton && singletons.has(id2)) {\n      return singletons.get(id2);\n    }\n    const system2 = constructor(dependencies.map(e => _init(e)));\n    if (singleton) {\n      singletons.set(id2, system2);\n    }\n    return system2;\n  };\n  return _init(systemSpec);\n}\nfunction omit(keys, obj) {\n  const result = {};\n  const index = {};\n  let idx = 0;\n  const len = keys.length;\n  while (idx < len) {\n    index[keys[idx]] = 1;\n    idx += 1;\n  }\n  for (const prop in obj) {\n    if (!index.hasOwnProperty(prop)) {\n      result[prop] = obj[prop];\n    }\n  }\n  return result;\n}\nconst useIsomorphicLayoutEffect$2 = typeof document !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\nfunction systemToComponent(systemSpec, map2, Root) {\n  const requiredPropNames = Object.keys(map2.required || {});\n  const optionalPropNames = Object.keys(map2.optional || {});\n  const methodNames = Object.keys(map2.methods || {});\n  const eventNames = Object.keys(map2.events || {});\n  const Context = React.createContext({});\n  function applyPropsToSystem(system2, props) {\n    if (system2[\"propsReady\"]) {\n      publish(system2[\"propsReady\"], false);\n    }\n    for (const requiredPropName of requiredPropNames) {\n      const stream2 = system2[map2.required[requiredPropName]];\n      publish(stream2, props[requiredPropName]);\n    }\n    for (const optionalPropName of optionalPropNames) {\n      if (optionalPropName in props) {\n        const stream2 = system2[map2.optional[optionalPropName]];\n        publish(stream2, props[optionalPropName]);\n      }\n    }\n    if (system2[\"propsReady\"]) {\n      publish(system2[\"propsReady\"], true);\n    }\n  }\n  function buildMethods(system2) {\n    return methodNames.reduce((acc, methodName) => {\n      acc[methodName] = value => {\n        const stream2 = system2[map2.methods[methodName]];\n        publish(stream2, value);\n      };\n      return acc;\n    }, {});\n  }\n  function buildEventHandlers(system2) {\n    return eventNames.reduce((handlers, eventName) => {\n      handlers[eventName] = eventHandler(system2[map2.events[eventName]]);\n      return handlers;\n    }, {});\n  }\n  const Component = React.forwardRef((propsWithChildren, ref) => {\n    const {\n      children,\n      ...props\n    } = propsWithChildren;\n    const [system2] = React.useState(() => {\n      return tap(init(systemSpec), system22 => applyPropsToSystem(system22, props));\n    });\n    const [handlers] = React.useState(curry1to0(buildEventHandlers, system2));\n    useIsomorphicLayoutEffect$2(() => {\n      for (const eventName of eventNames) {\n        if (eventName in props) {\n          subscribe(handlers[eventName], props[eventName]);\n        }\n      }\n      return () => {\n        Object.values(handlers).map(reset);\n      };\n    }, [props, handlers, system2]);\n    useIsomorphicLayoutEffect$2(() => {\n      applyPropsToSystem(system2, props);\n    });\n    React.useImperativeHandle(ref, always(buildMethods(system2)));\n    return React.createElement(Context.Provider, {\n      value: system2\n    }, Root ? React.createElement(Root, omit([...requiredPropNames, ...optionalPropNames, ...eventNames], props), children) : children);\n  });\n  const usePublisher2 = key => {\n    return React.useCallback(curry2to1(publish, React.useContext(Context)[key]), [key]);\n  };\n  const useEmitterValue2 = key => {\n    const system2 = React.useContext(Context);\n    const source = system2[key];\n    const [value, setValue] = React.useState(curry1to0(getValue, source));\n    useIsomorphicLayoutEffect$2(() => subscribe(source, next => {\n      if (next !== value) {\n        setValue(always(next));\n      }\n    }), [source, value]);\n    return value;\n  };\n  const useEmitter2 = (key, callback) => {\n    const context = React.useContext(Context);\n    const source = context[key];\n    useIsomorphicLayoutEffect$2(() => subscribe(source, callback), [callback, source]);\n  };\n  return {\n    Component,\n    usePublisher: usePublisher2,\n    useEmitterValue: useEmitterValue2,\n    useEmitter: useEmitter2\n  };\n}\nconst useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\nconst useIsomorphicLayoutEffect$1 = useIsomorphicLayoutEffect;\nvar LogLevel = /* @__PURE__ */(LogLevel2 => {\n  LogLevel2[LogLevel2[\"DEBUG\"] = 0] = \"DEBUG\";\n  LogLevel2[LogLevel2[\"INFO\"] = 1] = \"INFO\";\n  LogLevel2[LogLevel2[\"WARN\"] = 2] = \"WARN\";\n  LogLevel2[LogLevel2[\"ERROR\"] = 3] = \"ERROR\";\n  return LogLevel2;\n})(LogLevel || {});\nconst CONSOLE_METHOD_MAP = {\n  [0\n  /* DEBUG */]: \"debug\",\n  [1\n  /* INFO */]: \"log\",\n  [2\n  /* WARN */]: \"warn\",\n  [3\n  /* ERROR */]: \"error\"\n};\nconst getGlobalThis = () => typeof globalThis === \"undefined\" ? window : globalThis;\nconst loggerSystem = system(() => {\n  const logLevel = statefulStream(3\n  /* ERROR */);\n\n  const log = statefulStream(function (label, message) {\n    let level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var _a;\n    const currentLevel = (_a = getGlobalThis()[\"VIRTUOSO_LOG_LEVEL\"]) != null ? _a : getValue(logLevel);\n    if (level >= currentLevel) {\n      console[CONSOLE_METHOD_MAP[level]](\"%creact-virtuoso: %c%s %o\", \"color: #0253b3; font-weight: bold\", \"color: initial\", label, message);\n    }\n  });\n  return {\n    log,\n    logLevel\n  };\n}, [], {\n  singleton: true\n});\nfunction useSizeWithElRef(callback) {\n  let enabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  const ref = React.useRef(null);\n  let callbackRef = _el => {};\n  if (typeof ResizeObserver !== \"undefined\") {\n    const observer = React.useMemo(() => {\n      return new ResizeObserver(entries => {\n        const element = entries[0].target;\n        if (element.offsetParent !== null) {\n          callback(element);\n        }\n      });\n    }, [callback]);\n    callbackRef = elRef => {\n      if (elRef && enabled) {\n        observer.observe(elRef);\n        ref.current = elRef;\n      } else {\n        if (ref.current) {\n          observer.unobserve(ref.current);\n        }\n        ref.current = null;\n      }\n    };\n  }\n  return {\n    ref,\n    callbackRef\n  };\n}\nfunction useSize(callback) {\n  let enabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return useSizeWithElRef(callback, enabled).callbackRef;\n}\nfunction useChangedListContentsSizes(callback, itemSize, enabled, scrollContainerStateCallback, log, gap, customScrollParent) {\n  const memoedCallback = React.useCallback(el => {\n    const ranges = getChangedChildSizes(el.children, itemSize, \"offsetHeight\", log);\n    let scrollableElement = el.parentElement;\n    while (!scrollableElement.dataset[\"virtuosoScroller\"]) {\n      scrollableElement = scrollableElement.parentElement;\n    }\n    const windowScrolling = scrollableElement.lastElementChild.dataset[\"viewportType\"] === \"window\";\n    const scrollTop = customScrollParent ? customScrollParent.scrollTop : windowScrolling ? window.pageYOffset || document.documentElement.scrollTop : scrollableElement.scrollTop;\n    const scrollHeight = customScrollParent ? customScrollParent.scrollHeight : windowScrolling ? document.documentElement.scrollHeight : scrollableElement.scrollHeight;\n    const viewportHeight = customScrollParent ? customScrollParent.offsetHeight : windowScrolling ? window.innerHeight : scrollableElement.offsetHeight;\n    scrollContainerStateCallback({\n      scrollTop: Math.max(scrollTop, 0),\n      scrollHeight,\n      viewportHeight\n    });\n    gap == null ? void 0 : gap(resolveGapValue$1(\"row-gap\", getComputedStyle(el).rowGap, log));\n    if (ranges !== null) {\n      callback(ranges);\n    }\n  }, [callback, itemSize, log, gap, customScrollParent, scrollContainerStateCallback]);\n  return useSizeWithElRef(memoedCallback, enabled);\n}\nfunction getChangedChildSizes(children, itemSize, field, log) {\n  const length = children.length;\n  if (length === 0) {\n    return null;\n  }\n  const results = [];\n  for (let i = 0; i < length; i++) {\n    const child = children.item(i);\n    if (!child || child.dataset.index === void 0) {\n      continue;\n    }\n    const index = parseInt(child.dataset.index);\n    const knownSize = parseFloat(child.dataset.knownSize);\n    const size = itemSize(child, field);\n    if (size === 0) {\n      log(\"Zero-sized element, this should not happen\", {\n        child\n      }, LogLevel.ERROR);\n    }\n    if (size === knownSize) {\n      continue;\n    }\n    const lastResult = results[results.length - 1];\n    if (results.length === 0 || lastResult.size !== size || lastResult.endIndex !== index - 1) {\n      results.push({\n        startIndex: index,\n        endIndex: index,\n        size\n      });\n    } else {\n      results[results.length - 1].endIndex++;\n    }\n  }\n  return results;\n}\nfunction resolveGapValue$1(property, value, log) {\n  if (value !== \"normal\" && !(value == null ? void 0 : value.endsWith(\"px\"))) {\n    log(`${property} was not resolved to pixel value correctly`, value, LogLevel.WARN);\n  }\n  if (value === \"normal\") {\n    return 0;\n  }\n  return parseInt(value != null ? value : \"0\", 10);\n}\nfunction correctItemSize(el, dimension) {\n  return Math.round(el.getBoundingClientRect()[dimension]);\n}\nfunction approximatelyEqual(num1, num2) {\n  return Math.abs(num1 - num2) < 1.01;\n}\nfunction useScrollTop(scrollContainerStateCallback, smoothScrollTargetReached, scrollerElement) {\n  let scrollerRefCallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;\n  let customScrollParent = arguments.length > 4 ? arguments[4] : undefined;\n  const scrollerRef = React.useRef(null);\n  const scrollTopTarget = React.useRef(null);\n  const timeoutRef = React.useRef(null);\n  const handler = React.useCallback(ev => {\n    const el = ev.target;\n    const windowScroll = el === window || el === document;\n    const scrollTop = windowScroll ? window.pageYOffset || document.documentElement.scrollTop : el.scrollTop;\n    const scrollHeight = windowScroll ? document.documentElement.scrollHeight : el.scrollHeight;\n    const viewportHeight = windowScroll ? window.innerHeight : el.offsetHeight;\n    const call2 = () => {\n      scrollContainerStateCallback({\n        scrollTop: Math.max(scrollTop, 0),\n        scrollHeight,\n        viewportHeight\n      });\n    };\n    if (ev.suppressFlushSync) {\n      call2();\n    } else {\n      ReactDOM.flushSync(call2);\n    }\n    if (scrollTopTarget.current !== null) {\n      if (scrollTop === scrollTopTarget.current || scrollTop <= 0 || scrollTop === scrollHeight - viewportHeight) {\n        scrollTopTarget.current = null;\n        smoothScrollTargetReached(true);\n        if (timeoutRef.current) {\n          clearTimeout(timeoutRef.current);\n          timeoutRef.current = null;\n        }\n      }\n    }\n  }, [scrollContainerStateCallback, smoothScrollTargetReached]);\n  React.useEffect(() => {\n    const localRef = customScrollParent ? customScrollParent : scrollerRef.current;\n    scrollerRefCallback(customScrollParent ? customScrollParent : scrollerRef.current);\n    handler({\n      target: localRef,\n      suppressFlushSync: true\n    });\n    localRef.addEventListener(\"scroll\", handler, {\n      passive: true\n    });\n    return () => {\n      scrollerRefCallback(null);\n      localRef.removeEventListener(\"scroll\", handler);\n    };\n  }, [scrollerRef, handler, scrollerElement, scrollerRefCallback, customScrollParent]);\n  function scrollToCallback(location) {\n    const scrollerElement2 = scrollerRef.current;\n    if (!scrollerElement2 || \"offsetHeight\" in scrollerElement2 && scrollerElement2.offsetHeight === 0) {\n      return;\n    }\n    const isSmooth = location.behavior === \"smooth\";\n    let offsetHeight;\n    let scrollHeight;\n    let scrollTop;\n    if (scrollerElement2 === window) {\n      scrollHeight = Math.max(correctItemSize(document.documentElement, \"height\"), document.documentElement.scrollHeight);\n      offsetHeight = window.innerHeight;\n      scrollTop = document.documentElement.scrollTop;\n    } else {\n      scrollHeight = scrollerElement2.scrollHeight;\n      offsetHeight = correctItemSize(scrollerElement2, \"height\");\n      scrollTop = scrollerElement2.scrollTop;\n    }\n    const maxScrollTop = scrollHeight - offsetHeight;\n    location.top = Math.ceil(Math.max(Math.min(maxScrollTop, location.top), 0));\n    if (approximatelyEqual(offsetHeight, scrollHeight) || location.top === scrollTop) {\n      scrollContainerStateCallback({\n        scrollTop,\n        scrollHeight,\n        viewportHeight: offsetHeight\n      });\n      if (isSmooth) {\n        smoothScrollTargetReached(true);\n      }\n      return;\n    }\n    if (isSmooth) {\n      scrollTopTarget.current = location.top;\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n      timeoutRef.current = setTimeout(() => {\n        timeoutRef.current = null;\n        scrollTopTarget.current = null;\n        smoothScrollTargetReached(true);\n      }, 1e3);\n    } else {\n      scrollTopTarget.current = null;\n    }\n    scrollerElement2.scrollTo(location);\n  }\n  function scrollByCallback(location) {\n    scrollerRef.current.scrollBy(location);\n  }\n  return {\n    scrollerRef,\n    scrollByCallback,\n    scrollToCallback\n  };\n}\nconst domIOSystem = system(() => {\n  const scrollContainerState = stream();\n  const scrollTop = stream();\n  const deviation = statefulStream(0);\n  const smoothScrollTargetReached = stream();\n  const statefulScrollTop = statefulStream(0);\n  const viewportHeight = stream();\n  const scrollHeight = stream();\n  const headerHeight = statefulStream(0);\n  const fixedHeaderHeight = statefulStream(0);\n  const fixedFooterHeight = statefulStream(0);\n  const footerHeight = statefulStream(0);\n  const scrollTo = stream();\n  const scrollBy = stream();\n  const scrollingInProgress = statefulStream(false);\n  connect(pipe(scrollContainerState, map(_ref2 => {\n    let {\n      scrollTop: scrollTop2\n    } = _ref2;\n    return scrollTop2;\n  })), scrollTop);\n  connect(pipe(scrollContainerState, map(_ref3 => {\n    let {\n      scrollHeight: scrollHeight2\n    } = _ref3;\n    return scrollHeight2;\n  })), scrollHeight);\n  connect(scrollTop, statefulScrollTop);\n  return {\n    // input\n    scrollContainerState,\n    scrollTop,\n    viewportHeight,\n    headerHeight,\n    fixedHeaderHeight,\n    fixedFooterHeight,\n    footerHeight,\n    scrollHeight,\n    smoothScrollTargetReached,\n    // signals\n    scrollTo,\n    scrollBy,\n    // state\n    statefulScrollTop,\n    deviation,\n    scrollingInProgress\n  };\n}, [], {\n  singleton: true\n});\nconst NIL_NODE = {\n  lvl: 0\n};\nfunction newAANode(k, v, lvl) {\n  let l = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : NIL_NODE;\n  let r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : NIL_NODE;\n  return {\n    k,\n    v,\n    lvl,\n    l,\n    r\n  };\n}\nfunction empty(node) {\n  return node === NIL_NODE;\n}\nfunction newTree() {\n  return NIL_NODE;\n}\nfunction remove(node, key) {\n  if (empty(node)) return NIL_NODE;\n  const {\n    k,\n    l,\n    r\n  } = node;\n  if (key === k) {\n    if (empty(l)) {\n      return r;\n    } else if (empty(r)) {\n      return l;\n    } else {\n      const [lastKey, lastValue] = last(l);\n      return adjust(clone(node, {\n        k: lastKey,\n        v: lastValue,\n        l: deleteLast(l)\n      }));\n    }\n  } else if (key < k) {\n    return adjust(clone(node, {\n      l: remove(l, key)\n    }));\n  } else {\n    return adjust(clone(node, {\n      r: remove(r, key)\n    }));\n  }\n}\nfunction find(node, key) {\n  if (empty(node)) {\n    return;\n  }\n  if (key === node.k) {\n    return node.v;\n  } else if (key < node.k) {\n    return find(node.l, key);\n  } else {\n    return find(node.r, key);\n  }\n}\nfunction findMaxKeyValue(node, value) {\n  let field = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"k\";\n  if (empty(node)) {\n    return [-Infinity, void 0];\n  }\n  if (Number(node[field]) === value) {\n    return [node.k, node.v];\n  }\n  if (Number(node[field]) < value) {\n    const r = findMaxKeyValue(node.r, value, field);\n    if (r[0] === -Infinity) {\n      return [node.k, node.v];\n    } else {\n      return r;\n    }\n  }\n  return findMaxKeyValue(node.l, value, field);\n}\nfunction insert(node, k, v) {\n  if (empty(node)) {\n    return newAANode(k, v, 1);\n  }\n  if (k === node.k) {\n    return clone(node, {\n      k,\n      v\n    });\n  } else if (k < node.k) {\n    return rebalance(clone(node, {\n      l: insert(node.l, k, v)\n    }));\n  } else {\n    return rebalance(clone(node, {\n      r: insert(node.r, k, v)\n    }));\n  }\n}\nfunction walkWithin(node, start, end) {\n  if (empty(node)) {\n    return [];\n  }\n  const {\n    k,\n    v,\n    l,\n    r\n  } = node;\n  let result = [];\n  if (k > start) {\n    result = result.concat(walkWithin(l, start, end));\n  }\n  if (k >= start && k <= end) {\n    result.push({\n      k,\n      v\n    });\n  }\n  if (k <= end) {\n    result = result.concat(walkWithin(r, start, end));\n  }\n  return result;\n}\nfunction walk(node) {\n  if (empty(node)) {\n    return [];\n  }\n  return [...walk(node.l), {\n    k: node.k,\n    v: node.v\n  }, ...walk(node.r)];\n}\nfunction last(node) {\n  return empty(node.r) ? [node.k, node.v] : last(node.r);\n}\nfunction deleteLast(node) {\n  return empty(node.r) ? node.l : adjust(clone(node, {\n    r: deleteLast(node.r)\n  }));\n}\nfunction clone(node, args) {\n  return newAANode(args.k !== void 0 ? args.k : node.k, args.v !== void 0 ? args.v : node.v, args.lvl !== void 0 ? args.lvl : node.lvl, args.l !== void 0 ? args.l : node.l, args.r !== void 0 ? args.r : node.r);\n}\nfunction isSingle(node) {\n  return empty(node) || node.lvl > node.r.lvl;\n}\nfunction rebalance(node) {\n  return split(skew(node));\n}\nfunction adjust(node) {\n  const {\n    l,\n    r,\n    lvl\n  } = node;\n  if (r.lvl >= lvl - 1 && l.lvl >= lvl - 1) {\n    return node;\n  } else if (lvl > r.lvl + 1) {\n    if (isSingle(l)) {\n      return skew(clone(node, {\n        lvl: lvl - 1\n      }));\n    } else {\n      if (!empty(l) && !empty(l.r)) {\n        return clone(l.r, {\n          l: clone(l, {\n            r: l.r.l\n          }),\n          r: clone(node, {\n            l: l.r.r,\n            lvl: lvl - 1\n          }),\n          lvl\n        });\n      } else {\n        throw new Error(\"Unexpected empty nodes\");\n      }\n    }\n  } else {\n    if (isSingle(node)) {\n      return split(clone(node, {\n        lvl: lvl - 1\n      }));\n    } else {\n      if (!empty(r) && !empty(r.l)) {\n        const rl = r.l;\n        const rlvl = isSingle(rl) ? r.lvl - 1 : r.lvl;\n        return clone(rl, {\n          l: clone(node, {\n            r: rl.l,\n            lvl: lvl - 1\n          }),\n          r: split(clone(r, {\n            l: rl.r,\n            lvl: rlvl\n          })),\n          lvl: rl.lvl + 1\n        });\n      } else {\n        throw new Error(\"Unexpected empty nodes\");\n      }\n    }\n  }\n}\nfunction rangesWithin(node, startIndex, endIndex) {\n  if (empty(node)) {\n    return [];\n  }\n  const adjustedStart = findMaxKeyValue(node, startIndex)[0];\n  return toRanges(walkWithin(node, adjustedStart, endIndex));\n}\nfunction arrayToRanges(items, parser) {\n  const length = items.length;\n  if (length === 0) {\n    return [];\n  }\n  let {\n    index: start,\n    value\n  } = parser(items[0]);\n  const result = [];\n  for (let i = 1; i < length; i++) {\n    const {\n      index: nextIndex,\n      value: nextValue\n    } = parser(items[i]);\n    result.push({\n      start,\n      end: nextIndex - 1,\n      value\n    });\n    start = nextIndex;\n    value = nextValue;\n  }\n  result.push({\n    start,\n    end: Infinity,\n    value\n  });\n  return result;\n}\nfunction toRanges(nodes) {\n  return arrayToRanges(nodes, _ref4 => {\n    let {\n      k: index,\n      v: value\n    } = _ref4;\n    return {\n      index,\n      value\n    };\n  });\n}\nfunction split(node) {\n  const {\n    r,\n    lvl\n  } = node;\n  return !empty(r) && !empty(r.r) && r.lvl === lvl && r.r.lvl === lvl ? clone(r, {\n    l: clone(node, {\n      r: r.l\n    }),\n    lvl: lvl + 1\n  }) : node;\n}\nfunction skew(node) {\n  const {\n    l\n  } = node;\n  return !empty(l) && l.lvl === node.lvl ? clone(l, {\n    r: clone(node, {\n      l: l.r\n    })\n  }) : node;\n}\nfunction findIndexOfClosestSmallerOrEqual(items, value, comparator) {\n  let start = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let end = items.length - 1;\n  while (start <= end) {\n    const index = Math.floor((start + end) / 2);\n    const item = items[index];\n    const match = comparator(item, value);\n    if (match === 0) {\n      return index;\n    }\n    if (match === -1) {\n      if (end - start < 2) {\n        return index - 1;\n      }\n      end = index - 1;\n    } else {\n      if (end === start) {\n        return index;\n      }\n      start = index + 1;\n    }\n  }\n  throw new Error(`Failed binary finding record in array - ${items.join(\",\")}, searched for ${value}`);\n}\nfunction findClosestSmallerOrEqual(items, value, comparator) {\n  return items[findIndexOfClosestSmallerOrEqual(items, value, comparator)];\n}\nfunction findRange(items, startValue, endValue, comparator) {\n  const startIndex = findIndexOfClosestSmallerOrEqual(items, startValue, comparator);\n  const endIndex = findIndexOfClosestSmallerOrEqual(items, endValue, comparator, startIndex);\n  return items.slice(startIndex, endIndex + 1);\n}\nconst recalcSystem = system(() => {\n  const recalcInProgress = statefulStream(false);\n  return {\n    recalcInProgress\n  };\n}, [], {\n  singleton: true\n});\nfunction rangeIncludes(refRange) {\n  const {\n    size,\n    startIndex,\n    endIndex\n  } = refRange;\n  return range => {\n    return range.start === startIndex && (range.end === endIndex || range.end === Infinity) && range.value === size;\n  };\n}\nfunction affectedGroupCount(offset, groupIndices) {\n  let recognizedOffsetItems = 0;\n  let groupIndex = 0;\n  while (recognizedOffsetItems < offset) {\n    recognizedOffsetItems += groupIndices[groupIndex + 1] - groupIndices[groupIndex] - 1;\n    groupIndex++;\n  }\n  const offsetIsExact = recognizedOffsetItems === offset;\n  return groupIndex - (offsetIsExact ? 0 : 1);\n}\nfunction insertRanges(sizeTree, ranges) {\n  let syncStart = empty(sizeTree) ? 0 : Infinity;\n  for (const range of ranges) {\n    const {\n      size,\n      startIndex,\n      endIndex\n    } = range;\n    syncStart = Math.min(syncStart, startIndex);\n    if (empty(sizeTree)) {\n      sizeTree = insert(sizeTree, 0, size);\n      continue;\n    }\n    const overlappingRanges = rangesWithin(sizeTree, startIndex - 1, endIndex + 1);\n    if (overlappingRanges.some(rangeIncludes(range))) {\n      continue;\n    }\n    let firstPassDone = false;\n    let shouldInsert = false;\n    for (const {\n      start: rangeStart,\n      end: rangeEnd,\n      value: rangeValue\n    } of overlappingRanges) {\n      if (!firstPassDone) {\n        shouldInsert = rangeValue !== size;\n        firstPassDone = true;\n      } else {\n        if (endIndex >= rangeStart || size === rangeValue) {\n          sizeTree = remove(sizeTree, rangeStart);\n        }\n      }\n      if (rangeEnd > endIndex && endIndex >= rangeStart) {\n        if (rangeValue !== size) {\n          sizeTree = insert(sizeTree, endIndex + 1, rangeValue);\n        }\n      }\n    }\n    if (shouldInsert) {\n      sizeTree = insert(sizeTree, startIndex, size);\n    }\n  }\n  return [sizeTree, syncStart];\n}\nfunction initialSizeState() {\n  return {\n    offsetTree: [],\n    sizeTree: newTree(),\n    groupOffsetTree: newTree(),\n    lastIndex: 0,\n    lastOffset: 0,\n    lastSize: 0,\n    groupIndices: []\n  };\n}\nfunction indexComparator(_ref5, index) {\n  let {\n    index: itemIndex\n  } = _ref5;\n  return index === itemIndex ? 0 : index < itemIndex ? -1 : 1;\n}\nfunction offsetComparator(_ref6, offset) {\n  let {\n    offset: itemOffset\n  } = _ref6;\n  return offset === itemOffset ? 0 : offset < itemOffset ? -1 : 1;\n}\nfunction offsetPointParser(point) {\n  return {\n    index: point.index,\n    value: point\n  };\n}\nfunction rangesWithinOffsets(tree, startOffset, endOffset) {\n  let minStartIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  if (minStartIndex > 0) {\n    startOffset = Math.max(startOffset, findClosestSmallerOrEqual(tree, minStartIndex, indexComparator).offset);\n  }\n  return arrayToRanges(findRange(tree, startOffset, endOffset, offsetComparator), offsetPointParser);\n}\nfunction createOffsetTree(prevOffsetTree, syncStart, sizeTree, gap) {\n  let offsetTree = prevOffsetTree;\n  let prevIndex = 0;\n  let prevSize = 0;\n  let prevOffset = 0;\n  let startIndex = 0;\n  if (syncStart !== 0) {\n    startIndex = findIndexOfClosestSmallerOrEqual(offsetTree, syncStart - 1, indexComparator);\n    const offsetInfo = offsetTree[startIndex];\n    prevOffset = offsetInfo.offset;\n    const kv = findMaxKeyValue(sizeTree, syncStart - 1);\n    prevIndex = kv[0];\n    prevSize = kv[1];\n    if (offsetTree.length && offsetTree[startIndex].size === findMaxKeyValue(sizeTree, syncStart)[1]) {\n      startIndex -= 1;\n    }\n    offsetTree = offsetTree.slice(0, startIndex + 1);\n  } else {\n    offsetTree = [];\n  }\n  for (const {\n    start: startIndex2,\n    value\n  } of rangesWithin(sizeTree, syncStart, Infinity)) {\n    const indexOffset = startIndex2 - prevIndex;\n    const aOffset = indexOffset * prevSize + prevOffset + indexOffset * gap;\n    offsetTree.push({\n      offset: aOffset,\n      size: value,\n      index: startIndex2\n    });\n    prevIndex = startIndex2;\n    prevOffset = aOffset;\n    prevSize = value;\n  }\n  return {\n    offsetTree,\n    lastIndex: prevIndex,\n    lastOffset: prevOffset,\n    lastSize: prevSize\n  };\n}\nfunction sizeStateReducer(state, _ref7) {\n  let [ranges, groupIndices, log, gap] = _ref7;\n  if (ranges.length > 0) {\n    log(\"received item sizes\", ranges, LogLevel.DEBUG);\n  }\n  const sizeTree = state.sizeTree;\n  let newSizeTree = sizeTree;\n  let syncStart = 0;\n  if (groupIndices.length > 0 && empty(sizeTree) && ranges.length === 2) {\n    const groupSize = ranges[0].size;\n    const itemSize = ranges[1].size;\n    newSizeTree = groupIndices.reduce((tree, groupIndex) => {\n      return insert(insert(tree, groupIndex, groupSize), groupIndex + 1, itemSize);\n    }, newSizeTree);\n  } else {\n    [newSizeTree, syncStart] = insertRanges(newSizeTree, ranges);\n  }\n  if (newSizeTree === sizeTree) {\n    return state;\n  }\n  const {\n    offsetTree: newOffsetTree,\n    lastIndex,\n    lastSize,\n    lastOffset\n  } = createOffsetTree(state.offsetTree, syncStart, newSizeTree, gap);\n  return {\n    sizeTree: newSizeTree,\n    offsetTree: newOffsetTree,\n    lastIndex,\n    lastOffset,\n    lastSize,\n    groupOffsetTree: groupIndices.reduce((tree, index) => {\n      return insert(tree, index, offsetOf(index, newOffsetTree, gap));\n    }, newTree()),\n    groupIndices\n  };\n}\nfunction offsetOf(index, tree, gap) {\n  if (tree.length === 0) {\n    return 0;\n  }\n  const {\n    offset,\n    index: startIndex,\n    size\n  } = findClosestSmallerOrEqual(tree, index, indexComparator);\n  const itemCount = index - startIndex;\n  const top = size * itemCount + (itemCount - 1) * gap + offset;\n  return top > 0 ? top + gap : top;\n}\nfunction isGroupLocation(location) {\n  return typeof location.groupIndex !== \"undefined\";\n}\nfunction originalIndexFromLocation(location, sizes, lastIndex) {\n  if (isGroupLocation(location)) {\n    return sizes.groupIndices[location.groupIndex] + 1;\n  } else {\n    const numericIndex = location.index === \"LAST\" ? lastIndex : location.index;\n    let result = originalIndexFromItemIndex(numericIndex, sizes);\n    result = Math.max(0, result, Math.min(lastIndex, result));\n    return result;\n  }\n}\nfunction originalIndexFromItemIndex(itemIndex, sizes) {\n  if (!hasGroups(sizes)) {\n    return itemIndex;\n  }\n  let groupOffset = 0;\n  while (sizes.groupIndices[groupOffset] <= itemIndex + groupOffset) {\n    groupOffset++;\n  }\n  return itemIndex + groupOffset;\n}\nfunction hasGroups(sizes) {\n  return !empty(sizes.groupOffsetTree);\n}\nfunction sizeTreeToRanges(sizeTree) {\n  return walk(sizeTree).map((_ref8, index, sizeArray) => {\n    let {\n      k: startIndex,\n      v: size\n    } = _ref8;\n    const nextSize = sizeArray[index + 1];\n    const endIndex = nextSize ? nextSize.k - 1 : Infinity;\n    return {\n      startIndex,\n      endIndex,\n      size\n    };\n  });\n}\nconst SIZE_MAP = {\n  offsetHeight: \"height\",\n  offsetWidth: \"width\"\n};\nconst sizeSystem = system(_ref9 => {\n  let [{\n    log\n  }, {\n    recalcInProgress\n  }] = _ref9;\n  const sizeRanges = stream();\n  const totalCount = stream();\n  const statefulTotalCount = statefulStreamFromEmitter(totalCount, 0);\n  const unshiftWith = stream();\n  const shiftWith = stream();\n  const firstItemIndex = statefulStream(0);\n  const groupIndices = statefulStream([]);\n  const fixedItemSize = statefulStream(void 0);\n  const defaultItemSize = statefulStream(void 0);\n  const itemSize = statefulStream((el, field) => correctItemSize(el, SIZE_MAP[field]));\n  const data = statefulStream(void 0);\n  const gap = statefulStream(0);\n  const initial = initialSizeState();\n  const sizes = statefulStreamFromEmitter(pipe(sizeRanges, withLatestFrom(groupIndices, log, gap), scan(sizeStateReducer, initial), distinctUntilChanged()), initial);\n  const prevGroupIndices = statefulStreamFromEmitter(pipe(groupIndices, distinctUntilChanged(), scan((prev, curr) => ({\n    prev: prev.current,\n    current: curr\n  }), {\n    prev: [],\n    current: []\n  }), map(_ref10 => {\n    let {\n      prev\n    } = _ref10;\n    return prev;\n  })), []);\n  connect(pipe(groupIndices, filter(indexes => indexes.length > 0), withLatestFrom(sizes, gap), map(_ref11 => {\n    let [groupIndices2, sizes2, gap2] = _ref11;\n    const groupOffsetTree = groupIndices2.reduce((tree, index, idx) => {\n      return insert(tree, index, offsetOf(index, sizes2.offsetTree, gap2) || idx);\n    }, newTree());\n    return {\n      ...sizes2,\n      groupIndices: groupIndices2,\n      groupOffsetTree\n    };\n  })), sizes);\n  connect(pipe(totalCount, withLatestFrom(sizes), filter(_ref12 => {\n    let [totalCount2, {\n      lastIndex,\n      groupIndices: groupIndices2\n    }] = _ref12;\n    return totalCount2 < lastIndex && groupIndices2.length === 0;\n  }), map(_ref13 => {\n    let [totalCount2, {\n      lastIndex,\n      lastSize\n    }] = _ref13;\n    return [{\n      startIndex: totalCount2,\n      endIndex: lastIndex,\n      size: lastSize\n    }];\n  })), sizeRanges);\n  connect(fixedItemSize, defaultItemSize);\n  const trackItemSizes = statefulStreamFromEmitter(pipe(fixedItemSize, map(size => size === void 0)), true);\n  connect(pipe(defaultItemSize, filter(value => {\n    return value !== void 0 && empty(getValue(sizes).sizeTree);\n  }), map(size => [{\n    startIndex: 0,\n    endIndex: 0,\n    size\n  }])), sizeRanges);\n  const listRefresh = streamFromEmitter(pipe(sizeRanges, withLatestFrom(sizes), scan((_ref14, _ref15) => {\n    let {\n      sizes: oldSizes\n    } = _ref14;\n    let [_, newSizes] = _ref15;\n    return {\n      changed: newSizes !== oldSizes,\n      sizes: newSizes\n    };\n  }, {\n    changed: false,\n    sizes: initial\n  }), map(value => value.changed)));\n  subscribe(pipe(firstItemIndex, scan((prev, next) => {\n    return {\n      diff: prev.prev - next,\n      prev: next\n    };\n  }, {\n    diff: 0,\n    prev: 0\n  }), map(val => val.diff)), offset => {\n    const {\n      groupIndices: groupIndices2\n    } = getValue(sizes);\n    if (offset > 0) {\n      publish(recalcInProgress, true);\n      publish(unshiftWith, offset + affectedGroupCount(offset, groupIndices2));\n    } else if (offset < 0) {\n      const prevGroupIndicesValue = getValue(prevGroupIndices);\n      if (prevGroupIndicesValue.length > 0) {\n        offset -= affectedGroupCount(-offset, prevGroupIndicesValue);\n      }\n      publish(shiftWith, offset);\n    }\n  });\n  subscribe(pipe(firstItemIndex, withLatestFrom(log)), _ref16 => {\n    let [index, log2] = _ref16;\n    if (index < 0) {\n      log2(\"`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value\", {\n        firstItemIndex\n      }, LogLevel.ERROR);\n    }\n  });\n  const beforeUnshiftWith = streamFromEmitter(unshiftWith);\n  connect(pipe(unshiftWith, withLatestFrom(sizes), map(_ref17 => {\n    let [unshiftWith2, sizes2] = _ref17;\n    const groupedMode = sizes2.groupIndices.length > 0;\n    const initialRanges = [];\n    const defaultSize = sizes2.lastSize;\n    if (groupedMode) {\n      const firstGroupSize = find(sizes2.sizeTree, 0);\n      let prependedGroupItemsCount = 0;\n      let groupIndex = 0;\n      while (prependedGroupItemsCount < unshiftWith2) {\n        const theGroupIndex = sizes2.groupIndices[groupIndex];\n        const groupItemCount = sizes2.groupIndices.length === groupIndex + 1 ? Infinity : sizes2.groupIndices[groupIndex + 1] - theGroupIndex - 1;\n        initialRanges.push({\n          startIndex: theGroupIndex,\n          endIndex: theGroupIndex,\n          size: firstGroupSize\n        });\n        initialRanges.push({\n          startIndex: theGroupIndex + 1,\n          endIndex: theGroupIndex + 1 + groupItemCount - 1,\n          size: defaultSize\n        });\n        groupIndex++;\n        prependedGroupItemsCount += groupItemCount + 1;\n      }\n      const sizeTreeKV = walk(sizes2.sizeTree);\n      const firstGroupIsExpanded = prependedGroupItemsCount !== unshiftWith2;\n      if (firstGroupIsExpanded) {\n        sizeTreeKV.shift();\n      }\n      return sizeTreeKV.reduce((acc, _ref18) => {\n        let {\n          k: index,\n          v: size\n        } = _ref18;\n        let ranges = acc.ranges;\n        if (acc.prevSize !== 0) {\n          ranges = [...acc.ranges, {\n            startIndex: acc.prevIndex,\n            endIndex: index + unshiftWith2 - 1,\n            size: acc.prevSize\n          }];\n        }\n        return {\n          ranges,\n          prevIndex: index + unshiftWith2,\n          prevSize: size\n        };\n      }, {\n        ranges: initialRanges,\n        prevIndex: unshiftWith2,\n        prevSize: 0\n      }).ranges;\n    }\n    return walk(sizes2.sizeTree).reduce((acc, _ref19) => {\n      let {\n        k: index,\n        v: size\n      } = _ref19;\n      return {\n        ranges: [...acc.ranges, {\n          startIndex: acc.prevIndex,\n          endIndex: index + unshiftWith2 - 1,\n          size: acc.prevSize\n        }],\n        prevIndex: index + unshiftWith2,\n        prevSize: size\n      };\n    }, {\n      ranges: [],\n      prevIndex: 0,\n      prevSize: defaultSize\n    }).ranges;\n  })), sizeRanges);\n  const shiftWithOffset = streamFromEmitter(pipe(shiftWith, withLatestFrom(sizes, gap), map(_ref20 => {\n    let [shiftWith2, {\n      offsetTree\n    }, gap2] = _ref20;\n    const newFirstItemIndex = -shiftWith2;\n    return offsetOf(newFirstItemIndex, offsetTree, gap2);\n  })));\n  connect(pipe(shiftWith, withLatestFrom(sizes, gap), map(_ref21 => {\n    let [shiftWith2, sizes2, gap2] = _ref21;\n    const groupedMode = sizes2.groupIndices.length > 0;\n    if (groupedMode) {\n      if (empty(sizes2.sizeTree)) {\n        return sizes2;\n      }\n      let newSizeTree = newTree();\n      const prevGroupIndicesValue = getValue(prevGroupIndices);\n      let removedItemsCount = 0;\n      let groupIndex = 0;\n      let groupOffset = 0;\n      while (removedItemsCount < -shiftWith2) {\n        groupOffset = prevGroupIndicesValue[groupIndex];\n        const groupItemCount = prevGroupIndicesValue[groupIndex + 1] - groupOffset - 1;\n        groupIndex++;\n        removedItemsCount += groupItemCount + 1;\n      }\n      newSizeTree = walk(sizes2.sizeTree).reduce((acc, _ref22) => {\n        let {\n          k,\n          v\n        } = _ref22;\n        return insert(acc, Math.max(0, k + shiftWith2), v);\n      }, newSizeTree);\n      const aGroupIsShrunk = removedItemsCount !== -shiftWith2;\n      if (aGroupIsShrunk) {\n        const firstGroupSize = find(sizes2.sizeTree, groupOffset);\n        newSizeTree = insert(newSizeTree, 0, firstGroupSize);\n        const nextItemSize = findMaxKeyValue(sizes2.sizeTree, -shiftWith2 + 1)[1];\n        newSizeTree = insert(newSizeTree, 1, nextItemSize);\n      }\n      return {\n        ...sizes2,\n        sizeTree: newSizeTree,\n        ...createOffsetTree(sizes2.offsetTree, 0, newSizeTree, gap2)\n      };\n    } else {\n      const newSizeTree = walk(sizes2.sizeTree).reduce((acc, _ref23) => {\n        let {\n          k,\n          v\n        } = _ref23;\n        return insert(acc, Math.max(0, k + shiftWith2), v);\n      }, newTree());\n      return {\n        ...sizes2,\n        sizeTree: newSizeTree,\n        ...createOffsetTree(sizes2.offsetTree, 0, newSizeTree, gap2)\n      };\n    }\n  })), sizes);\n  return {\n    // input\n    data,\n    totalCount,\n    sizeRanges,\n    groupIndices,\n    defaultItemSize,\n    fixedItemSize,\n    unshiftWith,\n    shiftWith,\n    shiftWithOffset,\n    beforeUnshiftWith,\n    firstItemIndex,\n    gap,\n    // output\n    sizes,\n    listRefresh,\n    statefulTotalCount,\n    trackItemSizes,\n    itemSize\n  };\n}, tup(loggerSystem, recalcSystem), {\n  singleton: true\n});\nconst SUPPORTS_SCROLL_TO_OPTIONS = typeof document !== \"undefined\" && \"scrollBehavior\" in document.documentElement.style;\nfunction normalizeIndexLocation(location) {\n  const result = typeof location === \"number\" ? {\n    index: location\n  } : location;\n  if (!result.align) {\n    result.align = \"start\";\n  }\n  if (!result.behavior || !SUPPORTS_SCROLL_TO_OPTIONS) {\n    result.behavior = \"auto\";\n  }\n  if (!result.offset) {\n    result.offset = 0;\n  }\n  return result;\n}\nconst scrollToIndexSystem = system(_ref24 => {\n  let [{\n    sizes,\n    totalCount,\n    listRefresh,\n    gap\n  }, {\n    scrollingInProgress,\n    viewportHeight,\n    scrollTo,\n    smoothScrollTargetReached,\n    headerHeight,\n    footerHeight,\n    fixedHeaderHeight,\n    fixedFooterHeight\n  }, {\n    log\n  }] = _ref24;\n  const scrollToIndex = stream();\n  const topListHeight = statefulStream(0);\n  let unsubscribeNextListRefresh = null;\n  let cleartTimeoutRef = null;\n  let unsubscribeListRefresh = null;\n  function cleanup() {\n    if (unsubscribeNextListRefresh) {\n      unsubscribeNextListRefresh();\n      unsubscribeNextListRefresh = null;\n    }\n    if (unsubscribeListRefresh) {\n      unsubscribeListRefresh();\n      unsubscribeListRefresh = null;\n    }\n    if (cleartTimeoutRef) {\n      clearTimeout(cleartTimeoutRef);\n      cleartTimeoutRef = null;\n    }\n    publish(scrollingInProgress, false);\n  }\n  connect(pipe(scrollToIndex, withLatestFrom(sizes, viewportHeight, totalCount, topListHeight, headerHeight, footerHeight, log), withLatestFrom(gap, fixedHeaderHeight, fixedFooterHeight), map(_ref25 => {\n    let [[location, sizes2, viewportHeight2, totalCount2, topListHeight2, headerHeight2, footerHeight2, log2], gap2, fixedHeaderHeight2, fixedFooterHeight2] = _ref25;\n    const normalLocation = normalizeIndexLocation(location);\n    const {\n      align,\n      behavior,\n      offset\n    } = normalLocation;\n    const lastIndex = totalCount2 - 1;\n    const index = originalIndexFromLocation(normalLocation, sizes2, lastIndex);\n    let top = offsetOf(index, sizes2.offsetTree, gap2) + headerHeight2;\n    if (align === \"end\") {\n      top += fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index)[1] - viewportHeight2 + fixedFooterHeight2;\n      if (index === lastIndex) {\n        top += footerHeight2;\n      }\n    } else if (align === \"center\") {\n      top += (fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index)[1] - viewportHeight2 + fixedFooterHeight2) / 2;\n    } else {\n      top -= topListHeight2;\n    }\n    if (offset) {\n      top += offset;\n    }\n    const retry = listChanged => {\n      cleanup();\n      if (listChanged) {\n        log2(\"retrying to scroll to\", {\n          location\n        }, LogLevel.DEBUG);\n        publish(scrollToIndex, location);\n      } else {\n        log2(\"list did not change, scroll successful\", {}, LogLevel.DEBUG);\n      }\n    };\n    cleanup();\n    if (behavior === \"smooth\") {\n      let listChanged = false;\n      unsubscribeListRefresh = subscribe(listRefresh, changed => {\n        listChanged = listChanged || changed;\n      });\n      unsubscribeNextListRefresh = handleNext(smoothScrollTargetReached, () => {\n        retry(listChanged);\n      });\n    } else {\n      unsubscribeNextListRefresh = handleNext(pipe(listRefresh, watchChangesFor(150)), retry);\n    }\n    cleartTimeoutRef = setTimeout(() => {\n      cleanup();\n    }, 1200);\n    publish(scrollingInProgress, true);\n    log2(\"scrolling from index to\", {\n      index,\n      top,\n      behavior\n    }, LogLevel.DEBUG);\n    return {\n      top,\n      behavior\n    };\n  })), scrollTo);\n  return {\n    scrollToIndex,\n    topListHeight\n  };\n}, tup(sizeSystem, domIOSystem, loggerSystem), {\n  singleton: true\n});\nfunction watchChangesFor(limit) {\n  return done => {\n    const timeoutRef = setTimeout(() => {\n      done(false);\n    }, limit);\n    return value => {\n      if (value) {\n        done(true);\n        clearTimeout(timeoutRef);\n      }\n    };\n  };\n}\nconst UP = \"up\";\nconst DOWN = \"down\";\nconst NONE$1 = \"none\";\nconst INITIAL_BOTTOM_STATE = {\n  atBottom: false,\n  notAtBottomBecause: \"NOT_SHOWING_LAST_ITEM\",\n  state: {\n    offsetBottom: 0,\n    scrollTop: 0,\n    viewportHeight: 0,\n    scrollHeight: 0\n  }\n};\nconst DEFAULT_AT_TOP_THRESHOLD = 0;\nconst stateFlagsSystem = system(_ref26 => {\n  let [{\n    scrollContainerState,\n    scrollTop,\n    viewportHeight,\n    headerHeight,\n    footerHeight,\n    scrollBy\n  }] = _ref26;\n  const isAtBottom = statefulStream(false);\n  const isAtTop = statefulStream(true);\n  const atBottomStateChange = stream();\n  const atTopStateChange = stream();\n  const atBottomThreshold = statefulStream(4);\n  const atTopThreshold = statefulStream(DEFAULT_AT_TOP_THRESHOLD);\n  const isScrolling = statefulStreamFromEmitter(pipe(merge(pipe(duc(scrollTop), skip(1), mapTo(true)), pipe(duc(scrollTop), skip(1), mapTo(false), debounceTime(100))), distinctUntilChanged()), false);\n  const isScrollingBy = statefulStreamFromEmitter(pipe(merge(pipe(scrollBy, mapTo(true)), pipe(scrollBy, mapTo(false), debounceTime(200))), distinctUntilChanged()), false);\n  connect(pipe(combineLatest(duc(scrollTop), duc(atTopThreshold)), map(_ref27 => {\n    let [top, atTopThreshold2] = _ref27;\n    return top <= atTopThreshold2;\n  }), distinctUntilChanged()), isAtTop);\n  connect(pipe(isAtTop, throttleTime(50)), atTopStateChange);\n  const atBottomState = streamFromEmitter(pipe(combineLatest(scrollContainerState, duc(viewportHeight), duc(headerHeight), duc(footerHeight), duc(atBottomThreshold)), scan((current, _ref28) => {\n    let [{\n      scrollTop: scrollTop2,\n      scrollHeight\n    }, viewportHeight2, _headerHeight, _footerHeight, atBottomThreshold2] = _ref28;\n    const isAtBottom2 = scrollTop2 + viewportHeight2 - scrollHeight > -atBottomThreshold2;\n    const state = {\n      viewportHeight: viewportHeight2,\n      scrollTop: scrollTop2,\n      scrollHeight\n    };\n    if (isAtBottom2) {\n      let atBottomBecause;\n      let scrollTopDelta;\n      if (scrollTop2 > current.state.scrollTop) {\n        atBottomBecause = \"SCROLLED_DOWN\";\n        scrollTopDelta = current.state.scrollTop - scrollTop2;\n      } else {\n        atBottomBecause = \"SIZE_DECREASED\";\n        scrollTopDelta = current.state.scrollTop - scrollTop2 || current.scrollTopDelta;\n      }\n      return {\n        atBottom: true,\n        state,\n        atBottomBecause,\n        scrollTopDelta\n      };\n    }\n    let notAtBottomBecause;\n    if (state.scrollHeight > current.state.scrollHeight) {\n      notAtBottomBecause = \"SIZE_INCREASED\";\n    } else if (viewportHeight2 < current.state.viewportHeight) {\n      notAtBottomBecause = \"VIEWPORT_HEIGHT_DECREASING\";\n    } else if (scrollTop2 < current.state.scrollTop) {\n      notAtBottomBecause = \"SCROLLING_UPWARDS\";\n    } else {\n      notAtBottomBecause = \"NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM\";\n    }\n    return {\n      atBottom: false,\n      notAtBottomBecause,\n      state\n    };\n  }, INITIAL_BOTTOM_STATE), distinctUntilChanged((prev, next) => {\n    return prev && prev.atBottom === next.atBottom;\n  })));\n  const lastJumpDueToItemResize = statefulStreamFromEmitter(pipe(scrollContainerState, scan((current, _ref29) => {\n    let {\n      scrollTop: scrollTop2,\n      scrollHeight,\n      viewportHeight: viewportHeight2\n    } = _ref29;\n    if (!approximatelyEqual(current.scrollHeight, scrollHeight)) {\n      const atBottom = scrollHeight - (scrollTop2 + viewportHeight2) < 1;\n      if (current.scrollTop !== scrollTop2 && atBottom) {\n        return {\n          scrollHeight,\n          scrollTop: scrollTop2,\n          jump: current.scrollTop - scrollTop2,\n          changed: true\n        };\n      } else {\n        return {\n          scrollHeight,\n          scrollTop: scrollTop2,\n          jump: 0,\n          changed: true\n        };\n      }\n    } else {\n      return {\n        scrollTop: scrollTop2,\n        scrollHeight,\n        jump: 0,\n        changed: false\n      };\n    }\n  }, {\n    scrollHeight: 0,\n    jump: 0,\n    scrollTop: 0,\n    changed: false\n  }), filter(value => value.changed), map(value => value.jump)), 0);\n  connect(pipe(atBottomState, map(state => state.atBottom)), isAtBottom);\n  connect(pipe(isAtBottom, throttleTime(50)), atBottomStateChange);\n  const scrollDirection = statefulStream(DOWN);\n  connect(pipe(scrollContainerState, map(_ref30 => {\n    let {\n      scrollTop: scrollTop2\n    } = _ref30;\n    return scrollTop2;\n  }), distinctUntilChanged(), scan((acc, scrollTop2) => {\n    if (getValue(isScrollingBy)) {\n      return {\n        direction: acc.direction,\n        prevScrollTop: scrollTop2\n      };\n    }\n    return {\n      direction: scrollTop2 < acc.prevScrollTop ? UP : DOWN,\n      prevScrollTop: scrollTop2\n    };\n  }, {\n    direction: DOWN,\n    prevScrollTop: 0\n  }), map(value => value.direction)), scrollDirection);\n  connect(pipe(scrollContainerState, throttleTime(50), mapTo(NONE$1)), scrollDirection);\n  const scrollVelocity = statefulStream(0);\n  connect(pipe(isScrolling, filter(value => !value),\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n  mapTo(0)), scrollVelocity);\n  connect(pipe(scrollTop, throttleTime(100), withLatestFrom(isScrolling), filter(_ref31 => {\n    let [_, isScrolling2] = _ref31;\n    return !!isScrolling2;\n  }), scan((_ref32, _ref33) => {\n    let [_, prev] = _ref32;\n    let [next] = _ref33;\n    return [prev, next];\n  }, [0, 0]), map(_ref34 => {\n    let [prev, next] = _ref34;\n    return next - prev;\n  })), scrollVelocity);\n  return {\n    isScrolling,\n    isAtTop,\n    isAtBottom,\n    atBottomState,\n    atTopStateChange,\n    atBottomStateChange,\n    scrollDirection,\n    atBottomThreshold,\n    atTopThreshold,\n    scrollVelocity,\n    lastJumpDueToItemResize\n  };\n}, tup(domIOSystem));\nconst propsReadySystem = system(_ref35 => {\n  let [{\n    log\n  }] = _ref35;\n  const propsReady = statefulStream(false);\n  const didMount = streamFromEmitter(pipe(propsReady, filter(ready => ready), distinctUntilChanged()));\n  subscribe(propsReady, value => {\n    value && getValue(log)(\"props updated\", {}, LogLevel.DEBUG);\n  });\n  return {\n    propsReady,\n    didMount\n  };\n}, tup(loggerSystem), {\n  singleton: true\n});\nfunction getInitialTopMostItemIndexNumber(location, totalCount) {\n  const lastIndex = totalCount - 1;\n  const index = typeof location === \"number\" ? location : location.index === \"LAST\" ? lastIndex : location.index;\n  return index;\n}\nfunction skipFrames(frameCount, callback) {\n  if (frameCount == 0) {\n    callback();\n  } else {\n    requestAnimationFrame(() => skipFrames(frameCount - 1, callback));\n  }\n}\nconst initialTopMostItemIndexSystem = system(_ref36 => {\n  let [{\n    sizes,\n    listRefresh,\n    defaultItemSize\n  }, {\n    scrollTop\n  }, {\n    scrollToIndex\n  }, {\n    didMount\n  }] = _ref36;\n  const scrolledToInitialItem = statefulStream(true);\n  const initialTopMostItemIndex = statefulStream(0);\n  const scrollScheduled = statefulStream(false);\n  connect(pipe(didMount, withLatestFrom(initialTopMostItemIndex), filter(_ref37 => {\n    let [_, location] = _ref37;\n    return !!location;\n  }),\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n  mapTo(false)), scrolledToInitialItem);\n  subscribe(pipe(combineLatest(listRefresh, didMount), withLatestFrom(scrolledToInitialItem, sizes, defaultItemSize, scrollScheduled), filter(_ref38 => {\n    let [[, didMount2], scrolledToInitialItem2, {\n      sizeTree\n    }, defaultItemSize2, scrollScheduled2] = _ref38;\n    return didMount2 && (!empty(sizeTree) || isDefined(defaultItemSize2)) && !scrolledToInitialItem2 && !scrollScheduled2;\n  }), withLatestFrom(initialTopMostItemIndex)), _ref39 => {\n    let [, initialTopMostItemIndex2] = _ref39;\n    publish(scrollScheduled, true);\n    skipFrames(2, () => {\n      handleNext(scrollTop, () => publish(scrolledToInitialItem, true));\n      publish(scrollToIndex, initialTopMostItemIndex2);\n    });\n  });\n  return {\n    scrolledToInitialItem,\n    initialTopMostItemIndex\n  };\n}, tup(sizeSystem, domIOSystem, scrollToIndexSystem, propsReadySystem), {\n  singleton: true\n});\nfunction normalizeFollowOutput(follow) {\n  if (!follow) {\n    return false;\n  }\n  return follow === \"smooth\" ? \"smooth\" : \"auto\";\n}\nconst behaviorFromFollowOutput = (follow, isAtBottom) => {\n  if (typeof follow === \"function\") {\n    return normalizeFollowOutput(follow(isAtBottom));\n  }\n  return isAtBottom && normalizeFollowOutput(follow);\n};\nconst followOutputSystem = system(_ref40 => {\n  let [{\n    totalCount,\n    listRefresh\n  }, {\n    isAtBottom,\n    atBottomState\n  }, {\n    scrollToIndex\n  }, {\n    scrolledToInitialItem\n  }, {\n    propsReady,\n    didMount\n  }, {\n    log\n  }, {\n    scrollingInProgress\n  }] = _ref40;\n  const followOutput = statefulStream(false);\n  const autoscrollToBottom = stream();\n  let pendingScrollHandle = null;\n  function scrollToBottom(followOutputBehavior) {\n    publish(scrollToIndex, {\n      index: \"LAST\",\n      align: \"end\",\n      behavior: followOutputBehavior\n    });\n  }\n  subscribe(pipe(combineLatest(pipe(duc(totalCount), skip(1)), didMount), withLatestFrom(duc(followOutput), isAtBottom, scrolledToInitialItem, scrollingInProgress), map(_ref41 => {\n    let [[totalCount2, didMount2], followOutput2, isAtBottom2, scrolledToInitialItem2, scrollingInProgress2] = _ref41;\n    let shouldFollow = didMount2 && scrolledToInitialItem2;\n    let followOutputBehavior = \"auto\";\n    if (shouldFollow) {\n      followOutputBehavior = behaviorFromFollowOutput(followOutput2, isAtBottom2 || scrollingInProgress2);\n      shouldFollow = shouldFollow && !!followOutputBehavior;\n    }\n    return {\n      totalCount: totalCount2,\n      shouldFollow,\n      followOutputBehavior\n    };\n  }), filter(_ref42 => {\n    let {\n      shouldFollow\n    } = _ref42;\n    return shouldFollow;\n  })), _ref43 => {\n    let {\n      totalCount: totalCount2,\n      followOutputBehavior\n    } = _ref43;\n    if (pendingScrollHandle) {\n      pendingScrollHandle();\n      pendingScrollHandle = null;\n    }\n    pendingScrollHandle = handleNext(listRefresh, () => {\n      getValue(log)(\"following output to \", {\n        totalCount: totalCount2\n      }, LogLevel.DEBUG);\n      scrollToBottom(followOutputBehavior);\n      pendingScrollHandle = null;\n    });\n  });\n  function trapNextSizeIncrease(followOutput2) {\n    const cancel = handleNext(atBottomState, state => {\n      if (followOutput2 && !state.atBottom && state.notAtBottomBecause === \"SIZE_INCREASED\" && !pendingScrollHandle) {\n        getValue(log)(\"scrolling to bottom due to increased size\", {}, LogLevel.DEBUG);\n        scrollToBottom(\"auto\");\n      }\n    });\n    setTimeout(cancel, 100);\n  }\n  subscribe(pipe(combineLatest(duc(followOutput), totalCount, propsReady), filter(_ref44 => {\n    let [follow,, ready] = _ref44;\n    return follow && ready;\n  }), scan((_ref45, _ref46) => {\n    let {\n      value\n    } = _ref45;\n    let [, next] = _ref46;\n    return {\n      refreshed: value === next,\n      value: next\n    };\n  }, {\n    refreshed: false,\n    value: 0\n  }), filter(_ref47 => {\n    let {\n      refreshed\n    } = _ref47;\n    return refreshed;\n  }), withLatestFrom(followOutput, totalCount)), _ref48 => {\n    let [, followOutput2] = _ref48;\n    trapNextSizeIncrease(followOutput2 !== false);\n  });\n  subscribe(autoscrollToBottom, () => {\n    trapNextSizeIncrease(getValue(followOutput) !== false);\n  });\n  subscribe(combineLatest(duc(followOutput), atBottomState), _ref49 => {\n    let [followOutput2, state] = _ref49;\n    if (followOutput2 && !state.atBottom && state.notAtBottomBecause === \"VIEWPORT_HEIGHT_DECREASING\") {\n      scrollToBottom(\"auto\");\n    }\n  });\n  return {\n    followOutput,\n    autoscrollToBottom\n  };\n}, tup(sizeSystem, stateFlagsSystem, scrollToIndexSystem, initialTopMostItemIndexSystem, propsReadySystem, loggerSystem, domIOSystem));\nfunction groupCountsToIndicesAndCount(counts) {\n  return counts.reduce((acc, groupCount) => {\n    acc.groupIndices.push(acc.totalCount);\n    acc.totalCount += groupCount + 1;\n    return acc;\n  }, {\n    totalCount: 0,\n    groupIndices: []\n  });\n}\nconst groupedListSystem = system(_ref50 => {\n  let [{\n    totalCount,\n    groupIndices,\n    sizes\n  }, {\n    scrollTop,\n    headerHeight\n  }] = _ref50;\n  const groupCounts = stream();\n  const topItemsIndexes = stream();\n  const groupIndicesAndCount = streamFromEmitter(pipe(groupCounts, map(groupCountsToIndicesAndCount)));\n  connect(pipe(groupIndicesAndCount, map(value => value.totalCount)), totalCount);\n  connect(pipe(groupIndicesAndCount, map(value => value.groupIndices)), groupIndices);\n  connect(pipe(combineLatest(scrollTop, sizes, headerHeight), filter(_ref51 => {\n    let [_, sizes2] = _ref51;\n    return hasGroups(sizes2);\n  }), map(_ref52 => {\n    let [scrollTop2, state, headerHeight2] = _ref52;\n    return findMaxKeyValue(state.groupOffsetTree, Math.max(scrollTop2 - headerHeight2, 0), \"v\")[0];\n  }), distinctUntilChanged(), map(index => [index])), topItemsIndexes);\n  return {\n    groupCounts,\n    topItemsIndexes\n  };\n}, tup(sizeSystem, domIOSystem));\nfunction tupleComparator(prev, current) {\n  return !!(prev && prev[0] === current[0] && prev[1] === current[1]);\n}\nfunction rangeComparator(prev, next) {\n  return !!(prev && prev.startIndex === next.startIndex && prev.endIndex === next.endIndex);\n}\nconst TOP = \"top\";\nconst BOTTOM = \"bottom\";\nconst NONE = \"none\";\nfunction getOverscan(overscan, end, direction) {\n  if (typeof overscan === \"number\") {\n    return direction === UP && end === TOP || direction === DOWN && end === BOTTOM ? overscan : 0;\n  } else {\n    if (direction === UP) {\n      return end === TOP ? overscan.main : overscan.reverse;\n    } else {\n      return end === BOTTOM ? overscan.main : overscan.reverse;\n    }\n  }\n}\nfunction getViewportIncrease(value, end) {\n  return typeof value === \"number\" ? value : value[end] || 0;\n}\nconst sizeRangeSystem = system(_ref53 => {\n  let [{\n    scrollTop,\n    viewportHeight,\n    deviation,\n    headerHeight,\n    fixedHeaderHeight\n  }] = _ref53;\n  const listBoundary = stream();\n  const topListHeight = statefulStream(0);\n  const increaseViewportBy = statefulStream(0);\n  const overscan = statefulStream(0);\n  const visibleRange = statefulStreamFromEmitter(pipe(combineLatest(duc(scrollTop), duc(viewportHeight), duc(headerHeight), duc(listBoundary, tupleComparator), duc(overscan), duc(topListHeight), duc(fixedHeaderHeight), duc(deviation), duc(increaseViewportBy)), map(_ref54 => {\n    let [scrollTop2, viewportHeight2, headerHeight2, [listTop, listBottom], overscan2, topListHeight2, fixedHeaderHeight2, deviation2, increaseViewportBy2] = _ref54;\n    const top = scrollTop2 - deviation2;\n    const stickyHeaderHeight = topListHeight2 + fixedHeaderHeight2;\n    const headerVisible = Math.max(headerHeight2 - top, 0);\n    let direction = NONE;\n    const topViewportAddition = getViewportIncrease(increaseViewportBy2, TOP);\n    const bottomViewportAddition = getViewportIncrease(increaseViewportBy2, BOTTOM);\n    listTop -= deviation2;\n    listTop += headerHeight2 + fixedHeaderHeight2;\n    listBottom += headerHeight2 + fixedHeaderHeight2;\n    listBottom -= deviation2;\n    if (listTop > scrollTop2 + stickyHeaderHeight - topViewportAddition) {\n      direction = UP;\n    }\n    if (listBottom < scrollTop2 - headerVisible + viewportHeight2 + bottomViewportAddition) {\n      direction = DOWN;\n    }\n    if (direction !== NONE) {\n      return [Math.max(top - headerHeight2 - getOverscan(overscan2, TOP, direction) - topViewportAddition, 0), top - headerVisible - fixedHeaderHeight2 + viewportHeight2 + getOverscan(overscan2, BOTTOM, direction) + bottomViewportAddition];\n    }\n    return null;\n  }), filter(value => value != null), distinctUntilChanged(tupleComparator)), [0, 0]);\n  return {\n    // input\n    listBoundary,\n    overscan,\n    topListHeight,\n    increaseViewportBy,\n    // output\n    visibleRange\n  };\n}, tup(domIOSystem), {\n  singleton: true\n});\nfunction probeItemSet(index, sizes, data) {\n  if (hasGroups(sizes)) {\n    const itemIndex = originalIndexFromItemIndex(index, sizes);\n    const groupIndex = findMaxKeyValue(sizes.groupOffsetTree, itemIndex)[0];\n    return [{\n      index: groupIndex,\n      size: 0,\n      offset: 0\n    }, {\n      index: itemIndex,\n      size: 0,\n      offset: 0,\n      data: data && data[0]\n    }];\n  }\n  return [{\n    index,\n    size: 0,\n    offset: 0,\n    data: data && data[0]\n  }];\n}\nconst EMPTY_LIST_STATE = {\n  items: [],\n  topItems: [],\n  offsetTop: 0,\n  offsetBottom: 0,\n  top: 0,\n  bottom: 0,\n  topListHeight: 0,\n  totalCount: 0,\n  firstItemIndex: 0\n};\nfunction transposeItems(items, sizes, firstItemIndex) {\n  if (items.length === 0) {\n    return [];\n  }\n  if (!hasGroups(sizes)) {\n    return items.map(item => ({\n      ...item,\n      index: item.index + firstItemIndex,\n      originalIndex: item.index\n    }));\n  }\n  const startIndex = items[0].index;\n  const endIndex = items[items.length - 1].index;\n  const transposedItems = [];\n  const groupRanges = rangesWithin(sizes.groupOffsetTree, startIndex, endIndex);\n  let currentRange = void 0;\n  let currentGroupIndex = 0;\n  for (const item of items) {\n    if (!currentRange || currentRange.end < item.index) {\n      currentRange = groupRanges.shift();\n      currentGroupIndex = sizes.groupIndices.indexOf(currentRange.start);\n    }\n    let transposedItem;\n    if (item.index === currentRange.start) {\n      transposedItem = {\n        type: \"group\",\n        index: currentGroupIndex\n      };\n    } else {\n      transposedItem = {\n        index: item.index - (currentGroupIndex + 1) + firstItemIndex,\n        groupIndex: currentGroupIndex\n      };\n    }\n    transposedItems.push({\n      ...transposedItem,\n      size: item.size,\n      offset: item.offset,\n      originalIndex: item.index,\n      data: item.data\n    });\n  }\n  return transposedItems;\n}\nfunction buildListState(items, topItems, totalCount, gap, sizes, firstItemIndex) {\n  const {\n    lastSize,\n    lastOffset,\n    lastIndex\n  } = sizes;\n  let offsetTop = 0;\n  let bottom = 0;\n  if (items.length > 0) {\n    offsetTop = items[0].offset;\n    const lastItem = items[items.length - 1];\n    bottom = lastItem.offset + lastItem.size;\n  }\n  const itemCount = totalCount - lastIndex;\n  const total = lastOffset + itemCount * lastSize + (itemCount - 1) * gap;\n  const top = offsetTop;\n  const offsetBottom = total - bottom;\n  return {\n    items: transposeItems(items, sizes, firstItemIndex),\n    topItems: transposeItems(topItems, sizes, firstItemIndex),\n    topListHeight: topItems.reduce((height, item) => item.size + height, 0),\n    offsetTop,\n    offsetBottom,\n    top,\n    bottom,\n    totalCount,\n    firstItemIndex\n  };\n}\nconst listStateSystem = system(_ref55 => {\n  let [{\n    sizes,\n    totalCount,\n    data,\n    firstItemIndex,\n    gap\n  }, groupedListSystem2, {\n    visibleRange,\n    listBoundary,\n    topListHeight: rangeTopListHeight\n  }, {\n    scrolledToInitialItem,\n    initialTopMostItemIndex\n  }, {\n    topListHeight\n  }, stateFlags, {\n    didMount\n  }, {\n    recalcInProgress\n  }] = _ref55;\n  const topItemsIndexes = statefulStream([]);\n  const itemsRendered = stream();\n  connect(groupedListSystem2.topItemsIndexes, topItemsIndexes);\n  const listState = statefulStreamFromEmitter(pipe(combineLatest(didMount, recalcInProgress, duc(visibleRange, tupleComparator), duc(totalCount), duc(sizes), duc(initialTopMostItemIndex), scrolledToInitialItem, duc(topItemsIndexes), duc(firstItemIndex), duc(gap), data), filter(_ref56 => {\n    let [mount, recalcInProgress2,, totalCount2,,,,,,, data2] = _ref56;\n    const dataChangeInProgress = data2 && data2.length !== totalCount2;\n    return mount && !recalcInProgress2 && !dataChangeInProgress;\n  }), map(_ref57 => {\n    let [,, [startOffset, endOffset], totalCount2, sizes2, initialTopMostItemIndex2, scrolledToInitialItem2, topItemsIndexes2, firstItemIndex2, gap2, data2] = _ref57;\n    const sizesValue = sizes2;\n    const {\n      sizeTree,\n      offsetTree\n    } = sizesValue;\n    if (totalCount2 === 0 || startOffset === 0 && endOffset === 0) {\n      return {\n        ...EMPTY_LIST_STATE,\n        totalCount: totalCount2\n      };\n    }\n    if (empty(sizeTree)) {\n      return buildListState(probeItemSet(getInitialTopMostItemIndexNumber(initialTopMostItemIndex2, totalCount2), sizesValue, data2), [], totalCount2, gap2, sizesValue, firstItemIndex2);\n    }\n    const topItems = [];\n    if (topItemsIndexes2.length > 0) {\n      const startIndex = topItemsIndexes2[0];\n      const endIndex = topItemsIndexes2[topItemsIndexes2.length - 1];\n      let offset = 0;\n      for (const range of rangesWithin(sizeTree, startIndex, endIndex)) {\n        const size = range.value;\n        const rangeStartIndex = Math.max(range.start, startIndex);\n        const rangeEndIndex = Math.min(range.end, endIndex);\n        for (let i = rangeStartIndex; i <= rangeEndIndex; i++) {\n          topItems.push({\n            index: i,\n            size,\n            offset,\n            data: data2 && data2[i]\n          });\n          offset += size;\n        }\n      }\n    }\n    if (!scrolledToInitialItem2) {\n      return buildListState([], topItems, totalCount2, gap2, sizesValue, firstItemIndex2);\n    }\n    const minStartIndex = topItemsIndexes2.length > 0 ? topItemsIndexes2[topItemsIndexes2.length - 1] + 1 : 0;\n    const offsetPointRanges = rangesWithinOffsets(offsetTree, startOffset, endOffset, minStartIndex);\n    if (offsetPointRanges.length === 0) {\n      return null;\n    }\n    const maxIndex = totalCount2 - 1;\n    const items = tap([], result => {\n      for (const range of offsetPointRanges) {\n        const point = range.value;\n        let offset = point.offset;\n        let rangeStartIndex = range.start;\n        const size = point.size;\n        if (point.offset < startOffset) {\n          rangeStartIndex += Math.floor((startOffset - point.offset + gap2) / (size + gap2));\n          const itemCount = rangeStartIndex - range.start;\n          offset += itemCount * size + itemCount * gap2;\n        }\n        if (rangeStartIndex < minStartIndex) {\n          offset += (minStartIndex - rangeStartIndex) * size;\n          rangeStartIndex = minStartIndex;\n        }\n        const endIndex = Math.min(range.end, maxIndex);\n        for (let i = rangeStartIndex; i <= endIndex; i++) {\n          if (offset >= endOffset) {\n            break;\n          }\n          result.push({\n            index: i,\n            size,\n            offset,\n            data: data2 && data2[i]\n          });\n          offset += size + gap2;\n        }\n      }\n    });\n    return buildListState(items, topItems, totalCount2, gap2, sizesValue, firstItemIndex2);\n  }),\n  //@ts-expect-error filter needs to be fixed\n  filter(value => value !== null), distinctUntilChanged()), EMPTY_LIST_STATE);\n  connect(pipe(data, filter(isDefined), map(data2 => data2 == null ? void 0 : data2.length)), totalCount);\n  connect(pipe(listState, map(value => value.topListHeight)), topListHeight);\n  connect(topListHeight, rangeTopListHeight);\n  connect(pipe(listState, map(state => [state.top, state.bottom])), listBoundary);\n  connect(pipe(listState, map(state => state.items)), itemsRendered);\n  const endReached = streamFromEmitter(pipe(listState, filter(_ref58 => {\n    let {\n      items\n    } = _ref58;\n    return items.length > 0;\n  }), withLatestFrom(totalCount, data), filter(_ref59 => {\n    let [{\n      items\n    }, totalCount2] = _ref59;\n    return items[items.length - 1].originalIndex === totalCount2 - 1;\n  }), map(_ref60 => {\n    let [, totalCount2, data2] = _ref60;\n    return [totalCount2 - 1, data2];\n  }), distinctUntilChanged(tupleComparator), map(_ref61 => {\n    let [count] = _ref61;\n    return count;\n  })));\n  const startReached = streamFromEmitter(pipe(listState, throttleTime(200), filter(_ref62 => {\n    let {\n      items,\n      topItems\n    } = _ref62;\n    return items.length > 0 && items[0].originalIndex === topItems.length;\n  }), map(_ref63 => {\n    let {\n      items\n    } = _ref63;\n    return items[0].index;\n  }), distinctUntilChanged()));\n  const rangeChanged = streamFromEmitter(pipe(listState, filter(_ref64 => {\n    let {\n      items\n    } = _ref64;\n    return items.length > 0;\n  }), map(_ref65 => {\n    let {\n      items\n    } = _ref65;\n    let startIndex = 0;\n    let endIndex = items.length - 1;\n    while (items[startIndex].type === \"group\" && startIndex < endIndex) {\n      startIndex++;\n    }\n    while (items[endIndex].type === \"group\" && endIndex > startIndex) {\n      endIndex--;\n    }\n    return {\n      startIndex: items[startIndex].index,\n      endIndex: items[endIndex].index\n    };\n  }), distinctUntilChanged(rangeComparator)));\n  return {\n    listState,\n    topItemsIndexes,\n    endReached,\n    startReached,\n    rangeChanged,\n    itemsRendered,\n    ...stateFlags\n  };\n}, tup(sizeSystem, groupedListSystem, sizeRangeSystem, initialTopMostItemIndexSystem, scrollToIndexSystem, stateFlagsSystem, propsReadySystem, recalcSystem), {\n  singleton: true\n});\nconst initialItemCountSystem = system(_ref66 => {\n  let [{\n    sizes,\n    firstItemIndex,\n    data,\n    gap\n  }, {\n    listState\n  }, {\n    didMount\n  }] = _ref66;\n  const initialItemCount = statefulStream(0);\n  connect(pipe(didMount, withLatestFrom(initialItemCount), filter(_ref67 => {\n    let [, count] = _ref67;\n    return count !== 0;\n  }), withLatestFrom(sizes, firstItemIndex, gap, data), map(_ref68 => {\n    let [[, count], sizes2, firstItemIndex2, gap2, data2 = []] = _ref68;\n    let includedGroupsCount = 0;\n    if (sizes2.groupIndices.length > 0) {\n      for (const index of sizes2.groupIndices) {\n        if (index - includedGroupsCount >= count) {\n          break;\n        }\n        includedGroupsCount++;\n      }\n    }\n    const adjustedCount = count + includedGroupsCount;\n    const items = Array.from({\n      length: adjustedCount\n    }).map((_, index) => ({\n      index,\n      size: 0,\n      offset: 0,\n      data: data2[index]\n    }));\n    return buildListState(items, [], adjustedCount, gap2, sizes2, firstItemIndex2);\n  })), listState);\n  return {\n    initialItemCount\n  };\n}, tup(sizeSystem, listStateSystem, propsReadySystem), {\n  singleton: true\n});\nconst scrollSeekSystem = system(_ref69 => {\n  let [{\n    scrollVelocity\n  }] = _ref69;\n  const isSeeking = statefulStream(false);\n  const rangeChanged = stream();\n  const scrollSeekConfiguration = statefulStream(false);\n  connect(pipe(scrollVelocity, withLatestFrom(scrollSeekConfiguration, isSeeking, rangeChanged), filter(_ref70 => {\n    let [_, config] = _ref70;\n    return !!config;\n  }), map(_ref71 => {\n    let [speed, config, isSeeking2, range] = _ref71;\n    const {\n      exit,\n      enter\n    } = config;\n    if (isSeeking2) {\n      if (exit(speed, range)) {\n        return false;\n      }\n    } else {\n      if (enter(speed, range)) {\n        return true;\n      }\n    }\n    return isSeeking2;\n  }), distinctUntilChanged()), isSeeking);\n  subscribe(pipe(combineLatest(isSeeking, scrollVelocity, rangeChanged), withLatestFrom(scrollSeekConfiguration)), _ref72 => {\n    let [[isSeeking2, velocity, range], config] = _ref72;\n    return isSeeking2 && config && config.change && config.change(velocity, range);\n  });\n  return {\n    isSeeking,\n    scrollSeekConfiguration,\n    scrollVelocity,\n    scrollSeekRangeChanged: rangeChanged\n  };\n}, tup(stateFlagsSystem), {\n  singleton: true\n});\nconst topItemCountSystem = system(_ref73 => {\n  let [{\n    topItemsIndexes\n  }] = _ref73;\n  const topItemCount = statefulStream(0);\n  connect(pipe(topItemCount, filter(length => length > 0), map(length => Array.from({\n    length\n  }).map((_, index) => index))), topItemsIndexes);\n  return {\n    topItemCount\n  };\n}, tup(listStateSystem));\nconst totalListHeightSystem = system(_ref74 => {\n  let [{\n    footerHeight,\n    headerHeight,\n    fixedHeaderHeight,\n    fixedFooterHeight\n  }, {\n    listState\n  }] = _ref74;\n  const totalListHeightChanged = stream();\n  const totalListHeight = statefulStreamFromEmitter(pipe(combineLatest(footerHeight, fixedFooterHeight, headerHeight, fixedHeaderHeight, listState), map(_ref75 => {\n    let [footerHeight2, fixedFooterHeight2, headerHeight2, fixedHeaderHeight2, listState2] = _ref75;\n    return footerHeight2 + fixedFooterHeight2 + headerHeight2 + fixedHeaderHeight2 + listState2.offsetBottom + listState2.bottom;\n  })), 0);\n  connect(duc(totalListHeight), totalListHeightChanged);\n  return {\n    totalListHeight,\n    totalListHeightChanged\n  };\n}, tup(domIOSystem, listStateSystem), {\n  singleton: true\n});\nfunction simpleMemoize(func) {\n  let called = false;\n  let result;\n  return () => {\n    if (!called) {\n      called = true;\n      result = func();\n    }\n    return result;\n  };\n}\nconst isMobileSafari = simpleMemoize(() => {\n  return /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent);\n});\nconst upwardScrollFixSystem = system(_ref76 => {\n  let [{\n    scrollBy,\n    scrollTop,\n    deviation,\n    scrollingInProgress\n  }, {\n    isScrolling,\n    isAtBottom,\n    scrollDirection,\n    lastJumpDueToItemResize\n  }, {\n    listState\n  }, {\n    beforeUnshiftWith,\n    shiftWithOffset,\n    sizes,\n    gap\n  }, {\n    log\n  }, {\n    recalcInProgress\n  }] = _ref76;\n  const deviationOffset = streamFromEmitter(pipe(listState, withLatestFrom(lastJumpDueToItemResize), scan((_ref77, _ref78) => {\n    let [, prevItems, prevTotalCount, prevTotalHeight] = _ref77;\n    let [{\n      items,\n      totalCount,\n      bottom,\n      offsetBottom\n    }, lastJumpDueToItemResize2] = _ref78;\n    const totalHeight = bottom + offsetBottom;\n    let newDev = 0;\n    if (prevTotalCount === totalCount) {\n      if (prevItems.length > 0 && items.length > 0) {\n        const atStart = items[0].originalIndex === 0 && prevItems[0].originalIndex === 0;\n        if (!atStart) {\n          newDev = totalHeight - prevTotalHeight;\n          if (newDev !== 0) {\n            newDev += lastJumpDueToItemResize2;\n          }\n        }\n      }\n    }\n    return [newDev, items, totalCount, totalHeight];\n  }, [0, [], 0, 0]), filter(_ref79 => {\n    let [amount] = _ref79;\n    return amount !== 0;\n  }), withLatestFrom(scrollTop, scrollDirection, scrollingInProgress, isAtBottom, log, recalcInProgress), filter(_ref80 => {\n    let [, scrollTop2, scrollDirection2, scrollingInProgress2,,, recalcInProgress2] = _ref80;\n    return !recalcInProgress2 && !scrollingInProgress2 && scrollTop2 !== 0 && scrollDirection2 === UP;\n  }), map(_ref81 => {\n    let [[amount],,,,, log2] = _ref81;\n    log2(\"Upward scrolling compensation\", {\n      amount\n    }, LogLevel.DEBUG);\n    return amount;\n  })));\n  function scrollByWith(offset) {\n    if (offset > 0) {\n      publish(scrollBy, {\n        top: -offset,\n        behavior: \"auto\"\n      });\n      publish(deviation, 0);\n    } else {\n      publish(deviation, 0);\n      publish(scrollBy, {\n        top: -offset,\n        behavior: \"auto\"\n      });\n    }\n  }\n  subscribe(pipe(deviationOffset, withLatestFrom(deviation, isScrolling)), _ref82 => {\n    let [offset, deviationAmount, isScrolling2] = _ref82;\n    if (isScrolling2 && isMobileSafari()) {\n      publish(deviation, deviationAmount - offset);\n    } else {\n      scrollByWith(-offset);\n    }\n  });\n  subscribe(pipe(combineLatest(statefulStreamFromEmitter(isScrolling, false), deviation, recalcInProgress), filter(_ref83 => {\n    let [is, deviation2, recalc] = _ref83;\n    return !is && !recalc && deviation2 !== 0;\n  }), map(_ref84 => {\n    let [_, deviation2] = _ref84;\n    return deviation2;\n  }), throttleTime(1)), scrollByWith);\n  connect(pipe(shiftWithOffset, map(offset => {\n    return {\n      top: -offset\n    };\n  })), scrollBy);\n  subscribe(pipe(beforeUnshiftWith, withLatestFrom(sizes, gap), map(_ref85 => {\n    let [offset, {\n      lastSize: defaultItemSize,\n      groupIndices,\n      sizeTree\n    }, gap2] = _ref85;\n    function getItemOffset(itemCount) {\n      return itemCount * (defaultItemSize + gap2);\n    }\n    if (groupIndices.length === 0) {\n      return getItemOffset(offset);\n    } else {\n      let amount = 0;\n      const defaultGroupSize = find(sizeTree, 0);\n      let recognizedOffsetItems = 0;\n      let groupIndex = 0;\n      while (recognizedOffsetItems < offset) {\n        recognizedOffsetItems++;\n        amount += defaultGroupSize;\n        let groupItemCount = groupIndices.length === groupIndex + 1 ? Infinity : groupIndices[groupIndex + 1] - groupIndices[groupIndex] - 1;\n        if (recognizedOffsetItems + groupItemCount > offset) {\n          amount -= defaultGroupSize;\n          groupItemCount = offset - recognizedOffsetItems + 1;\n        }\n        recognizedOffsetItems += groupItemCount;\n        amount += getItemOffset(groupItemCount);\n        groupIndex++;\n      }\n      return amount;\n    }\n  })), offset => {\n    publish(deviation, offset);\n    requestAnimationFrame(() => {\n      publish(scrollBy, {\n        top: offset\n      });\n      requestAnimationFrame(() => {\n        publish(deviation, 0);\n        publish(recalcInProgress, false);\n      });\n    });\n  });\n  return {\n    deviation\n  };\n}, tup(domIOSystem, stateFlagsSystem, listStateSystem, sizeSystem, loggerSystem, recalcSystem));\nconst initialScrollTopSystem = system(_ref86 => {\n  let [{\n    didMount\n  }, {\n    scrollTo\n  }, {\n    listState\n  }] = _ref86;\n  const initialScrollTop = statefulStream(0);\n  subscribe(pipe(didMount, withLatestFrom(initialScrollTop), filter(_ref87 => {\n    let [, offset] = _ref87;\n    return offset !== 0;\n  }), map(_ref88 => {\n    let [, offset] = _ref88;\n    return {\n      top: offset\n    };\n  })), location => {\n    handleNext(pipe(listState, skip(1), filter(state => state.items.length > 1)), () => {\n      requestAnimationFrame(() => {\n        publish(scrollTo, location);\n      });\n    });\n  });\n  return {\n    initialScrollTop\n  };\n}, tup(propsReadySystem, domIOSystem, listStateSystem), {\n  singleton: true\n});\nconst alignToBottomSystem = system(_ref89 => {\n  let [{\n    viewportHeight\n  }, {\n    totalListHeight\n  }] = _ref89;\n  const alignToBottom = statefulStream(false);\n  const paddingTopAddition = statefulStreamFromEmitter(pipe(combineLatest(alignToBottom, viewportHeight, totalListHeight), filter(_ref90 => {\n    let [enabled] = _ref90;\n    return enabled;\n  }), map(_ref91 => {\n    let [, viewportHeight2, totalListHeight2] = _ref91;\n    return Math.max(0, viewportHeight2 - totalListHeight2);\n  }), throttleTime(0), distinctUntilChanged()), 0);\n  return {\n    alignToBottom,\n    paddingTopAddition\n  };\n}, tup(domIOSystem, totalListHeightSystem), {\n  singleton: true\n});\nconst windowScrollerSystem = system(_ref92 => {\n  let [{\n    scrollTo,\n    scrollContainerState\n  }] = _ref92;\n  const windowScrollContainerState = stream();\n  const windowViewportRect = stream();\n  const windowScrollTo = stream();\n  const useWindowScroll = statefulStream(false);\n  const customScrollParent = statefulStream(void 0);\n  connect(pipe(combineLatest(windowScrollContainerState, windowViewportRect), map(_ref93 => {\n    let [{\n      viewportHeight,\n      scrollTop: windowScrollTop,\n      scrollHeight\n    }, {\n      offsetTop\n    }] = _ref93;\n    return {\n      scrollTop: Math.max(0, windowScrollTop - offsetTop),\n      scrollHeight,\n      viewportHeight\n    };\n  })), scrollContainerState);\n  connect(pipe(scrollTo, withLatestFrom(windowViewportRect), map(_ref94 => {\n    let [scrollTo2, {\n      offsetTop\n    }] = _ref94;\n    return {\n      ...scrollTo2,\n      top: scrollTo2.top + offsetTop\n    };\n  })), windowScrollTo);\n  return {\n    // config\n    useWindowScroll,\n    customScrollParent,\n    // input\n    windowScrollContainerState,\n    windowViewportRect,\n    // signals\n    windowScrollTo\n  };\n}, tup(domIOSystem));\nconst defaultCalculateViewLocation = _ref95 => {\n  let {\n    itemTop: itemTop2,\n    itemBottom,\n    viewportTop,\n    viewportBottom,\n    locationParams: {\n      behavior,\n      align,\n      ...rest\n    }\n  } = _ref95;\n  if (itemTop2 < viewportTop) {\n    return {\n      ...rest,\n      behavior,\n      align: align != null ? align : \"start\"\n    };\n  }\n  if (itemBottom > viewportBottom) {\n    return {\n      ...rest,\n      behavior,\n      align: align != null ? align : \"end\"\n    };\n  }\n  return null;\n};\nconst scrollIntoViewSystem = system(_ref96 => {\n  let [{\n    sizes,\n    totalCount,\n    gap\n  }, {\n    scrollTop,\n    viewportHeight,\n    headerHeight,\n    fixedHeaderHeight,\n    fixedFooterHeight,\n    scrollingInProgress\n  }, {\n    scrollToIndex\n  }] = _ref96;\n  const scrollIntoView = stream();\n  connect(pipe(scrollIntoView, withLatestFrom(sizes, viewportHeight, totalCount, headerHeight, fixedHeaderHeight, fixedFooterHeight, scrollTop), withLatestFrom(gap), map(_ref97 => {\n    let [[viewLocation, sizes2, viewportHeight2, totalCount2, headerHeight2, fixedHeaderHeight2, fixedFooterHeight2, scrollTop2], gap2] = _ref97;\n    const {\n      done,\n      behavior,\n      align,\n      calculateViewLocation = defaultCalculateViewLocation,\n      ...rest\n    } = viewLocation;\n    const actualIndex = originalIndexFromLocation(viewLocation, sizes2, totalCount2 - 1);\n    const itemTop2 = offsetOf(actualIndex, sizes2.offsetTree, gap2) + headerHeight2 + fixedHeaderHeight2;\n    const itemBottom = itemTop2 + findMaxKeyValue(sizes2.sizeTree, actualIndex)[1];\n    const viewportTop = scrollTop2 + fixedHeaderHeight2;\n    const viewportBottom = scrollTop2 + viewportHeight2 - fixedFooterHeight2;\n    const location = calculateViewLocation({\n      itemTop: itemTop2,\n      itemBottom,\n      viewportTop,\n      viewportBottom,\n      locationParams: {\n        behavior,\n        align,\n        ...rest\n      }\n    });\n    if (location) {\n      done && handleNext(pipe(scrollingInProgress, filter(value => value === false),\n      // skips the initial publish of false, and the cleanup call.\n      // but if scrollingInProgress is true, we skip the initial publish.\n      skip(getValue(scrollingInProgress) ? 1 : 2)), done);\n    } else {\n      done && done();\n    }\n    return location;\n  }), filter(value => value !== null)), scrollToIndex);\n  return {\n    scrollIntoView\n  };\n}, tup(sizeSystem, domIOSystem, scrollToIndexSystem, listStateSystem, loggerSystem), {\n  singleton: true\n});\nconst stateLoadSystem = system(_ref98 => {\n  let [{\n    sizes,\n    sizeRanges\n  }, {\n    scrollTop\n  }, {\n    initialTopMostItemIndex\n  }, {\n    didMount\n  }] = _ref98;\n  const getState = stream();\n  const restoreStateFrom = statefulStream(void 0);\n  subscribe(pipe(getState, withLatestFrom(sizes, scrollTop)), _ref99 => {\n    let [callback, sizes2, scrollTop2] = _ref99;\n    const ranges = sizeTreeToRanges(sizes2.sizeTree);\n    callback({\n      ranges,\n      scrollTop: scrollTop2\n    });\n  });\n  connect(pipe(restoreStateFrom, filter(isDefined), map(locationFromSnapshot)), initialTopMostItemIndex);\n  connect(pipe(didMount, withLatestFrom(restoreStateFrom), filter(_ref100 => {\n    let [, state] = _ref100;\n    return state !== void 0;\n  }), distinctUntilChanged(), map(_ref101 => {\n    let [, snapshot] = _ref101;\n    return snapshot.ranges;\n  })), sizeRanges);\n  return {\n    getState,\n    restoreStateFrom\n  };\n}, tup(sizeSystem, domIOSystem, initialTopMostItemIndexSystem, propsReadySystem));\nfunction locationFromSnapshot(snapshot) {\n  return {\n    offset: snapshot.scrollTop,\n    index: 0,\n    align: \"start\"\n  };\n}\nconst featureGroup1System = system(_ref102 => {\n  let [sizeRange, initialItemCount, propsReady, scrollSeek, totalListHeight, initialScrollTopSystem2, alignToBottom, windowScroller, scrollIntoView, logger] = _ref102;\n  return {\n    ...sizeRange,\n    ...initialItemCount,\n    ...propsReady,\n    ...scrollSeek,\n    ...totalListHeight,\n    ...initialScrollTopSystem2,\n    ...alignToBottom,\n    ...windowScroller,\n    ...scrollIntoView,\n    ...logger\n  };\n}, tup(sizeRangeSystem, initialItemCountSystem, propsReadySystem, scrollSeekSystem, totalListHeightSystem, initialScrollTopSystem, alignToBottomSystem, windowScrollerSystem, scrollIntoViewSystem, loggerSystem));\nconst listSystem = system(_ref103 => {\n  let [{\n    totalCount,\n    sizeRanges,\n    fixedItemSize,\n    defaultItemSize,\n    trackItemSizes,\n    itemSize,\n    data,\n    firstItemIndex,\n    groupIndices,\n    statefulTotalCount,\n    gap,\n    sizes\n  }, {\n    initialTopMostItemIndex,\n    scrolledToInitialItem\n  }, domIO, stateLoad, followOutput, {\n    listState,\n    topItemsIndexes,\n    ...flags\n  }, {\n    scrollToIndex\n  }, _, {\n    topItemCount\n  }, {\n    groupCounts\n  }, featureGroup1] = _ref103;\n  connect(flags.rangeChanged, featureGroup1.scrollSeekRangeChanged);\n  connect(pipe(featureGroup1.windowViewportRect, map(value => value.visibleHeight)), domIO.viewportHeight);\n  return {\n    // input\n    totalCount,\n    data,\n    firstItemIndex,\n    sizeRanges,\n    initialTopMostItemIndex,\n    scrolledToInitialItem,\n    topItemsIndexes,\n    topItemCount,\n    groupCounts,\n    fixedItemHeight: fixedItemSize,\n    defaultItemHeight: defaultItemSize,\n    gap,\n    ...followOutput,\n    // output\n    statefulTotalCount,\n    listState,\n    scrollToIndex,\n    trackItemSizes,\n    itemSize,\n    groupIndices,\n    // exported from stateFlagsSystem\n    ...flags,\n    // the bag of IO from featureGroup1System\n    ...featureGroup1,\n    ...domIO,\n    sizes,\n    ...stateLoad\n  };\n}, tup(sizeSystem, initialTopMostItemIndexSystem, domIOSystem, stateLoadSystem, followOutputSystem, listStateSystem, scrollToIndexSystem, upwardScrollFixSystem, topItemCountSystem, groupedListSystem, featureGroup1System));\nconst WEBKIT_STICKY = \"-webkit-sticky\";\nconst STICKY = \"sticky\";\nconst positionStickyCssValue = simpleMemoize(() => {\n  if (typeof document === \"undefined\") {\n    return STICKY;\n  }\n  const node = document.createElement(\"div\");\n  node.style.position = WEBKIT_STICKY;\n  return node.style.position === WEBKIT_STICKY ? WEBKIT_STICKY : STICKY;\n});\nfunction useWindowViewportRectRef(callback, customScrollParent) {\n  const viewportInfo = React.useRef(null);\n  const calculateInfo = React.useCallback(element => {\n    if (element === null || !element.offsetParent) {\n      return;\n    }\n    const rect = element.getBoundingClientRect();\n    const visibleWidth = rect.width;\n    let visibleHeight, offsetTop;\n    if (customScrollParent) {\n      const customScrollParentRect = customScrollParent.getBoundingClientRect();\n      const deltaTop = rect.top - customScrollParentRect.top;\n      visibleHeight = customScrollParentRect.height - Math.max(0, deltaTop);\n      offsetTop = deltaTop + customScrollParent.scrollTop;\n    } else {\n      visibleHeight = window.innerHeight - Math.max(0, rect.top);\n      offsetTop = rect.top + window.pageYOffset;\n    }\n    viewportInfo.current = {\n      offsetTop,\n      visibleHeight,\n      visibleWidth\n    };\n    callback(viewportInfo.current);\n  }, [callback, customScrollParent]);\n  const {\n    callbackRef,\n    ref\n  } = useSizeWithElRef(calculateInfo);\n  const scrollAndResizeEventHandler = React.useCallback(() => {\n    calculateInfo(ref.current);\n  }, [calculateInfo, ref]);\n  React.useEffect(() => {\n    if (customScrollParent) {\n      customScrollParent.addEventListener(\"scroll\", scrollAndResizeEventHandler);\n      const observer = new ResizeObserver(scrollAndResizeEventHandler);\n      observer.observe(customScrollParent);\n      return () => {\n        customScrollParent.removeEventListener(\"scroll\", scrollAndResizeEventHandler);\n        observer.unobserve(customScrollParent);\n      };\n    } else {\n      window.addEventListener(\"scroll\", scrollAndResizeEventHandler);\n      window.addEventListener(\"resize\", scrollAndResizeEventHandler);\n      return () => {\n        window.removeEventListener(\"scroll\", scrollAndResizeEventHandler);\n        window.removeEventListener(\"resize\", scrollAndResizeEventHandler);\n      };\n    }\n  }, [scrollAndResizeEventHandler, customScrollParent]);\n  return callbackRef;\n}\nconst VirtuosoMockContext = React.createContext(void 0);\nconst VirtuosoGridMockContext = React.createContext(void 0);\nfunction identity(value) {\n  return value;\n}\nconst listComponentPropsSystem = /* @__PURE__ */system(() => {\n  const itemContent = statefulStream(index => `Item ${index}`);\n  const context = statefulStream(null);\n  const groupContent = statefulStream(index => `Group ${index}`);\n  const components = statefulStream({});\n  const computeItemKey = statefulStream(identity);\n  const headerFooterTag = statefulStream(\"div\");\n  const scrollerRef = statefulStream(noop);\n  const distinctProp = function (propName) {\n    let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return statefulStreamFromEmitter(pipe(components, map(components2 => components2[propName]), distinctUntilChanged()), defaultValue);\n  };\n  return {\n    context,\n    itemContent,\n    groupContent,\n    components,\n    computeItemKey,\n    headerFooterTag,\n    scrollerRef,\n    FooterComponent: distinctProp(\"Footer\"),\n    HeaderComponent: distinctProp(\"Header\"),\n    TopItemListComponent: distinctProp(\"TopItemList\"),\n    ListComponent: distinctProp(\"List\", \"div\"),\n    ItemComponent: distinctProp(\"Item\", \"div\"),\n    GroupComponent: distinctProp(\"Group\", \"div\"),\n    ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n    EmptyPlaceholder: distinctProp(\"EmptyPlaceholder\"),\n    ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\")\n  };\n});\nconst combinedSystem$2 = /* @__PURE__ */system(_ref104 => {\n  let [listSystem2, propsSystem] = _ref104;\n  return {\n    ...listSystem2,\n    ...propsSystem\n  };\n}, tup(listSystem, listComponentPropsSystem));\nconst DefaultScrollSeekPlaceholder$1 = _ref105 => {\n  let {\n    height\n  } = _ref105;\n  return /* @__PURE__ */React.createElement(\"div\", {\n    style: {\n      height\n    }\n  });\n};\nconst GROUP_STYLE = {\n  position: positionStickyCssValue(),\n  zIndex: 1,\n  overflowAnchor: \"none\"\n};\nconst ITEM_STYLE = {\n  overflowAnchor: \"none\"\n};\nconst Items$1 = /* @__PURE__ */React.memo(function VirtuosoItems(_ref106) {\n  let {\n    showTopList = false\n  } = _ref106;\n  const listState = useEmitterValue$2(\"listState\");\n  const sizeRanges = usePublisher$2(\"sizeRanges\");\n  const useWindowScroll = useEmitterValue$2(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n  const windowScrollContainerStateCallback = usePublisher$2(\"windowScrollContainerState\");\n  const _scrollContainerStateCallback = usePublisher$2(\"scrollContainerState\");\n  const scrollContainerStateCallback = customScrollParent || useWindowScroll ? windowScrollContainerStateCallback : _scrollContainerStateCallback;\n  const itemContent = useEmitterValue$2(\"itemContent\");\n  const context = useEmitterValue$2(\"context\");\n  const groupContent = useEmitterValue$2(\"groupContent\");\n  const trackItemSizes = useEmitterValue$2(\"trackItemSizes\");\n  const itemSize = useEmitterValue$2(\"itemSize\");\n  const log = useEmitterValue$2(\"log\");\n  const listGap = usePublisher$2(\"gap\");\n  const {\n    callbackRef\n  } = useChangedListContentsSizes(sizeRanges, itemSize, trackItemSizes, showTopList ? noop : scrollContainerStateCallback, log, listGap, customScrollParent);\n  const [deviation, setDeviation] = React.useState(0);\n  useEmitter$2(\"deviation\", value => {\n    if (deviation !== value) {\n      setDeviation(value);\n    }\n  });\n  const EmptyPlaceholder = useEmitterValue$2(\"EmptyPlaceholder\");\n  const ScrollSeekPlaceholder = useEmitterValue$2(\"ScrollSeekPlaceholder\") || DefaultScrollSeekPlaceholder$1;\n  const ListComponent = useEmitterValue$2(\"ListComponent\");\n  const ItemComponent = useEmitterValue$2(\"ItemComponent\");\n  const GroupComponent = useEmitterValue$2(\"GroupComponent\");\n  const computeItemKey = useEmitterValue$2(\"computeItemKey\");\n  const isSeeking = useEmitterValue$2(\"isSeeking\");\n  const hasGroups2 = useEmitterValue$2(\"groupIndices\").length > 0;\n  const paddingTopAddition = useEmitterValue$2(\"paddingTopAddition\");\n  const scrolledToInitialItem = useEmitterValue$2(\"scrolledToInitialItem\");\n  const containerStyle = showTopList ? {} : {\n    boxSizing: \"border-box\",\n    paddingTop: listState.offsetTop + paddingTopAddition,\n    paddingBottom: listState.offsetBottom,\n    marginTop: deviation,\n    ...(scrolledToInitialItem ? {} : {\n      visibility: \"hidden\"\n    })\n  };\n  if (!showTopList && listState.totalCount === 0 && EmptyPlaceholder) {\n    return React.createElement(EmptyPlaceholder, contextPropIfNotDomElement(EmptyPlaceholder, context));\n  }\n  return React.createElement(ListComponent, {\n    ...contextPropIfNotDomElement(ListComponent, context),\n    ref: callbackRef,\n    style: containerStyle,\n    \"data-test-id\": showTopList ? \"virtuoso-top-item-list\" : \"virtuoso-item-list\"\n  }, (showTopList ? listState.topItems : listState.items).map(item => {\n    const index = item.originalIndex;\n    const key = computeItemKey(index + listState.firstItemIndex, item.data, context);\n    if (isSeeking) {\n      return React.createElement(ScrollSeekPlaceholder, {\n        ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n        key,\n        index: item.index,\n        height: item.size,\n        type: item.type || \"item\",\n        ...(item.type === \"group\" ? {} : {\n          groupIndex: item.groupIndex\n        })\n      });\n    }\n    if (item.type === \"group\") {\n      return React.createElement(GroupComponent, {\n        ...contextPropIfNotDomElement(GroupComponent, context),\n        key,\n        \"data-index\": index,\n        \"data-known-size\": item.size,\n        \"data-item-index\": item.index,\n        style: GROUP_STYLE\n      }, groupContent(item.index, context));\n    } else {\n      return React.createElement(ItemComponent, {\n        ...contextPropIfNotDomElement(ItemComponent, context),\n        key,\n        \"data-index\": index,\n        \"data-known-size\": item.size,\n        \"data-item-index\": item.index,\n        \"data-item-group-index\": item.groupIndex,\n        item: item.data,\n        style: ITEM_STYLE\n      }, hasGroups2 ? itemContent(item.index, item.groupIndex, item.data, context) : itemContent(item.index, item.data, context));\n    }\n  }));\n});\nconst scrollerStyle = {\n  height: \"100%\",\n  outline: \"none\",\n  overflowY: \"auto\",\n  position: \"relative\",\n  WebkitOverflowScrolling: \"touch\"\n};\nconst viewportStyle = {\n  width: \"100%\",\n  height: \"100%\",\n  position: \"absolute\",\n  top: 0\n};\nconst topItemListStyle = {\n  width: \"100%\",\n  position: positionStickyCssValue(),\n  top: 0,\n  zIndex: 1\n};\nfunction contextPropIfNotDomElement(element, context) {\n  if (typeof element === \"string\") {\n    return void 0;\n  }\n  return {\n    context\n  };\n}\nconst Header$1 = /* @__PURE__ */React.memo(function VirtuosoHeader() {\n  const Header2 = useEmitterValue$2(\"HeaderComponent\");\n  const headerHeight = usePublisher$2(\"headerHeight\");\n  const headerFooterTag = useEmitterValue$2(\"headerFooterTag\");\n  const ref = useSize(el => headerHeight(correctItemSize(el, \"height\")));\n  const context = useEmitterValue$2(\"context\");\n  return Header2 ? React.createElement(headerFooterTag, {\n    ref\n  }, React.createElement(Header2, contextPropIfNotDomElement(Header2, context))) : null;\n});\nconst Footer$1 = /* @__PURE__ */React.memo(function VirtuosoFooter() {\n  const Footer2 = useEmitterValue$2(\"FooterComponent\");\n  const footerHeight = usePublisher$2(\"footerHeight\");\n  const headerFooterTag = useEmitterValue$2(\"headerFooterTag\");\n  const ref = useSize(el => footerHeight(correctItemSize(el, \"height\")));\n  const context = useEmitterValue$2(\"context\");\n  return Footer2 ? React.createElement(headerFooterTag, {\n    ref\n  }, React.createElement(Footer2, contextPropIfNotDomElement(Footer2, context))) : null;\n});\nfunction buildScroller(_ref107) {\n  let {\n    usePublisher: usePublisher2,\n    useEmitter: useEmitter2,\n    useEmitterValue: useEmitterValue2\n  } = _ref107;\n  const Scroller2 = React.memo(function VirtuosoScroller(_ref108) {\n    let {\n      style,\n      children,\n      ...props\n    } = _ref108;\n    const scrollContainerStateCallback = usePublisher2(\"scrollContainerState\");\n    const ScrollerComponent = useEmitterValue2(\"ScrollerComponent\");\n    const smoothScrollTargetReached = usePublisher2(\"smoothScrollTargetReached\");\n    const scrollerRefCallback = useEmitterValue2(\"scrollerRef\");\n    const context = useEmitterValue2(\"context\");\n    const {\n      scrollerRef,\n      scrollByCallback,\n      scrollToCallback\n    } = useScrollTop(scrollContainerStateCallback, smoothScrollTargetReached, ScrollerComponent, scrollerRefCallback);\n    useEmitter2(\"scrollTo\", scrollToCallback);\n    useEmitter2(\"scrollBy\", scrollByCallback);\n    return React.createElement(ScrollerComponent, {\n      ref: scrollerRef,\n      style: {\n        ...scrollerStyle,\n        ...style\n      },\n      \"data-test-id\": \"virtuoso-scroller\",\n      \"data-virtuoso-scroller\": true,\n      tabIndex: 0,\n      ...props,\n      ...contextPropIfNotDomElement(ScrollerComponent, context)\n    }, children);\n  });\n  return Scroller2;\n}\nfunction buildWindowScroller(_ref109) {\n  let {\n    usePublisher: usePublisher2,\n    useEmitter: useEmitter2,\n    useEmitterValue: useEmitterValue2\n  } = _ref109;\n  const Scroller2 = React.memo(function VirtuosoWindowScroller(_ref110) {\n    let {\n      style,\n      children,\n      ...props\n    } = _ref110;\n    const scrollContainerStateCallback = usePublisher2(\"windowScrollContainerState\");\n    const ScrollerComponent = useEmitterValue2(\"ScrollerComponent\");\n    const smoothScrollTargetReached = usePublisher2(\"smoothScrollTargetReached\");\n    const totalListHeight = useEmitterValue2(\"totalListHeight\");\n    const deviation = useEmitterValue2(\"deviation\");\n    const customScrollParent = useEmitterValue2(\"customScrollParent\");\n    const context = useEmitterValue2(\"context\");\n    const {\n      scrollerRef,\n      scrollByCallback,\n      scrollToCallback\n    } = useScrollTop(scrollContainerStateCallback, smoothScrollTargetReached, ScrollerComponent, noop, customScrollParent);\n    useIsomorphicLayoutEffect$1(() => {\n      scrollerRef.current = customScrollParent ? customScrollParent : window;\n      return () => {\n        scrollerRef.current = null;\n      };\n    }, [scrollerRef, customScrollParent]);\n    useEmitter2(\"windowScrollTo\", scrollToCallback);\n    useEmitter2(\"scrollBy\", scrollByCallback);\n    return React.createElement(ScrollerComponent, {\n      style: {\n        position: \"relative\",\n        ...style,\n        ...(totalListHeight !== 0 ? {\n          height: totalListHeight + deviation\n        } : {})\n      },\n      \"data-virtuoso-scroller\": true,\n      ...props,\n      ...contextPropIfNotDomElement(ScrollerComponent, context)\n    }, children);\n  });\n  return Scroller2;\n}\nconst Viewport$2 = _ref111 => {\n  let {\n    children\n  } = _ref111;\n  const ctx = React.useContext(VirtuosoMockContext);\n  const viewportHeight = usePublisher$2(\"viewportHeight\");\n  const fixedItemHeight = usePublisher$2(\"fixedItemHeight\");\n  const viewportRef = useSize(compose(viewportHeight, el => correctItemSize(el, \"height\")));\n  React.useEffect(() => {\n    if (ctx) {\n      viewportHeight(ctx.viewportHeight);\n      fixedItemHeight(ctx.itemHeight);\n    }\n  }, [ctx, viewportHeight, fixedItemHeight]);\n  return /* @__PURE__ */React.createElement(\"div\", {\n    style: viewportStyle,\n    ref: viewportRef,\n    \"data-viewport-type\": \"element\"\n  }, children);\n};\nconst WindowViewport$2 = _ref112 => {\n  let {\n    children\n  } = _ref112;\n  const ctx = React.useContext(VirtuosoMockContext);\n  const windowViewportRect = usePublisher$2(\"windowViewportRect\");\n  const fixedItemHeight = usePublisher$2(\"fixedItemHeight\");\n  const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent);\n  React.useEffect(() => {\n    if (ctx) {\n      fixedItemHeight(ctx.itemHeight);\n      windowViewportRect({\n        offsetTop: 0,\n        visibleHeight: ctx.viewportHeight,\n        visibleWidth: 100\n      });\n    }\n  }, [ctx, windowViewportRect, fixedItemHeight]);\n  return /* @__PURE__ */React.createElement(\"div\", {\n    ref: viewportRef,\n    style: viewportStyle,\n    \"data-viewport-type\": \"window\"\n  }, children);\n};\nconst TopItemListContainer = _ref113 => {\n  let {\n    children\n  } = _ref113;\n  const TopItemList = useEmitterValue$2(\"TopItemListComponent\");\n  const headerHeight = useEmitterValue$2(\"headerHeight\");\n  const style = {\n    ...topItemListStyle,\n    marginTop: `${headerHeight}px`\n  };\n  const context = useEmitterValue$2(\"context\");\n  return React.createElement(TopItemList || \"div\", {\n    style,\n    context\n  }, children);\n};\nconst ListRoot = /* @__PURE__ */React.memo(function VirtuosoRoot(props) {\n  const useWindowScroll = useEmitterValue$2(\"useWindowScroll\");\n  const showTopList = useEmitterValue$2(\"topItemsIndexes\").length > 0;\n  const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller$2 : Scroller$2;\n  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport$2 : Viewport$2;\n  return /* @__PURE__ */React.createElement(TheScroller, {\n    ...props\n  }, showTopList && /* @__PURE__ */React.createElement(TopItemListContainer, null, /* @__PURE__ */React.createElement(Items$1, {\n    showTopList: true\n  })), /* @__PURE__ */React.createElement(TheViewport, null, /* @__PURE__ */React.createElement(Header$1, null), /* @__PURE__ */React.createElement(Items$1, null), /* @__PURE__ */React.createElement(Footer$1, null)));\n});\nconst {\n  Component: List,\n  usePublisher: usePublisher$2,\n  useEmitterValue: useEmitterValue$2,\n  useEmitter: useEmitter$2\n} = /* @__PURE__ */systemToComponent(combinedSystem$2, {\n  required: {},\n  optional: {\n    restoreStateFrom: \"restoreStateFrom\",\n    context: \"context\",\n    followOutput: \"followOutput\",\n    itemContent: \"itemContent\",\n    groupContent: \"groupContent\",\n    overscan: \"overscan\",\n    increaseViewportBy: \"increaseViewportBy\",\n    totalCount: \"totalCount\",\n    groupCounts: \"groupCounts\",\n    topItemCount: \"topItemCount\",\n    firstItemIndex: \"firstItemIndex\",\n    initialTopMostItemIndex: \"initialTopMostItemIndex\",\n    components: \"components\",\n    atBottomThreshold: \"atBottomThreshold\",\n    atTopThreshold: \"atTopThreshold\",\n    computeItemKey: \"computeItemKey\",\n    defaultItemHeight: \"defaultItemHeight\",\n    fixedItemHeight: \"fixedItemHeight\",\n    itemSize: \"itemSize\",\n    scrollSeekConfiguration: \"scrollSeekConfiguration\",\n    headerFooterTag: \"headerFooterTag\",\n    data: \"data\",\n    initialItemCount: \"initialItemCount\",\n    initialScrollTop: \"initialScrollTop\",\n    alignToBottom: \"alignToBottom\",\n    useWindowScroll: \"useWindowScroll\",\n    customScrollParent: \"customScrollParent\",\n    scrollerRef: \"scrollerRef\",\n    logLevel: \"logLevel\"\n  },\n  methods: {\n    scrollToIndex: \"scrollToIndex\",\n    scrollIntoView: \"scrollIntoView\",\n    scrollTo: \"scrollTo\",\n    scrollBy: \"scrollBy\",\n    autoscrollToBottom: \"autoscrollToBottom\",\n    getState: \"getState\"\n  },\n  events: {\n    isScrolling: \"isScrolling\",\n    endReached: \"endReached\",\n    startReached: \"startReached\",\n    rangeChanged: \"rangeChanged\",\n    atBottomStateChange: \"atBottomStateChange\",\n    atTopStateChange: \"atTopStateChange\",\n    totalListHeightChanged: \"totalListHeightChanged\",\n    itemsRendered: \"itemsRendered\",\n    groupIndices: \"groupIndices\"\n  }\n}, ListRoot);\nconst Scroller$2 = /* @__PURE__ */buildScroller({\n  usePublisher: usePublisher$2,\n  useEmitterValue: useEmitterValue$2,\n  useEmitter: useEmitter$2\n});\nconst WindowScroller$2 = /* @__PURE__ */buildWindowScroller({\n  usePublisher: usePublisher$2,\n  useEmitterValue: useEmitterValue$2,\n  useEmitter: useEmitter$2\n});\nconst Virtuoso = List;\nconst GroupedVirtuoso = List;\nconst INITIAL_GRID_STATE = {\n  items: [],\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0,\n  bottom: 0,\n  itemHeight: 0,\n  itemWidth: 0\n};\nconst PROBE_GRID_STATE = {\n  items: [{\n    index: 0\n  }],\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0,\n  bottom: 0,\n  itemHeight: 0,\n  itemWidth: 0\n};\nconst {\n  round,\n  ceil,\n  floor,\n  min,\n  max\n} = Math;\nfunction buildProbeGridState(items) {\n  return {\n    ...PROBE_GRID_STATE,\n    items\n  };\n}\nfunction buildItems(startIndex, endIndex, data) {\n  return Array.from({\n    length: endIndex - startIndex + 1\n  }).map((_, i) => ({\n    index: i + startIndex,\n    data: data == null ? void 0 : data[i + startIndex]\n  }));\n}\nfunction gapComparator(prev, next) {\n  return prev && prev.column === next.column && prev.row === next.row;\n}\nfunction dimensionComparator(prev, next) {\n  return prev && prev.width === next.width && prev.height === next.height;\n}\nconst gridSystem = /* @__PURE__ */system(_ref114 => {\n  let [{\n    overscan,\n    visibleRange,\n    listBoundary\n  }, {\n    scrollTop,\n    viewportHeight,\n    scrollBy,\n    scrollTo,\n    smoothScrollTargetReached,\n    scrollContainerState,\n    footerHeight,\n    headerHeight\n  }, stateFlags, scrollSeek, {\n    propsReady,\n    didMount\n  }, {\n    windowViewportRect,\n    windowScrollTo,\n    useWindowScroll,\n    customScrollParent,\n    windowScrollContainerState\n  }, log] = _ref114;\n  const totalCount = statefulStream(0);\n  const initialItemCount = statefulStream(0);\n  const gridState = statefulStream(INITIAL_GRID_STATE);\n  const viewportDimensions = statefulStream({\n    height: 0,\n    width: 0\n  });\n  const itemDimensions = statefulStream({\n    height: 0,\n    width: 0\n  });\n  const scrollToIndex = stream();\n  const scrollHeight = stream();\n  const deviation = statefulStream(0);\n  const data = statefulStream(void 0);\n  const gap = statefulStream({\n    row: 0,\n    column: 0\n  });\n  connect(pipe(didMount, withLatestFrom(initialItemCount, data), filter(_ref115 => {\n    let [didMount2, count] = _ref115;\n    return didMount2 && count !== 0;\n  }), map(_ref116 => {\n    let [, count, data2] = _ref116;\n    return {\n      items: buildItems(0, count - 1, data2),\n      top: 0,\n      bottom: 0,\n      offsetBottom: 0,\n      offsetTop: 0,\n      itemHeight: 0,\n      itemWidth: 0\n    };\n  })), gridState);\n  connect(pipe(combineLatest(duc(totalCount), visibleRange, duc(gap, gapComparator), duc(itemDimensions, dimensionComparator), duc(viewportDimensions, dimensionComparator), data), map(_ref117 => {\n    let [totalCount2, [startOffset, endOffset], gap2, item, viewport, data2] = _ref117;\n    const {\n      row: rowGap,\n      column: columnGap\n    } = gap2;\n    const {\n      height: itemHeight,\n      width: itemWidth\n    } = item;\n    const {\n      width: viewportWidth\n    } = viewport;\n    if (totalCount2 === 0 || viewportWidth === 0) {\n      return INITIAL_GRID_STATE;\n    }\n    if (itemWidth === 0) {\n      return buildProbeGridState(buildItems(0, 0, data2));\n    }\n    const perRow = itemsPerRow(viewportWidth, itemWidth, columnGap);\n    let startIndex = perRow * floor((startOffset + rowGap) / (itemHeight + rowGap));\n    let endIndex = perRow * ceil((endOffset + rowGap) / (itemHeight + rowGap)) - 1;\n    endIndex = min(totalCount2 - 1, max(endIndex, perRow - 1));\n    startIndex = min(endIndex, max(0, startIndex));\n    const items = buildItems(startIndex, endIndex, data2);\n    const {\n      top,\n      bottom\n    } = gridLayout(viewport, gap2, item, items);\n    const rowCount = ceil(totalCount2 / perRow);\n    const totalHeight = rowCount * itemHeight + (rowCount - 1) * rowGap;\n    const offsetBottom = totalHeight - bottom;\n    return {\n      items,\n      offsetTop: top,\n      offsetBottom,\n      top,\n      bottom,\n      itemHeight,\n      itemWidth\n    };\n  })), gridState);\n  connect(pipe(data, filter(isDefined), map(data2 => data2.length)), totalCount);\n  connect(pipe(viewportDimensions, map(_ref118 => {\n    let {\n      height\n    } = _ref118;\n    return height;\n  })), viewportHeight);\n  connect(pipe(combineLatest(viewportDimensions, itemDimensions, gridState, gap), map(_ref119 => {\n    let [viewportDimensions2, item, {\n      items\n    }, gap2] = _ref119;\n    const {\n      top,\n      bottom\n    } = gridLayout(viewportDimensions2, gap2, item, items);\n    return [top, bottom];\n  }), distinctUntilChanged(tupleComparator)), listBoundary);\n  const hasScrolled = statefulStream(false);\n  connect(pipe(scrollTop, withLatestFrom(hasScrolled), map(_ref120 => {\n    let [scrollTop2, hasScrolled2] = _ref120;\n    return hasScrolled2 || scrollTop2 !== 0;\n  })), hasScrolled);\n  const endReached = streamFromEmitter(pipe(duc(gridState), filter(_ref121 => {\n    let {\n      items\n    } = _ref121;\n    return items.length > 0;\n  }), withLatestFrom(totalCount, hasScrolled), filter(_ref122 => {\n    let [{\n      items\n    }, totalCount2, hasScrolled2] = _ref122;\n    return hasScrolled2 && items[items.length - 1].index === totalCount2 - 1;\n  }), map(_ref123 => {\n    let [, totalCount2] = _ref123;\n    return totalCount2 - 1;\n  }), distinctUntilChanged()));\n  const startReached = streamFromEmitter(pipe(duc(gridState), filter(_ref124 => {\n    let {\n      items\n    } = _ref124;\n    return items.length > 0 && items[0].index === 0;\n  }),\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n  mapTo(0), distinctUntilChanged()));\n  const rangeChanged = streamFromEmitter(pipe(duc(gridState), filter(_ref125 => {\n    let {\n      items\n    } = _ref125;\n    return items.length > 0;\n  }), map(_ref126 => {\n    let {\n      items\n    } = _ref126;\n    return {\n      startIndex: items[0].index,\n      endIndex: items[items.length - 1].index\n    };\n  }), distinctUntilChanged(rangeComparator)));\n  connect(rangeChanged, scrollSeek.scrollSeekRangeChanged);\n  connect(pipe(scrollToIndex, withLatestFrom(viewportDimensions, itemDimensions, totalCount, gap), map(_ref127 => {\n    let [location, viewport, item, totalCount2, gap2] = _ref127;\n    const normalLocation = normalizeIndexLocation(location);\n    const {\n      align,\n      behavior,\n      offset\n    } = normalLocation;\n    let index = normalLocation.index;\n    if (index === \"LAST\") {\n      index = totalCount2 - 1;\n    }\n    index = max(0, index, min(totalCount2 - 1, index));\n    let top = itemTop(viewport, gap2, item, index);\n    if (align === \"end\") {\n      top = round(top - viewport.height + item.height);\n    } else if (align === \"center\") {\n      top = round(top - viewport.height / 2 + item.height / 2);\n    }\n    if (offset) {\n      top += offset;\n    }\n    return {\n      top,\n      behavior\n    };\n  })), scrollTo);\n  const totalListHeight = statefulStreamFromEmitter(pipe(gridState, map(gridState2 => {\n    return gridState2.offsetBottom + gridState2.bottom;\n  })), 0);\n  connect(pipe(windowViewportRect, map(viewportInfo => ({\n    width: viewportInfo.visibleWidth,\n    height: viewportInfo.visibleHeight\n  }))), viewportDimensions);\n  return {\n    // input\n    data,\n    totalCount,\n    viewportDimensions,\n    itemDimensions,\n    scrollTop,\n    scrollHeight,\n    overscan,\n    scrollBy,\n    scrollTo,\n    scrollToIndex,\n    smoothScrollTargetReached,\n    windowViewportRect,\n    windowScrollTo,\n    useWindowScroll,\n    customScrollParent,\n    windowScrollContainerState,\n    deviation,\n    scrollContainerState,\n    footerHeight,\n    headerHeight,\n    initialItemCount,\n    gap,\n    ...scrollSeek,\n    // output\n    gridState,\n    totalListHeight,\n    ...stateFlags,\n    startReached,\n    endReached,\n    rangeChanged,\n    propsReady,\n    ...log\n  };\n}, tup(sizeRangeSystem, domIOSystem, stateFlagsSystem, scrollSeekSystem, propsReadySystem, windowScrollerSystem, loggerSystem));\nfunction gridLayout(viewport, gap, item, items) {\n  const {\n    height: itemHeight\n  } = item;\n  if (itemHeight === void 0 || items.length === 0) {\n    return {\n      top: 0,\n      bottom: 0\n    };\n  }\n  const top = itemTop(viewport, gap, item, items[0].index);\n  const bottom = itemTop(viewport, gap, item, items[items.length - 1].index) + itemHeight;\n  return {\n    top,\n    bottom\n  };\n}\nfunction itemTop(viewport, gap, item, index) {\n  const perRow = itemsPerRow(viewport.width, item.width, gap.column);\n  const rowCount = floor(index / perRow);\n  const top = rowCount * item.height + max(0, rowCount - 1) * gap.row;\n  return top > 0 ? top + gap.row : top;\n}\nfunction itemsPerRow(viewportWidth, itemWidth, gap) {\n  return max(1, floor((viewportWidth + gap) / (floor(itemWidth) + gap)));\n}\nconst gridComponentPropsSystem = /* @__PURE__ */system(() => {\n  const itemContent = statefulStream(index => `Item ${index}`);\n  const components = statefulStream({});\n  const context = statefulStream(null);\n  const itemClassName = statefulStream(\"virtuoso-grid-item\");\n  const listClassName = statefulStream(\"virtuoso-grid-list\");\n  const computeItemKey = statefulStream(identity);\n  const headerFooterTag = statefulStream(\"div\");\n  const scrollerRef = statefulStream(noop);\n  const distinctProp = function (propName) {\n    let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return statefulStreamFromEmitter(pipe(components, map(components2 => components2[propName]), distinctUntilChanged()), defaultValue);\n  };\n  return {\n    context,\n    itemContent,\n    components,\n    computeItemKey,\n    itemClassName,\n    listClassName,\n    headerFooterTag,\n    scrollerRef,\n    FooterComponent: distinctProp(\"Footer\"),\n    HeaderComponent: distinctProp(\"Header\"),\n    ListComponent: distinctProp(\"List\", \"div\"),\n    ItemComponent: distinctProp(\"Item\", \"div\"),\n    ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n    ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\", \"div\")\n  };\n});\nconst combinedSystem$1 = /* @__PURE__ */system(_ref128 => {\n  let [gridSystem2, gridComponentPropsSystem2] = _ref128;\n  return {\n    ...gridSystem2,\n    ...gridComponentPropsSystem2\n  };\n}, tup(gridSystem, gridComponentPropsSystem));\nconst GridItems = /* @__PURE__ */React.memo(function GridItems2() {\n  const gridState = useEmitterValue$1(\"gridState\");\n  const listClassName = useEmitterValue$1(\"listClassName\");\n  const itemClassName = useEmitterValue$1(\"itemClassName\");\n  const itemContent = useEmitterValue$1(\"itemContent\");\n  const computeItemKey = useEmitterValue$1(\"computeItemKey\");\n  const isSeeking = useEmitterValue$1(\"isSeeking\");\n  const scrollHeightCallback = usePublisher$1(\"scrollHeight\");\n  const ItemComponent = useEmitterValue$1(\"ItemComponent\");\n  const ListComponent = useEmitterValue$1(\"ListComponent\");\n  const ScrollSeekPlaceholder = useEmitterValue$1(\"ScrollSeekPlaceholder\");\n  const context = useEmitterValue$1(\"context\");\n  const itemDimensions = usePublisher$1(\"itemDimensions\");\n  const gridGap = usePublisher$1(\"gap\");\n  const log = useEmitterValue$1(\"log\");\n  const listRef = useSize(el => {\n    const scrollHeight = el.parentElement.parentElement.scrollHeight;\n    scrollHeightCallback(scrollHeight);\n    const firstItem = el.firstChild;\n    if (firstItem) {\n      itemDimensions(firstItem.getBoundingClientRect());\n    }\n    gridGap({\n      row: resolveGapValue(\"row-gap\", getComputedStyle(el).rowGap, log),\n      column: resolveGapValue(\"column-gap\", getComputedStyle(el).columnGap, log)\n    });\n  });\n  return React.createElement(ListComponent, {\n    ref: listRef,\n    className: listClassName,\n    ...contextPropIfNotDomElement(ListComponent, context),\n    style: {\n      paddingTop: gridState.offsetTop,\n      paddingBottom: gridState.offsetBottom\n    },\n    \"data-test-id\": \"virtuoso-item-list\"\n  }, gridState.items.map(item => {\n    const key = computeItemKey(item.index, item.data, context);\n    return isSeeking ? React.createElement(ScrollSeekPlaceholder, {\n      key,\n      ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n      index: item.index,\n      height: gridState.itemHeight,\n      width: gridState.itemWidth\n    }) : React.createElement(ItemComponent, {\n      ...contextPropIfNotDomElement(ItemComponent, context),\n      className: itemClassName,\n      \"data-index\": item.index,\n      key\n    }, itemContent(item.index, item.data, context));\n  }));\n});\nconst Header = React.memo(function VirtuosoHeader2() {\n  const Header2 = useEmitterValue$1(\"HeaderComponent\");\n  const headerHeight = usePublisher$1(\"headerHeight\");\n  const headerFooterTag = useEmitterValue$1(\"headerFooterTag\");\n  const ref = useSize(el => headerHeight(correctItemSize(el, \"height\")));\n  const context = useEmitterValue$1(\"context\");\n  return Header2 ? React.createElement(headerFooterTag, {\n    ref\n  }, React.createElement(Header2, contextPropIfNotDomElement(Header2, context))) : null;\n});\nconst Footer = React.memo(function VirtuosoGridFooter() {\n  const Footer2 = useEmitterValue$1(\"FooterComponent\");\n  const footerHeight = usePublisher$1(\"footerHeight\");\n  const headerFooterTag = useEmitterValue$1(\"headerFooterTag\");\n  const ref = useSize(el => footerHeight(correctItemSize(el, \"height\")));\n  const context = useEmitterValue$1(\"context\");\n  return Footer2 ? React.createElement(headerFooterTag, {\n    ref\n  }, React.createElement(Footer2, contextPropIfNotDomElement(Footer2, context))) : null;\n});\nconst Viewport$1 = _ref129 => {\n  let {\n    children\n  } = _ref129;\n  const ctx = React.useContext(VirtuosoGridMockContext);\n  const itemDimensions = usePublisher$1(\"itemDimensions\");\n  const viewportDimensions = usePublisher$1(\"viewportDimensions\");\n  const viewportRef = useSize(el => {\n    viewportDimensions(el.getBoundingClientRect());\n  });\n  React.useEffect(() => {\n    if (ctx) {\n      viewportDimensions({\n        height: ctx.viewportHeight,\n        width: ctx.viewportWidth\n      });\n      itemDimensions({\n        height: ctx.itemHeight,\n        width: ctx.itemWidth\n      });\n    }\n  }, [ctx, viewportDimensions, itemDimensions]);\n  return /* @__PURE__ */React.createElement(\"div\", {\n    style: viewportStyle,\n    ref: viewportRef\n  }, children);\n};\nconst WindowViewport$1 = _ref130 => {\n  let {\n    children\n  } = _ref130;\n  const ctx = React.useContext(VirtuosoGridMockContext);\n  const windowViewportRect = usePublisher$1(\"windowViewportRect\");\n  const itemDimensions = usePublisher$1(\"itemDimensions\");\n  const customScrollParent = useEmitterValue$1(\"customScrollParent\");\n  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent);\n  React.useEffect(() => {\n    if (ctx) {\n      itemDimensions({\n        height: ctx.itemHeight,\n        width: ctx.itemWidth\n      });\n      windowViewportRect({\n        offsetTop: 0,\n        visibleHeight: ctx.viewportHeight,\n        visibleWidth: ctx.viewportWidth\n      });\n    }\n  }, [ctx, windowViewportRect, itemDimensions]);\n  return /* @__PURE__ */React.createElement(\"div\", {\n    ref: viewportRef,\n    style: viewportStyle\n  }, children);\n};\nconst GridRoot = /* @__PURE__ */React.memo(function GridRoot2(_ref131) {\n  let {\n    ...props\n  } = _ref131;\n  const useWindowScroll = useEmitterValue$1(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue$1(\"customScrollParent\");\n  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller$1 : Scroller$1;\n  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport$1 : Viewport$1;\n  return /* @__PURE__ */React.createElement(TheScroller, {\n    ...props\n  }, /* @__PURE__ */React.createElement(TheViewport, null, /* @__PURE__ */React.createElement(Header, null), /* @__PURE__ */React.createElement(GridItems, null), /* @__PURE__ */React.createElement(Footer, null)));\n});\nconst {\n  Component: Grid,\n  usePublisher: usePublisher$1,\n  useEmitterValue: useEmitterValue$1,\n  useEmitter: useEmitter$1\n} = /* @__PURE__ */systemToComponent(combinedSystem$1, {\n  optional: {\n    context: \"context\",\n    totalCount: \"totalCount\",\n    overscan: \"overscan\",\n    itemContent: \"itemContent\",\n    components: \"components\",\n    computeItemKey: \"computeItemKey\",\n    data: \"data\",\n    initialItemCount: \"initialItemCount\",\n    scrollSeekConfiguration: \"scrollSeekConfiguration\",\n    headerFooterTag: \"headerFooterTag\",\n    listClassName: \"listClassName\",\n    itemClassName: \"itemClassName\",\n    useWindowScroll: \"useWindowScroll\",\n    customScrollParent: \"customScrollParent\",\n    scrollerRef: \"scrollerRef\",\n    logLevel: \"logLevel\"\n  },\n  methods: {\n    scrollTo: \"scrollTo\",\n    scrollBy: \"scrollBy\",\n    scrollToIndex: \"scrollToIndex\"\n  },\n  events: {\n    isScrolling: \"isScrolling\",\n    endReached: \"endReached\",\n    startReached: \"startReached\",\n    rangeChanged: \"rangeChanged\",\n    atBottomStateChange: \"atBottomStateChange\",\n    atTopStateChange: \"atTopStateChange\"\n  }\n}, GridRoot);\nconst Scroller$1 = /* @__PURE__ */buildScroller({\n  usePublisher: usePublisher$1,\n  useEmitterValue: useEmitterValue$1,\n  useEmitter: useEmitter$1\n});\nconst WindowScroller$1 = /* @__PURE__ */buildWindowScroller({\n  usePublisher: usePublisher$1,\n  useEmitterValue: useEmitterValue$1,\n  useEmitter: useEmitter$1\n});\nfunction resolveGapValue(property, value, log) {\n  if (value !== \"normal\" && !(value == null ? void 0 : value.endsWith(\"px\"))) {\n    log(`${property} was not resolved to pixel value correctly`, value, LogLevel.WARN);\n  }\n  if (value === \"normal\") {\n    return 0;\n  }\n  return parseInt(value != null ? value : \"0\", 10);\n}\nconst VirtuosoGrid = Grid;\nconst tableComponentPropsSystem = /* @__PURE__ */system(() => {\n  const itemContent = statefulStream(index => /* @__PURE__ */React.createElement(\"td\", null, \"Item $\", index));\n  const context = statefulStream(null);\n  const fixedHeaderContent = statefulStream(null);\n  const fixedFooterContent = statefulStream(null);\n  const components = statefulStream({});\n  const computeItemKey = statefulStream(identity);\n  const scrollerRef = statefulStream(noop);\n  const distinctProp = function (propName) {\n    let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return statefulStreamFromEmitter(pipe(components, map(components2 => components2[propName]), distinctUntilChanged()), defaultValue);\n  };\n  return {\n    context,\n    itemContent,\n    fixedHeaderContent,\n    fixedFooterContent,\n    components,\n    computeItemKey,\n    scrollerRef,\n    TableComponent: distinctProp(\"Table\", \"table\"),\n    TableHeadComponent: distinctProp(\"TableHead\", \"thead\"),\n    TableFooterComponent: distinctProp(\"TableFoot\", \"tfoot\"),\n    TableBodyComponent: distinctProp(\"TableBody\", \"tbody\"),\n    TableRowComponent: distinctProp(\"TableRow\", \"tr\"),\n    ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n    EmptyPlaceholder: distinctProp(\"EmptyPlaceholder\"),\n    ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\"),\n    FillerRow: distinctProp(\"FillerRow\")\n  };\n});\nconst combinedSystem = /* @__PURE__ */system(_ref132 => {\n  let [listSystem2, propsSystem] = _ref132;\n  return {\n    ...listSystem2,\n    ...propsSystem\n  };\n}, tup(listSystem, tableComponentPropsSystem));\nconst DefaultScrollSeekPlaceholder = _ref133 => {\n  let {\n    height\n  } = _ref133;\n  return /* @__PURE__ */React.createElement(\"tr\", null, /* @__PURE__ */React.createElement(\"td\", {\n    style: {\n      height\n    }\n  }));\n};\nconst DefaultFillerRow = _ref134 => {\n  let {\n    height\n  } = _ref134;\n  return /* @__PURE__ */React.createElement(\"tr\", null, /* @__PURE__ */React.createElement(\"td\", {\n    style: {\n      height,\n      padding: 0,\n      border: 0\n    }\n  }));\n};\nconst Items = /* @__PURE__ */React.memo(function VirtuosoItems2() {\n  const listState = useEmitterValue(\"listState\");\n  const sizeRanges = usePublisher(\"sizeRanges\");\n  const useWindowScroll = useEmitterValue(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue(\"customScrollParent\");\n  const windowScrollContainerStateCallback = usePublisher(\"windowScrollContainerState\");\n  const _scrollContainerStateCallback = usePublisher(\"scrollContainerState\");\n  const scrollContainerStateCallback = customScrollParent || useWindowScroll ? windowScrollContainerStateCallback : _scrollContainerStateCallback;\n  const itemContent = useEmitterValue(\"itemContent\");\n  const trackItemSizes = useEmitterValue(\"trackItemSizes\");\n  const itemSize = useEmitterValue(\"itemSize\");\n  const log = useEmitterValue(\"log\");\n  const {\n    callbackRef,\n    ref\n  } = useChangedListContentsSizes(sizeRanges, itemSize, trackItemSizes, scrollContainerStateCallback, log, void 0, customScrollParent);\n  const [deviation, setDeviation] = React.useState(0);\n  useEmitter(\"deviation\", value => {\n    if (deviation !== value) {\n      ref.current.style.marginTop = `${value}px`;\n      setDeviation(value);\n    }\n  });\n  const EmptyPlaceholder = useEmitterValue(\"EmptyPlaceholder\");\n  const ScrollSeekPlaceholder = useEmitterValue(\"ScrollSeekPlaceholder\") || DefaultScrollSeekPlaceholder;\n  const FillerRow = useEmitterValue(\"FillerRow\") || DefaultFillerRow;\n  const TableBodyComponent = useEmitterValue(\"TableBodyComponent\");\n  const TableRowComponent = useEmitterValue(\"TableRowComponent\");\n  const computeItemKey = useEmitterValue(\"computeItemKey\");\n  const isSeeking = useEmitterValue(\"isSeeking\");\n  const paddingTopAddition = useEmitterValue(\"paddingTopAddition\");\n  const firstItemIndex = useEmitterValue(\"firstItemIndex\");\n  const statefulTotalCount = useEmitterValue(\"statefulTotalCount\");\n  const context = useEmitterValue(\"context\");\n  if (statefulTotalCount === 0 && EmptyPlaceholder) {\n    return React.createElement(EmptyPlaceholder, contextPropIfNotDomElement(EmptyPlaceholder, context));\n  }\n  const paddingTop = listState.offsetTop + paddingTopAddition + deviation;\n  const paddingBottom = listState.offsetBottom;\n  const paddingTopEl = paddingTop > 0 ? /* @__PURE__ */React.createElement(FillerRow, {\n    height: paddingTop,\n    key: \"padding-top\",\n    context\n  }) : null;\n  const paddingBottomEl = paddingBottom > 0 ? /* @__PURE__ */React.createElement(FillerRow, {\n    height: paddingBottom,\n    key: \"padding-bottom\",\n    context\n  }) : null;\n  const items = listState.items.map(item => {\n    const index = item.originalIndex;\n    const key = computeItemKey(index + firstItemIndex, item.data, context);\n    if (isSeeking) {\n      return React.createElement(ScrollSeekPlaceholder, {\n        ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n        key,\n        index: item.index,\n        height: item.size,\n        type: item.type || \"item\"\n      });\n    }\n    return React.createElement(TableRowComponent, {\n      ...contextPropIfNotDomElement(TableRowComponent, context),\n      key,\n      \"data-index\": index,\n      \"data-known-size\": item.size,\n      \"data-item-index\": item.index,\n      item: item.data,\n      style: {\n        overflowAnchor: \"none\"\n      }\n    }, itemContent(item.index, item.data, context));\n  });\n  return React.createElement(TableBodyComponent, {\n    ref: callbackRef,\n    \"data-test-id\": \"virtuoso-item-list\",\n    ...contextPropIfNotDomElement(TableBodyComponent, context)\n  }, [paddingTopEl, ...items, paddingBottomEl]);\n});\nconst Viewport = _ref135 => {\n  let {\n    children\n  } = _ref135;\n  const ctx = React.useContext(VirtuosoMockContext);\n  const viewportHeight = usePublisher(\"viewportHeight\");\n  const fixedItemHeight = usePublisher(\"fixedItemHeight\");\n  const viewportRef = useSize(compose(viewportHeight, el => correctItemSize(el, \"height\")));\n  React.useEffect(() => {\n    if (ctx) {\n      viewportHeight(ctx.viewportHeight);\n      fixedItemHeight(ctx.itemHeight);\n    }\n  }, [ctx, viewportHeight, fixedItemHeight]);\n  return /* @__PURE__ */React.createElement(\"div\", {\n    style: viewportStyle,\n    ref: viewportRef,\n    \"data-viewport-type\": \"element\"\n  }, children);\n};\nconst WindowViewport = _ref136 => {\n  let {\n    children\n  } = _ref136;\n  const ctx = React.useContext(VirtuosoMockContext);\n  const windowViewportRect = usePublisher(\"windowViewportRect\");\n  const fixedItemHeight = usePublisher(\"fixedItemHeight\");\n  const customScrollParent = useEmitterValue(\"customScrollParent\");\n  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent);\n  React.useEffect(() => {\n    if (ctx) {\n      fixedItemHeight(ctx.itemHeight);\n      windowViewportRect({\n        offsetTop: 0,\n        visibleHeight: ctx.viewportHeight,\n        visibleWidth: 100\n      });\n    }\n  }, [ctx, windowViewportRect, fixedItemHeight]);\n  return /* @__PURE__ */React.createElement(\"div\", {\n    ref: viewportRef,\n    style: viewportStyle,\n    \"data-viewport-type\": \"window\"\n  }, children);\n};\nconst TableRoot = /* @__PURE__ */React.memo(function TableVirtuosoRoot(props) {\n  const useWindowScroll = useEmitterValue(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue(\"customScrollParent\");\n  const fixedHeaderHeight = usePublisher(\"fixedHeaderHeight\");\n  const fixedFooterHeight = usePublisher(\"fixedFooterHeight\");\n  const fixedHeaderContent = useEmitterValue(\"fixedHeaderContent\");\n  const fixedFooterContent = useEmitterValue(\"fixedFooterContent\");\n  const context = useEmitterValue(\"context\");\n  const theadRef = useSize(compose(fixedHeaderHeight, el => correctItemSize(el, \"height\")));\n  const tfootRef = useSize(compose(fixedFooterHeight, el => correctItemSize(el, \"height\")));\n  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller : Scroller;\n  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport : Viewport;\n  const TheTable = useEmitterValue(\"TableComponent\");\n  const TheTHead = useEmitterValue(\"TableHeadComponent\");\n  const TheTFoot = useEmitterValue(\"TableFooterComponent\");\n  const theHead = fixedHeaderContent ? React.createElement(TheTHead, {\n    key: \"TableHead\",\n    style: {\n      zIndex: 2,\n      position: \"sticky\",\n      top: 0\n    },\n    ref: theadRef,\n    ...contextPropIfNotDomElement(TheTHead, context)\n  }, fixedHeaderContent()) : null;\n  const theFoot = fixedFooterContent ? React.createElement(TheTFoot, {\n    key: \"TableFoot\",\n    style: {\n      zIndex: 1,\n      position: \"sticky\",\n      bottom: 0\n    },\n    ref: tfootRef,\n    ...contextPropIfNotDomElement(TheTFoot, context)\n  }, fixedFooterContent()) : null;\n  return /* @__PURE__ */React.createElement(TheScroller, {\n    ...props\n  }, /* @__PURE__ */React.createElement(TheViewport, null, React.createElement(TheTable, {\n    style: {\n      borderSpacing: 0\n    },\n    ...contextPropIfNotDomElement(TheTable, context)\n  }, [theHead, /* @__PURE__ */React.createElement(Items, {\n    key: \"TableBody\"\n  }), theFoot])));\n});\nconst {\n  Component: Table,\n  usePublisher,\n  useEmitterValue,\n  useEmitter\n} = /* @__PURE__ */systemToComponent(combinedSystem, {\n  required: {},\n  optional: {\n    context: \"context\",\n    followOutput: \"followOutput\",\n    firstItemIndex: \"firstItemIndex\",\n    itemContent: \"itemContent\",\n    fixedHeaderContent: \"fixedHeaderContent\",\n    fixedFooterContent: \"fixedFooterContent\",\n    overscan: \"overscan\",\n    increaseViewportBy: \"increaseViewportBy\",\n    totalCount: \"totalCount\",\n    topItemCount: \"topItemCount\",\n    initialTopMostItemIndex: \"initialTopMostItemIndex\",\n    components: \"components\",\n    groupCounts: \"groupCounts\",\n    atBottomThreshold: \"atBottomThreshold\",\n    atTopThreshold: \"atTopThreshold\",\n    computeItemKey: \"computeItemKey\",\n    defaultItemHeight: \"defaultItemHeight\",\n    fixedItemHeight: \"fixedItemHeight\",\n    itemSize: \"itemSize\",\n    scrollSeekConfiguration: \"scrollSeekConfiguration\",\n    data: \"data\",\n    initialItemCount: \"initialItemCount\",\n    initialScrollTop: \"initialScrollTop\",\n    alignToBottom: \"alignToBottom\",\n    useWindowScroll: \"useWindowScroll\",\n    customScrollParent: \"customScrollParent\",\n    scrollerRef: \"scrollerRef\",\n    logLevel: \"logLevel\"\n  },\n  methods: {\n    scrollToIndex: \"scrollToIndex\",\n    scrollIntoView: \"scrollIntoView\",\n    scrollTo: \"scrollTo\",\n    scrollBy: \"scrollBy\"\n  },\n  events: {\n    isScrolling: \"isScrolling\",\n    endReached: \"endReached\",\n    startReached: \"startReached\",\n    rangeChanged: \"rangeChanged\",\n    atBottomStateChange: \"atBottomStateChange\",\n    atTopStateChange: \"atTopStateChange\",\n    totalListHeightChanged: \"totalListHeightChanged\",\n    itemsRendered: \"itemsRendered\",\n    groupIndices: \"groupIndices\"\n  }\n}, TableRoot);\nconst Scroller = /* @__PURE__ */buildScroller({\n  usePublisher,\n  useEmitterValue,\n  useEmitter\n});\nconst WindowScroller = /* @__PURE__ */buildWindowScroller({\n  usePublisher,\n  useEmitterValue,\n  useEmitter\n});\nconst TableVirtuoso = Table;\nexport { GroupedVirtuoso, LogLevel, TableVirtuoso, Virtuoso, VirtuosoGrid, VirtuosoGridMockContext, VirtuosoMockContext };","map":{"version":3,"names":["React","ReactDOM","PUBLISH","SUBSCRIBE","RESET","VALUE","compose","a","b","arg","thrush","proc","curry2to1","arg1","arg2","curry1to0","tap","tup","_len","arguments","length","args","Array","_key","call","always","value","joinProc","_len2","procs","_key2","map","isDefined","noop","subscribe","emitter","subscription","publish","publisher","reset","getValue","depot","connect","handleNext","unsub","stream","subscriptions","action","splice","push","indexOf","slice","forEach","Error","statefulStream","initial","innerSubject","eventHandler","currentSubscription","cleanup","streamFromEmitter","stream2","statefulStreamFromEmitter","combineOperators","_len3","operators","_key3","subscriber","reduceRight","pipe","source","_len4","_key4","project","defaultComparator","previous","next","distinctUntilChanged","comparator","undefined","current","done","filter","predicate","mapTo","scan","scanner","skip","times","throttleTime","interval","currentValue","timeout","setTimeout","debounceTime","clearTimeout","withLatestFrom","_len5","sources","_key5","values","called","pendingCall","allCalled","Math","pow","index","bit","prevCalled","call2","concat","merge","_len6","_key6","duc","combineLatest","_len7","emitters","_key7","system","constructor","dependencies","singleton","id","Symbol","init","systemSpec","singletons","Map","_init","_ref","id2","has","get","system2","e","set","omit","keys","obj","result","idx","len","prop","hasOwnProperty","useIsomorphicLayoutEffect$2","document","useLayoutEffect","useEffect","systemToComponent","map2","Root","requiredPropNames","Object","required","optionalPropNames","optional","methodNames","methods","eventNames","events","Context","createContext","applyPropsToSystem","props","requiredPropName","optionalPropName","buildMethods","reduce","acc","methodName","buildEventHandlers","handlers","eventName","Component","forwardRef","propsWithChildren","ref","children","useState","system22","useImperativeHandle","createElement","Provider","usePublisher2","key","useCallback","useContext","useEmitterValue2","setValue","useEmitter2","callback","context","usePublisher","useEmitterValue","useEmitter","useIsomorphicLayoutEffect","useIsomorphicLayoutEffect$1","LogLevel","LogLevel2","CONSOLE_METHOD_MAP","getGlobalThis","globalThis","window","loggerSystem","logLevel","log","label","message","level","_a","currentLevel","console","useSizeWithElRef","enabled","useRef","callbackRef","_el","ResizeObserver","observer","useMemo","entries","element","target","offsetParent","elRef","observe","unobserve","useSize","useChangedListContentsSizes","itemSize","scrollContainerStateCallback","gap","customScrollParent","memoedCallback","el","ranges","getChangedChildSizes","scrollableElement","parentElement","dataset","windowScrolling","lastElementChild","scrollTop","pageYOffset","documentElement","scrollHeight","viewportHeight","offsetHeight","innerHeight","max","resolveGapValue$1","getComputedStyle","rowGap","field","results","i","child","item","parseInt","knownSize","parseFloat","size","ERROR","lastResult","endIndex","startIndex","property","endsWith","WARN","correctItemSize","dimension","round","getBoundingClientRect","approximatelyEqual","num1","num2","abs","useScrollTop","smoothScrollTargetReached","scrollerElement","scrollerRefCallback","scrollerRef","scrollTopTarget","timeoutRef","handler","ev","windowScroll","suppressFlushSync","flushSync","localRef","addEventListener","passive","removeEventListener","scrollToCallback","location","scrollerElement2","isSmooth","behavior","maxScrollTop","top","ceil","min","scrollTo","scrollByCallback","scrollBy","domIOSystem","scrollContainerState","deviation","statefulScrollTop","headerHeight","fixedHeaderHeight","fixedFooterHeight","footerHeight","scrollingInProgress","_ref2","scrollTop2","_ref3","scrollHeight2","NIL_NODE","lvl","newAANode","k","v","l","r","empty","node","newTree","remove","lastKey","lastValue","last","adjust","clone","deleteLast","find","findMaxKeyValue","Infinity","Number","insert","rebalance","walkWithin","start","end","walk","isSingle","split","skew","rl","rlvl","rangesWithin","adjustedStart","toRanges","arrayToRanges","items","parser","nextIndex","nextValue","nodes","_ref4","findIndexOfClosestSmallerOrEqual","floor","match","join","findClosestSmallerOrEqual","findRange","startValue","endValue","recalcSystem","recalcInProgress","rangeIncludes","refRange","range","affectedGroupCount","offset","groupIndices","recognizedOffsetItems","groupIndex","offsetIsExact","insertRanges","sizeTree","syncStart","overlappingRanges","some","firstPassDone","shouldInsert","rangeStart","rangeEnd","rangeValue","initialSizeState","offsetTree","groupOffsetTree","lastIndex","lastOffset","lastSize","indexComparator","_ref5","itemIndex","offsetComparator","_ref6","itemOffset","offsetPointParser","point","rangesWithinOffsets","tree","startOffset","endOffset","minStartIndex","createOffsetTree","prevOffsetTree","prevIndex","prevSize","prevOffset","offsetInfo","kv","startIndex2","indexOffset","aOffset","sizeStateReducer","state","_ref7","DEBUG","newSizeTree","groupSize","newOffsetTree","offsetOf","itemCount","isGroupLocation","originalIndexFromLocation","sizes","numericIndex","originalIndexFromItemIndex","hasGroups","groupOffset","sizeTreeToRanges","_ref8","sizeArray","nextSize","SIZE_MAP","offsetWidth","sizeSystem","_ref9","sizeRanges","totalCount","statefulTotalCount","unshiftWith","shiftWith","firstItemIndex","fixedItemSize","defaultItemSize","data","prevGroupIndices","prev","curr","_ref10","indexes","_ref11","groupIndices2","sizes2","gap2","_ref12","totalCount2","_ref13","trackItemSizes","listRefresh","_ref14","_ref15","oldSizes","_","newSizes","changed","diff","val","prevGroupIndicesValue","_ref16","log2","beforeUnshiftWith","_ref17","unshiftWith2","groupedMode","initialRanges","defaultSize","firstGroupSize","prependedGroupItemsCount","theGroupIndex","groupItemCount","sizeTreeKV","firstGroupIsExpanded","shift","_ref18","_ref19","shiftWithOffset","_ref20","shiftWith2","newFirstItemIndex","_ref21","removedItemsCount","_ref22","aGroupIsShrunk","nextItemSize","_ref23","SUPPORTS_SCROLL_TO_OPTIONS","style","normalizeIndexLocation","align","scrollToIndexSystem","_ref24","scrollToIndex","topListHeight","unsubscribeNextListRefresh","cleartTimeoutRef","unsubscribeListRefresh","_ref25","viewportHeight2","topListHeight2","headerHeight2","footerHeight2","fixedHeaderHeight2","fixedFooterHeight2","normalLocation","retry","listChanged","watchChangesFor","limit","UP","DOWN","NONE$1","INITIAL_BOTTOM_STATE","atBottom","notAtBottomBecause","offsetBottom","DEFAULT_AT_TOP_THRESHOLD","stateFlagsSystem","_ref26","isAtBottom","isAtTop","atBottomStateChange","atTopStateChange","atBottomThreshold","atTopThreshold","isScrolling","isScrollingBy","_ref27","atTopThreshold2","atBottomState","_ref28","_headerHeight","_footerHeight","atBottomThreshold2","isAtBottom2","atBottomBecause","scrollTopDelta","lastJumpDueToItemResize","_ref29","jump","scrollDirection","_ref30","direction","prevScrollTop","scrollVelocity","_ref31","isScrolling2","_ref32","_ref33","_ref34","propsReadySystem","_ref35","propsReady","didMount","ready","getInitialTopMostItemIndexNumber","skipFrames","frameCount","requestAnimationFrame","initialTopMostItemIndexSystem","_ref36","scrolledToInitialItem","initialTopMostItemIndex","scrollScheduled","_ref37","_ref38","didMount2","scrolledToInitialItem2","defaultItemSize2","scrollScheduled2","_ref39","initialTopMostItemIndex2","normalizeFollowOutput","follow","behaviorFromFollowOutput","followOutputSystem","_ref40","followOutput","autoscrollToBottom","pendingScrollHandle","scrollToBottom","followOutputBehavior","_ref41","followOutput2","scrollingInProgress2","shouldFollow","_ref42","_ref43","trapNextSizeIncrease","cancel","_ref44","_ref45","_ref46","refreshed","_ref47","_ref48","_ref49","groupCountsToIndicesAndCount","counts","groupCount","groupedListSystem","_ref50","groupCounts","topItemsIndexes","groupIndicesAndCount","_ref51","_ref52","tupleComparator","rangeComparator","TOP","BOTTOM","NONE","getOverscan","overscan","main","reverse","getViewportIncrease","sizeRangeSystem","_ref53","listBoundary","increaseViewportBy","visibleRange","_ref54","listTop","listBottom","overscan2","deviation2","increaseViewportBy2","stickyHeaderHeight","headerVisible","topViewportAddition","bottomViewportAddition","probeItemSet","EMPTY_LIST_STATE","topItems","offsetTop","bottom","transposeItems","originalIndex","transposedItems","groupRanges","currentRange","currentGroupIndex","transposedItem","type","buildListState","lastItem","total","height","listStateSystem","_ref55","groupedListSystem2","rangeTopListHeight","stateFlags","itemsRendered","listState","_ref56","mount","recalcInProgress2","data2","dataChangeInProgress","_ref57","topItemsIndexes2","firstItemIndex2","sizesValue","rangeStartIndex","rangeEndIndex","offsetPointRanges","maxIndex","endReached","_ref58","_ref59","_ref60","_ref61","count","startReached","_ref62","_ref63","rangeChanged","_ref64","_ref65","initialItemCountSystem","_ref66","initialItemCount","_ref67","_ref68","includedGroupsCount","adjustedCount","from","scrollSeekSystem","_ref69","isSeeking","scrollSeekConfiguration","_ref70","config","_ref71","speed","isSeeking2","exit","enter","_ref72","velocity","change","scrollSeekRangeChanged","topItemCountSystem","_ref73","topItemCount","totalListHeightSystem","_ref74","totalListHeightChanged","totalListHeight","_ref75","listState2","simpleMemoize","func","isMobileSafari","test","navigator","userAgent","upwardScrollFixSystem","_ref76","deviationOffset","_ref77","_ref78","prevItems","prevTotalCount","prevTotalHeight","lastJumpDueToItemResize2","totalHeight","newDev","atStart","_ref79","amount","_ref80","scrollDirection2","_ref81","scrollByWith","_ref82","deviationAmount","_ref83","is","recalc","_ref84","_ref85","getItemOffset","defaultGroupSize","initialScrollTopSystem","_ref86","initialScrollTop","_ref87","_ref88","alignToBottomSystem","_ref89","alignToBottom","paddingTopAddition","_ref90","_ref91","totalListHeight2","windowScrollerSystem","_ref92","windowScrollContainerState","windowViewportRect","windowScrollTo","useWindowScroll","_ref93","windowScrollTop","_ref94","scrollTo2","defaultCalculateViewLocation","_ref95","itemTop","itemTop2","itemBottom","viewportTop","viewportBottom","locationParams","rest","scrollIntoViewSystem","_ref96","scrollIntoView","_ref97","viewLocation","calculateViewLocation","actualIndex","stateLoadSystem","_ref98","getState","restoreStateFrom","_ref99","locationFromSnapshot","_ref100","_ref101","snapshot","featureGroup1System","_ref102","sizeRange","scrollSeek","initialScrollTopSystem2","windowScroller","logger","listSystem","_ref103","domIO","stateLoad","flags","featureGroup1","visibleHeight","fixedItemHeight","defaultItemHeight","WEBKIT_STICKY","STICKY","positionStickyCssValue","position","useWindowViewportRectRef","viewportInfo","calculateInfo","rect","visibleWidth","width","customScrollParentRect","deltaTop","scrollAndResizeEventHandler","VirtuosoMockContext","VirtuosoGridMockContext","identity","listComponentPropsSystem","itemContent","groupContent","components","computeItemKey","headerFooterTag","distinctProp","propName","defaultValue","components2","FooterComponent","HeaderComponent","TopItemListComponent","ListComponent","ItemComponent","GroupComponent","ScrollerComponent","EmptyPlaceholder","ScrollSeekPlaceholder","combinedSystem$2","_ref104","listSystem2","propsSystem","DefaultScrollSeekPlaceholder$1","_ref105","GROUP_STYLE","zIndex","overflowAnchor","ITEM_STYLE","Items$1","memo","VirtuosoItems","_ref106","showTopList","useEmitterValue$2","usePublisher$2","windowScrollContainerStateCallback","_scrollContainerStateCallback","listGap","setDeviation","useEmitter$2","hasGroups2","containerStyle","boxSizing","paddingTop","paddingBottom","marginTop","visibility","contextPropIfNotDomElement","scrollerStyle","outline","overflowY","WebkitOverflowScrolling","viewportStyle","topItemListStyle","Header$1","VirtuosoHeader","Header2","Footer$1","VirtuosoFooter","Footer2","buildScroller","_ref107","Scroller2","VirtuosoScroller","_ref108","tabIndex","buildWindowScroller","_ref109","VirtuosoWindowScroller","_ref110","Viewport$2","_ref111","ctx","viewportRef","itemHeight","WindowViewport$2","_ref112","TopItemListContainer","_ref113","TopItemList","ListRoot","VirtuosoRoot","TheScroller","WindowScroller$2","Scroller$2","TheViewport","List","Virtuoso","GroupedVirtuoso","INITIAL_GRID_STATE","itemWidth","PROBE_GRID_STATE","buildProbeGridState","buildItems","gapComparator","column","row","dimensionComparator","gridSystem","_ref114","gridState","viewportDimensions","itemDimensions","_ref115","_ref116","_ref117","viewport","columnGap","viewportWidth","perRow","itemsPerRow","gridLayout","rowCount","_ref118","_ref119","viewportDimensions2","hasScrolled","_ref120","hasScrolled2","_ref121","_ref122","_ref123","_ref124","_ref125","_ref126","_ref127","gridState2","gridComponentPropsSystem","itemClassName","listClassName","combinedSystem$1","_ref128","gridSystem2","gridComponentPropsSystem2","GridItems","GridItems2","useEmitterValue$1","scrollHeightCallback","usePublisher$1","gridGap","listRef","firstItem","firstChild","resolveGapValue","className","Header","VirtuosoHeader2","Footer","VirtuosoGridFooter","Viewport$1","_ref129","WindowViewport$1","_ref130","GridRoot","GridRoot2","_ref131","WindowScroller$1","Scroller$1","Grid","useEmitter$1","VirtuosoGrid","tableComponentPropsSystem","fixedHeaderContent","fixedFooterContent","TableComponent","TableHeadComponent","TableFooterComponent","TableBodyComponent","TableRowComponent","FillerRow","combinedSystem","_ref132","DefaultScrollSeekPlaceholder","_ref133","DefaultFillerRow","_ref134","padding","border","Items","VirtuosoItems2","paddingTopEl","paddingBottomEl","Viewport","_ref135","WindowViewport","_ref136","TableRoot","TableVirtuosoRoot","theadRef","tfootRef","WindowScroller","Scroller","TheTable","TheTHead","TheTFoot","theHead","theFoot","borderSpacing","Table","TableVirtuoso"],"sources":["D:/MAS_project/help_desk/node_modules/react-virtuoso/dist/index.mjs"],"sourcesContent":["import React from \"react\";\nimport ReactDOM from \"react-dom\";\nconst PUBLISH = 0;\nconst SUBSCRIBE = 1;\nconst RESET = 2;\nconst VALUE = 4;\nfunction compose(a, b) {\n  return (arg) => a(b(arg));\n}\nfunction thrush(arg, proc) {\n  return proc(arg);\n}\nfunction curry2to1(proc, arg1) {\n  return (arg2) => proc(arg1, arg2);\n}\nfunction curry1to0(proc, arg) {\n  return () => proc(arg);\n}\nfunction tap(arg, proc) {\n  proc(arg);\n  return arg;\n}\nfunction tup(...args) {\n  return args;\n}\nfunction call(proc) {\n  proc();\n}\nfunction always(value) {\n  return () => value;\n}\nfunction joinProc(...procs) {\n  return () => {\n    procs.map(call);\n  };\n}\nfunction isDefined(arg) {\n  return arg !== void 0;\n}\nfunction noop() {\n}\nfunction subscribe(emitter, subscription) {\n  return emitter(SUBSCRIBE, subscription);\n}\nfunction publish(publisher, value) {\n  publisher(PUBLISH, value);\n}\nfunction reset(emitter) {\n  emitter(RESET);\n}\nfunction getValue(depot) {\n  return depot(VALUE);\n}\nfunction connect(emitter, publisher) {\n  return subscribe(emitter, curry2to1(publisher, PUBLISH));\n}\nfunction handleNext(emitter, subscription) {\n  const unsub = emitter(SUBSCRIBE, (value) => {\n    unsub();\n    subscription(value);\n  });\n  return unsub;\n}\nfunction stream() {\n  const subscriptions = [];\n  return (action, arg) => {\n    switch (action) {\n      case RESET:\n        subscriptions.splice(0, subscriptions.length);\n        return;\n      case SUBSCRIBE:\n        subscriptions.push(arg);\n        return () => {\n          const indexOf = subscriptions.indexOf(arg);\n          if (indexOf > -1) {\n            subscriptions.splice(indexOf, 1);\n          }\n        };\n      case PUBLISH:\n        subscriptions.slice().forEach((subscription) => {\n          subscription(arg);\n        });\n        return;\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction statefulStream(initial) {\n  let value = initial;\n  const innerSubject = stream();\n  return (action, arg) => {\n    switch (action) {\n      case SUBSCRIBE:\n        const subscription = arg;\n        subscription(value);\n        break;\n      case PUBLISH:\n        value = arg;\n        break;\n      case VALUE:\n        return value;\n    }\n    return innerSubject(action, arg);\n  };\n}\nfunction eventHandler(emitter) {\n  let unsub;\n  let currentSubscription;\n  const cleanup = () => unsub && unsub();\n  return function(action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (subscription) {\n          if (currentSubscription === subscription) {\n            return;\n          }\n          cleanup();\n          currentSubscription = subscription;\n          unsub = subscribe(emitter, subscription);\n          return unsub;\n        } else {\n          cleanup();\n          return noop;\n        }\n      case RESET:\n        cleanup();\n        currentSubscription = null;\n        return;\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction streamFromEmitter(emitter) {\n  return tap(stream(), (stream2) => connect(emitter, stream2));\n}\nfunction statefulStreamFromEmitter(emitter, initial) {\n  return tap(statefulStream(initial), (stream2) => connect(emitter, stream2));\n}\nfunction combineOperators(...operators) {\n  return (subscriber) => {\n    return operators.reduceRight(thrush, subscriber);\n  };\n}\nfunction pipe(source, ...operators) {\n  const project = combineOperators(...operators);\n  return (action, subscription) => {\n    switch (action) {\n      case SUBSCRIBE:\n        return subscribe(source, project(subscription));\n      case RESET:\n        reset(source);\n        return;\n    }\n  };\n}\nfunction defaultComparator(previous, next) {\n  return previous === next;\n}\nfunction distinctUntilChanged(comparator = defaultComparator) {\n  let current;\n  return (done) => (next) => {\n    if (!comparator(current, next)) {\n      current = next;\n      done(next);\n    }\n  };\n}\nfunction filter(predicate) {\n  return (done) => (value) => {\n    predicate(value) && done(value);\n  };\n}\nfunction map(project) {\n  return (done) => compose(done, project);\n}\nfunction mapTo(value) {\n  return (done) => () => done(value);\n}\nfunction scan(scanner, initial) {\n  return (done) => (value) => done(initial = scanner(initial, value));\n}\nfunction skip(times) {\n  return (done) => (value) => {\n    times > 0 ? times-- : done(value);\n  };\n}\nfunction throttleTime(interval) {\n  let currentValue = null;\n  let timeout;\n  return (done) => (value) => {\n    currentValue = value;\n    if (timeout) {\n      return;\n    }\n    timeout = setTimeout(() => {\n      timeout = void 0;\n      done(currentValue);\n    }, interval);\n  };\n}\nfunction debounceTime(interval) {\n  let currentValue;\n  let timeout;\n  return (done) => (value) => {\n    currentValue = value;\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(() => {\n      done(currentValue);\n    }, interval);\n  };\n}\nfunction withLatestFrom(...sources) {\n  const values = new Array(sources.length);\n  let called = 0;\n  let pendingCall = null;\n  const allCalled = Math.pow(2, sources.length) - 1;\n  sources.forEach((source, index) => {\n    const bit = Math.pow(2, index);\n    subscribe(source, (value) => {\n      const prevCalled = called;\n      called = called | bit;\n      values[index] = value;\n      if (prevCalled !== allCalled && called === allCalled && pendingCall) {\n        pendingCall();\n        pendingCall = null;\n      }\n    });\n  });\n  return (done) => (value) => {\n    const call2 = () => done([value].concat(values));\n    if (called === allCalled) {\n      call2();\n    } else {\n      pendingCall = call2;\n    }\n  };\n}\nfunction merge(...sources) {\n  return function(action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        return joinProc(...sources.map((source) => subscribe(source, subscription)));\n      case RESET:\n        return;\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction duc(source, comparator = defaultComparator) {\n  return pipe(source, distinctUntilChanged(comparator));\n}\nfunction combineLatest(...emitters) {\n  const innerSubject = stream();\n  const values = new Array(emitters.length);\n  let called = 0;\n  const allCalled = Math.pow(2, emitters.length) - 1;\n  emitters.forEach((source, index) => {\n    const bit = Math.pow(2, index);\n    subscribe(source, (value) => {\n      values[index] = value;\n      called = called | bit;\n      if (called === allCalled) {\n        publish(innerSubject, values);\n      }\n    });\n  });\n  return function(action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (called === allCalled) {\n          subscription(values);\n        }\n        return subscribe(innerSubject, subscription);\n      case RESET:\n        return reset(innerSubject);\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction system(constructor, dependencies = [], { singleton } = { singleton: true }) {\n  return {\n    id: id(),\n    constructor,\n    dependencies,\n    singleton\n  };\n}\nconst id = () => Symbol();\nfunction init(systemSpec) {\n  const singletons = /* @__PURE__ */ new Map();\n  const _init = ({ id: id2, constructor, dependencies, singleton }) => {\n    if (singleton && singletons.has(id2)) {\n      return singletons.get(id2);\n    }\n    const system2 = constructor(dependencies.map((e) => _init(e)));\n    if (singleton) {\n      singletons.set(id2, system2);\n    }\n    return system2;\n  };\n  return _init(systemSpec);\n}\nfunction omit(keys, obj) {\n  const result = {};\n  const index = {};\n  let idx = 0;\n  const len = keys.length;\n  while (idx < len) {\n    index[keys[idx]] = 1;\n    idx += 1;\n  }\n  for (const prop in obj) {\n    if (!index.hasOwnProperty(prop)) {\n      result[prop] = obj[prop];\n    }\n  }\n  return result;\n}\nconst useIsomorphicLayoutEffect$2 = typeof document !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\nfunction systemToComponent(systemSpec, map2, Root) {\n  const requiredPropNames = Object.keys(map2.required || {});\n  const optionalPropNames = Object.keys(map2.optional || {});\n  const methodNames = Object.keys(map2.methods || {});\n  const eventNames = Object.keys(map2.events || {});\n  const Context = React.createContext({});\n  function applyPropsToSystem(system2, props) {\n    if (system2[\"propsReady\"]) {\n      publish(system2[\"propsReady\"], false);\n    }\n    for (const requiredPropName of requiredPropNames) {\n      const stream2 = system2[map2.required[requiredPropName]];\n      publish(stream2, props[requiredPropName]);\n    }\n    for (const optionalPropName of optionalPropNames) {\n      if (optionalPropName in props) {\n        const stream2 = system2[map2.optional[optionalPropName]];\n        publish(stream2, props[optionalPropName]);\n      }\n    }\n    if (system2[\"propsReady\"]) {\n      publish(system2[\"propsReady\"], true);\n    }\n  }\n  function buildMethods(system2) {\n    return methodNames.reduce((acc, methodName) => {\n      acc[methodName] = (value) => {\n        const stream2 = system2[map2.methods[methodName]];\n        publish(stream2, value);\n      };\n      return acc;\n    }, {});\n  }\n  function buildEventHandlers(system2) {\n    return eventNames.reduce((handlers, eventName) => {\n      handlers[eventName] = eventHandler(system2[map2.events[eventName]]);\n      return handlers;\n    }, {});\n  }\n  const Component = React.forwardRef((propsWithChildren, ref) => {\n    const { children, ...props } = propsWithChildren;\n    const [system2] = React.useState(() => {\n      return tap(init(systemSpec), (system22) => applyPropsToSystem(system22, props));\n    });\n    const [handlers] = React.useState(curry1to0(buildEventHandlers, system2));\n    useIsomorphicLayoutEffect$2(() => {\n      for (const eventName of eventNames) {\n        if (eventName in props) {\n          subscribe(handlers[eventName], props[eventName]);\n        }\n      }\n      return () => {\n        Object.values(handlers).map(reset);\n      };\n    }, [props, handlers, system2]);\n    useIsomorphicLayoutEffect$2(() => {\n      applyPropsToSystem(system2, props);\n    });\n    React.useImperativeHandle(ref, always(buildMethods(system2)));\n    return React.createElement(\n      Context.Provider,\n      { value: system2 },\n      Root ? React.createElement(\n        Root,\n        omit([...requiredPropNames, ...optionalPropNames, ...eventNames], props),\n        children\n      ) : children\n    );\n  });\n  const usePublisher2 = (key) => {\n    return React.useCallback(curry2to1(publish, React.useContext(Context)[key]), [key]);\n  };\n  const useEmitterValue2 = (key) => {\n    const system2 = React.useContext(Context);\n    const source = system2[key];\n    const [value, setValue] = React.useState(curry1to0(getValue, source));\n    useIsomorphicLayoutEffect$2(\n      () => subscribe(source, (next) => {\n        if (next !== value) {\n          setValue(always(next));\n        }\n      }),\n      [source, value]\n    );\n    return value;\n  };\n  const useEmitter2 = (key, callback) => {\n    const context = React.useContext(Context);\n    const source = context[key];\n    useIsomorphicLayoutEffect$2(() => subscribe(source, callback), [callback, source]);\n  };\n  return {\n    Component,\n    usePublisher: usePublisher2,\n    useEmitterValue: useEmitterValue2,\n    useEmitter: useEmitter2\n  };\n}\nconst useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\nconst useIsomorphicLayoutEffect$1 = useIsomorphicLayoutEffect;\nvar LogLevel = /* @__PURE__ */ ((LogLevel2) => {\n  LogLevel2[LogLevel2[\"DEBUG\"] = 0] = \"DEBUG\";\n  LogLevel2[LogLevel2[\"INFO\"] = 1] = \"INFO\";\n  LogLevel2[LogLevel2[\"WARN\"] = 2] = \"WARN\";\n  LogLevel2[LogLevel2[\"ERROR\"] = 3] = \"ERROR\";\n  return LogLevel2;\n})(LogLevel || {});\nconst CONSOLE_METHOD_MAP = {\n  [\n    0\n    /* DEBUG */\n  ]: \"debug\",\n  [\n    1\n    /* INFO */\n  ]: \"log\",\n  [\n    2\n    /* WARN */\n  ]: \"warn\",\n  [\n    3\n    /* ERROR */\n  ]: \"error\"\n};\nconst getGlobalThis = () => typeof globalThis === \"undefined\" ? window : globalThis;\nconst loggerSystem = system(\n  () => {\n    const logLevel = statefulStream(\n      3\n      /* ERROR */\n    );\n    const log = statefulStream((label, message, level = 1) => {\n      var _a;\n      const currentLevel = (_a = getGlobalThis()[\"VIRTUOSO_LOG_LEVEL\"]) != null ? _a : getValue(logLevel);\n      if (level >= currentLevel) {\n        console[CONSOLE_METHOD_MAP[level]](\n          \"%creact-virtuoso: %c%s %o\",\n          \"color: #0253b3; font-weight: bold\",\n          \"color: initial\",\n          label,\n          message\n        );\n      }\n    });\n    return {\n      log,\n      logLevel\n    };\n  },\n  [],\n  { singleton: true }\n);\nfunction useSizeWithElRef(callback, enabled = true) {\n  const ref = React.useRef(null);\n  let callbackRef = (_el) => {\n  };\n  if (typeof ResizeObserver !== \"undefined\") {\n    const observer = React.useMemo(() => {\n      return new ResizeObserver((entries) => {\n        const element = entries[0].target;\n        if (element.offsetParent !== null) {\n          callback(element);\n        }\n      });\n    }, [callback]);\n    callbackRef = (elRef) => {\n      if (elRef && enabled) {\n        observer.observe(elRef);\n        ref.current = elRef;\n      } else {\n        if (ref.current) {\n          observer.unobserve(ref.current);\n        }\n        ref.current = null;\n      }\n    };\n  }\n  return { ref, callbackRef };\n}\nfunction useSize(callback, enabled = true) {\n  return useSizeWithElRef(callback, enabled).callbackRef;\n}\nfunction useChangedListContentsSizes(callback, itemSize, enabled, scrollContainerStateCallback, log, gap, customScrollParent) {\n  const memoedCallback = React.useCallback(\n    (el) => {\n      const ranges = getChangedChildSizes(el.children, itemSize, \"offsetHeight\", log);\n      let scrollableElement = el.parentElement;\n      while (!scrollableElement.dataset[\"virtuosoScroller\"]) {\n        scrollableElement = scrollableElement.parentElement;\n      }\n      const windowScrolling = scrollableElement.lastElementChild.dataset[\"viewportType\"] === \"window\";\n      const scrollTop = customScrollParent ? customScrollParent.scrollTop : windowScrolling ? window.pageYOffset || document.documentElement.scrollTop : scrollableElement.scrollTop;\n      const scrollHeight = customScrollParent ? customScrollParent.scrollHeight : windowScrolling ? document.documentElement.scrollHeight : scrollableElement.scrollHeight;\n      const viewportHeight = customScrollParent ? customScrollParent.offsetHeight : windowScrolling ? window.innerHeight : scrollableElement.offsetHeight;\n      scrollContainerStateCallback({\n        scrollTop: Math.max(scrollTop, 0),\n        scrollHeight,\n        viewportHeight\n      });\n      gap == null ? void 0 : gap(resolveGapValue$1(\"row-gap\", getComputedStyle(el).rowGap, log));\n      if (ranges !== null) {\n        callback(ranges);\n      }\n    },\n    [callback, itemSize, log, gap, customScrollParent, scrollContainerStateCallback]\n  );\n  return useSizeWithElRef(memoedCallback, enabled);\n}\nfunction getChangedChildSizes(children, itemSize, field, log) {\n  const length = children.length;\n  if (length === 0) {\n    return null;\n  }\n  const results = [];\n  for (let i = 0; i < length; i++) {\n    const child = children.item(i);\n    if (!child || child.dataset.index === void 0) {\n      continue;\n    }\n    const index = parseInt(child.dataset.index);\n    const knownSize = parseFloat(child.dataset.knownSize);\n    const size = itemSize(child, field);\n    if (size === 0) {\n      log(\"Zero-sized element, this should not happen\", { child }, LogLevel.ERROR);\n    }\n    if (size === knownSize) {\n      continue;\n    }\n    const lastResult = results[results.length - 1];\n    if (results.length === 0 || lastResult.size !== size || lastResult.endIndex !== index - 1) {\n      results.push({ startIndex: index, endIndex: index, size });\n    } else {\n      results[results.length - 1].endIndex++;\n    }\n  }\n  return results;\n}\nfunction resolveGapValue$1(property, value, log) {\n  if (value !== \"normal\" && !(value == null ? void 0 : value.endsWith(\"px\"))) {\n    log(`${property} was not resolved to pixel value correctly`, value, LogLevel.WARN);\n  }\n  if (value === \"normal\") {\n    return 0;\n  }\n  return parseInt(value != null ? value : \"0\", 10);\n}\nfunction correctItemSize(el, dimension) {\n  return Math.round(el.getBoundingClientRect()[dimension]);\n}\nfunction approximatelyEqual(num1, num2) {\n  return Math.abs(num1 - num2) < 1.01;\n}\nfunction useScrollTop(scrollContainerStateCallback, smoothScrollTargetReached, scrollerElement, scrollerRefCallback = noop, customScrollParent) {\n  const scrollerRef = React.useRef(null);\n  const scrollTopTarget = React.useRef(null);\n  const timeoutRef = React.useRef(null);\n  const handler = React.useCallback(\n    (ev) => {\n      const el = ev.target;\n      const windowScroll = el === window || el === document;\n      const scrollTop = windowScroll ? window.pageYOffset || document.documentElement.scrollTop : el.scrollTop;\n      const scrollHeight = windowScroll ? document.documentElement.scrollHeight : el.scrollHeight;\n      const viewportHeight = windowScroll ? window.innerHeight : el.offsetHeight;\n      const call2 = () => {\n        scrollContainerStateCallback({\n          scrollTop: Math.max(scrollTop, 0),\n          scrollHeight,\n          viewportHeight\n        });\n      };\n      if (ev.suppressFlushSync) {\n        call2();\n      } else {\n        ReactDOM.flushSync(call2);\n      }\n      if (scrollTopTarget.current !== null) {\n        if (scrollTop === scrollTopTarget.current || scrollTop <= 0 || scrollTop === scrollHeight - viewportHeight) {\n          scrollTopTarget.current = null;\n          smoothScrollTargetReached(true);\n          if (timeoutRef.current) {\n            clearTimeout(timeoutRef.current);\n            timeoutRef.current = null;\n          }\n        }\n      }\n    },\n    [scrollContainerStateCallback, smoothScrollTargetReached]\n  );\n  React.useEffect(() => {\n    const localRef = customScrollParent ? customScrollParent : scrollerRef.current;\n    scrollerRefCallback(customScrollParent ? customScrollParent : scrollerRef.current);\n    handler({ target: localRef, suppressFlushSync: true });\n    localRef.addEventListener(\"scroll\", handler, { passive: true });\n    return () => {\n      scrollerRefCallback(null);\n      localRef.removeEventListener(\"scroll\", handler);\n    };\n  }, [scrollerRef, handler, scrollerElement, scrollerRefCallback, customScrollParent]);\n  function scrollToCallback(location) {\n    const scrollerElement2 = scrollerRef.current;\n    if (!scrollerElement2 || \"offsetHeight\" in scrollerElement2 && scrollerElement2.offsetHeight === 0) {\n      return;\n    }\n    const isSmooth = location.behavior === \"smooth\";\n    let offsetHeight;\n    let scrollHeight;\n    let scrollTop;\n    if (scrollerElement2 === window) {\n      scrollHeight = Math.max(correctItemSize(document.documentElement, \"height\"), document.documentElement.scrollHeight);\n      offsetHeight = window.innerHeight;\n      scrollTop = document.documentElement.scrollTop;\n    } else {\n      scrollHeight = scrollerElement2.scrollHeight;\n      offsetHeight = correctItemSize(scrollerElement2, \"height\");\n      scrollTop = scrollerElement2.scrollTop;\n    }\n    const maxScrollTop = scrollHeight - offsetHeight;\n    location.top = Math.ceil(Math.max(Math.min(maxScrollTop, location.top), 0));\n    if (approximatelyEqual(offsetHeight, scrollHeight) || location.top === scrollTop) {\n      scrollContainerStateCallback({ scrollTop, scrollHeight, viewportHeight: offsetHeight });\n      if (isSmooth) {\n        smoothScrollTargetReached(true);\n      }\n      return;\n    }\n    if (isSmooth) {\n      scrollTopTarget.current = location.top;\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n      timeoutRef.current = setTimeout(() => {\n        timeoutRef.current = null;\n        scrollTopTarget.current = null;\n        smoothScrollTargetReached(true);\n      }, 1e3);\n    } else {\n      scrollTopTarget.current = null;\n    }\n    scrollerElement2.scrollTo(location);\n  }\n  function scrollByCallback(location) {\n    scrollerRef.current.scrollBy(location);\n  }\n  return { scrollerRef, scrollByCallback, scrollToCallback };\n}\nconst domIOSystem = system(\n  () => {\n    const scrollContainerState = stream();\n    const scrollTop = stream();\n    const deviation = statefulStream(0);\n    const smoothScrollTargetReached = stream();\n    const statefulScrollTop = statefulStream(0);\n    const viewportHeight = stream();\n    const scrollHeight = stream();\n    const headerHeight = statefulStream(0);\n    const fixedHeaderHeight = statefulStream(0);\n    const fixedFooterHeight = statefulStream(0);\n    const footerHeight = statefulStream(0);\n    const scrollTo = stream();\n    const scrollBy = stream();\n    const scrollingInProgress = statefulStream(false);\n    connect(\n      pipe(\n        scrollContainerState,\n        map(({ scrollTop: scrollTop2 }) => scrollTop2)\n      ),\n      scrollTop\n    );\n    connect(\n      pipe(\n        scrollContainerState,\n        map(({ scrollHeight: scrollHeight2 }) => scrollHeight2)\n      ),\n      scrollHeight\n    );\n    connect(scrollTop, statefulScrollTop);\n    return {\n      // input\n      scrollContainerState,\n      scrollTop,\n      viewportHeight,\n      headerHeight,\n      fixedHeaderHeight,\n      fixedFooterHeight,\n      footerHeight,\n      scrollHeight,\n      smoothScrollTargetReached,\n      // signals\n      scrollTo,\n      scrollBy,\n      // state\n      statefulScrollTop,\n      deviation,\n      scrollingInProgress\n    };\n  },\n  [],\n  { singleton: true }\n);\nconst NIL_NODE = { lvl: 0 };\nfunction newAANode(k, v, lvl, l = NIL_NODE, r = NIL_NODE) {\n  return { k, v, lvl, l, r };\n}\nfunction empty(node) {\n  return node === NIL_NODE;\n}\nfunction newTree() {\n  return NIL_NODE;\n}\nfunction remove(node, key) {\n  if (empty(node))\n    return NIL_NODE;\n  const { k, l, r } = node;\n  if (key === k) {\n    if (empty(l)) {\n      return r;\n    } else if (empty(r)) {\n      return l;\n    } else {\n      const [lastKey, lastValue] = last(l);\n      return adjust(clone(node, { k: lastKey, v: lastValue, l: deleteLast(l) }));\n    }\n  } else if (key < k) {\n    return adjust(clone(node, { l: remove(l, key) }));\n  } else {\n    return adjust(clone(node, { r: remove(r, key) }));\n  }\n}\nfunction find(node, key) {\n  if (empty(node)) {\n    return;\n  }\n  if (key === node.k) {\n    return node.v;\n  } else if (key < node.k) {\n    return find(node.l, key);\n  } else {\n    return find(node.r, key);\n  }\n}\nfunction findMaxKeyValue(node, value, field = \"k\") {\n  if (empty(node)) {\n    return [-Infinity, void 0];\n  }\n  if (Number(node[field]) === value) {\n    return [node.k, node.v];\n  }\n  if (Number(node[field]) < value) {\n    const r = findMaxKeyValue(node.r, value, field);\n    if (r[0] === -Infinity) {\n      return [node.k, node.v];\n    } else {\n      return r;\n    }\n  }\n  return findMaxKeyValue(node.l, value, field);\n}\nfunction insert(node, k, v) {\n  if (empty(node)) {\n    return newAANode(k, v, 1);\n  }\n  if (k === node.k) {\n    return clone(node, { k, v });\n  } else if (k < node.k) {\n    return rebalance(clone(node, { l: insert(node.l, k, v) }));\n  } else {\n    return rebalance(clone(node, { r: insert(node.r, k, v) }));\n  }\n}\nfunction walkWithin(node, start, end) {\n  if (empty(node)) {\n    return [];\n  }\n  const { k, v, l, r } = node;\n  let result = [];\n  if (k > start) {\n    result = result.concat(walkWithin(l, start, end));\n  }\n  if (k >= start && k <= end) {\n    result.push({ k, v });\n  }\n  if (k <= end) {\n    result = result.concat(walkWithin(r, start, end));\n  }\n  return result;\n}\nfunction walk(node) {\n  if (empty(node)) {\n    return [];\n  }\n  return [...walk(node.l), { k: node.k, v: node.v }, ...walk(node.r)];\n}\nfunction last(node) {\n  return empty(node.r) ? [node.k, node.v] : last(node.r);\n}\nfunction deleteLast(node) {\n  return empty(node.r) ? node.l : adjust(clone(node, { r: deleteLast(node.r) }));\n}\nfunction clone(node, args) {\n  return newAANode(\n    args.k !== void 0 ? args.k : node.k,\n    args.v !== void 0 ? args.v : node.v,\n    args.lvl !== void 0 ? args.lvl : node.lvl,\n    args.l !== void 0 ? args.l : node.l,\n    args.r !== void 0 ? args.r : node.r\n  );\n}\nfunction isSingle(node) {\n  return empty(node) || node.lvl > node.r.lvl;\n}\nfunction rebalance(node) {\n  return split(skew(node));\n}\nfunction adjust(node) {\n  const { l, r, lvl } = node;\n  if (r.lvl >= lvl - 1 && l.lvl >= lvl - 1) {\n    return node;\n  } else if (lvl > r.lvl + 1) {\n    if (isSingle(l)) {\n      return skew(clone(node, { lvl: lvl - 1 }));\n    } else {\n      if (!empty(l) && !empty(l.r)) {\n        return clone(l.r, {\n          l: clone(l, { r: l.r.l }),\n          r: clone(node, {\n            l: l.r.r,\n            lvl: lvl - 1\n          }),\n          lvl\n        });\n      } else {\n        throw new Error(\"Unexpected empty nodes\");\n      }\n    }\n  } else {\n    if (isSingle(node)) {\n      return split(clone(node, { lvl: lvl - 1 }));\n    } else {\n      if (!empty(r) && !empty(r.l)) {\n        const rl = r.l;\n        const rlvl = isSingle(rl) ? r.lvl - 1 : r.lvl;\n        return clone(rl, {\n          l: clone(node, {\n            r: rl.l,\n            lvl: lvl - 1\n          }),\n          r: split(clone(r, { l: rl.r, lvl: rlvl })),\n          lvl: rl.lvl + 1\n        });\n      } else {\n        throw new Error(\"Unexpected empty nodes\");\n      }\n    }\n  }\n}\nfunction rangesWithin(node, startIndex, endIndex) {\n  if (empty(node)) {\n    return [];\n  }\n  const adjustedStart = findMaxKeyValue(node, startIndex)[0];\n  return toRanges(walkWithin(node, adjustedStart, endIndex));\n}\nfunction arrayToRanges(items, parser) {\n  const length = items.length;\n  if (length === 0) {\n    return [];\n  }\n  let { index: start, value } = parser(items[0]);\n  const result = [];\n  for (let i = 1; i < length; i++) {\n    const { index: nextIndex, value: nextValue } = parser(items[i]);\n    result.push({ start, end: nextIndex - 1, value });\n    start = nextIndex;\n    value = nextValue;\n  }\n  result.push({ start, end: Infinity, value });\n  return result;\n}\nfunction toRanges(nodes) {\n  return arrayToRanges(nodes, ({ k: index, v: value }) => ({ index, value }));\n}\nfunction split(node) {\n  const { r, lvl } = node;\n  return !empty(r) && !empty(r.r) && r.lvl === lvl && r.r.lvl === lvl ? clone(r, { l: clone(node, { r: r.l }), lvl: lvl + 1 }) : node;\n}\nfunction skew(node) {\n  const { l } = node;\n  return !empty(l) && l.lvl === node.lvl ? clone(l, { r: clone(node, { l: l.r }) }) : node;\n}\nfunction findIndexOfClosestSmallerOrEqual(items, value, comparator, start = 0) {\n  let end = items.length - 1;\n  while (start <= end) {\n    const index = Math.floor((start + end) / 2);\n    const item = items[index];\n    const match = comparator(item, value);\n    if (match === 0) {\n      return index;\n    }\n    if (match === -1) {\n      if (end - start < 2) {\n        return index - 1;\n      }\n      end = index - 1;\n    } else {\n      if (end === start) {\n        return index;\n      }\n      start = index + 1;\n    }\n  }\n  throw new Error(`Failed binary finding record in array - ${items.join(\",\")}, searched for ${value}`);\n}\nfunction findClosestSmallerOrEqual(items, value, comparator) {\n  return items[findIndexOfClosestSmallerOrEqual(items, value, comparator)];\n}\nfunction findRange(items, startValue, endValue, comparator) {\n  const startIndex = findIndexOfClosestSmallerOrEqual(items, startValue, comparator);\n  const endIndex = findIndexOfClosestSmallerOrEqual(items, endValue, comparator, startIndex);\n  return items.slice(startIndex, endIndex + 1);\n}\nconst recalcSystem = system(\n  () => {\n    const recalcInProgress = statefulStream(false);\n    return { recalcInProgress };\n  },\n  [],\n  { singleton: true }\n);\nfunction rangeIncludes(refRange) {\n  const { size, startIndex, endIndex } = refRange;\n  return (range) => {\n    return range.start === startIndex && (range.end === endIndex || range.end === Infinity) && range.value === size;\n  };\n}\nfunction affectedGroupCount(offset, groupIndices) {\n  let recognizedOffsetItems = 0;\n  let groupIndex = 0;\n  while (recognizedOffsetItems < offset) {\n    recognizedOffsetItems += groupIndices[groupIndex + 1] - groupIndices[groupIndex] - 1;\n    groupIndex++;\n  }\n  const offsetIsExact = recognizedOffsetItems === offset;\n  return groupIndex - (offsetIsExact ? 0 : 1);\n}\nfunction insertRanges(sizeTree, ranges) {\n  let syncStart = empty(sizeTree) ? 0 : Infinity;\n  for (const range of ranges) {\n    const { size, startIndex, endIndex } = range;\n    syncStart = Math.min(syncStart, startIndex);\n    if (empty(sizeTree)) {\n      sizeTree = insert(sizeTree, 0, size);\n      continue;\n    }\n    const overlappingRanges = rangesWithin(sizeTree, startIndex - 1, endIndex + 1);\n    if (overlappingRanges.some(rangeIncludes(range))) {\n      continue;\n    }\n    let firstPassDone = false;\n    let shouldInsert = false;\n    for (const { start: rangeStart, end: rangeEnd, value: rangeValue } of overlappingRanges) {\n      if (!firstPassDone) {\n        shouldInsert = rangeValue !== size;\n        firstPassDone = true;\n      } else {\n        if (endIndex >= rangeStart || size === rangeValue) {\n          sizeTree = remove(sizeTree, rangeStart);\n        }\n      }\n      if (rangeEnd > endIndex && endIndex >= rangeStart) {\n        if (rangeValue !== size) {\n          sizeTree = insert(sizeTree, endIndex + 1, rangeValue);\n        }\n      }\n    }\n    if (shouldInsert) {\n      sizeTree = insert(sizeTree, startIndex, size);\n    }\n  }\n  return [sizeTree, syncStart];\n}\nfunction initialSizeState() {\n  return {\n    offsetTree: [],\n    sizeTree: newTree(),\n    groupOffsetTree: newTree(),\n    lastIndex: 0,\n    lastOffset: 0,\n    lastSize: 0,\n    groupIndices: []\n  };\n}\nfunction indexComparator({ index: itemIndex }, index) {\n  return index === itemIndex ? 0 : index < itemIndex ? -1 : 1;\n}\nfunction offsetComparator({ offset: itemOffset }, offset) {\n  return offset === itemOffset ? 0 : offset < itemOffset ? -1 : 1;\n}\nfunction offsetPointParser(point) {\n  return { index: point.index, value: point };\n}\nfunction rangesWithinOffsets(tree, startOffset, endOffset, minStartIndex = 0) {\n  if (minStartIndex > 0) {\n    startOffset = Math.max(startOffset, findClosestSmallerOrEqual(tree, minStartIndex, indexComparator).offset);\n  }\n  return arrayToRanges(findRange(tree, startOffset, endOffset, offsetComparator), offsetPointParser);\n}\nfunction createOffsetTree(prevOffsetTree, syncStart, sizeTree, gap) {\n  let offsetTree = prevOffsetTree;\n  let prevIndex = 0;\n  let prevSize = 0;\n  let prevOffset = 0;\n  let startIndex = 0;\n  if (syncStart !== 0) {\n    startIndex = findIndexOfClosestSmallerOrEqual(offsetTree, syncStart - 1, indexComparator);\n    const offsetInfo = offsetTree[startIndex];\n    prevOffset = offsetInfo.offset;\n    const kv = findMaxKeyValue(sizeTree, syncStart - 1);\n    prevIndex = kv[0];\n    prevSize = kv[1];\n    if (offsetTree.length && offsetTree[startIndex].size === findMaxKeyValue(sizeTree, syncStart)[1]) {\n      startIndex -= 1;\n    }\n    offsetTree = offsetTree.slice(0, startIndex + 1);\n  } else {\n    offsetTree = [];\n  }\n  for (const { start: startIndex2, value } of rangesWithin(sizeTree, syncStart, Infinity)) {\n    const indexOffset = startIndex2 - prevIndex;\n    const aOffset = indexOffset * prevSize + prevOffset + indexOffset * gap;\n    offsetTree.push({\n      offset: aOffset,\n      size: value,\n      index: startIndex2\n    });\n    prevIndex = startIndex2;\n    prevOffset = aOffset;\n    prevSize = value;\n  }\n  return {\n    offsetTree,\n    lastIndex: prevIndex,\n    lastOffset: prevOffset,\n    lastSize: prevSize\n  };\n}\nfunction sizeStateReducer(state, [ranges, groupIndices, log, gap]) {\n  if (ranges.length > 0) {\n    log(\"received item sizes\", ranges, LogLevel.DEBUG);\n  }\n  const sizeTree = state.sizeTree;\n  let newSizeTree = sizeTree;\n  let syncStart = 0;\n  if (groupIndices.length > 0 && empty(sizeTree) && ranges.length === 2) {\n    const groupSize = ranges[0].size;\n    const itemSize = ranges[1].size;\n    newSizeTree = groupIndices.reduce((tree, groupIndex) => {\n      return insert(insert(tree, groupIndex, groupSize), groupIndex + 1, itemSize);\n    }, newSizeTree);\n  } else {\n    [newSizeTree, syncStart] = insertRanges(newSizeTree, ranges);\n  }\n  if (newSizeTree === sizeTree) {\n    return state;\n  }\n  const { offsetTree: newOffsetTree, lastIndex, lastSize, lastOffset } = createOffsetTree(state.offsetTree, syncStart, newSizeTree, gap);\n  return {\n    sizeTree: newSizeTree,\n    offsetTree: newOffsetTree,\n    lastIndex,\n    lastOffset,\n    lastSize,\n    groupOffsetTree: groupIndices.reduce((tree, index) => {\n      return insert(tree, index, offsetOf(index, newOffsetTree, gap));\n    }, newTree()),\n    groupIndices\n  };\n}\nfunction offsetOf(index, tree, gap) {\n  if (tree.length === 0) {\n    return 0;\n  }\n  const { offset, index: startIndex, size } = findClosestSmallerOrEqual(tree, index, indexComparator);\n  const itemCount = index - startIndex;\n  const top = size * itemCount + (itemCount - 1) * gap + offset;\n  return top > 0 ? top + gap : top;\n}\nfunction isGroupLocation(location) {\n  return typeof location.groupIndex !== \"undefined\";\n}\nfunction originalIndexFromLocation(location, sizes, lastIndex) {\n  if (isGroupLocation(location)) {\n    return sizes.groupIndices[location.groupIndex] + 1;\n  } else {\n    const numericIndex = location.index === \"LAST\" ? lastIndex : location.index;\n    let result = originalIndexFromItemIndex(numericIndex, sizes);\n    result = Math.max(0, result, Math.min(lastIndex, result));\n    return result;\n  }\n}\nfunction originalIndexFromItemIndex(itemIndex, sizes) {\n  if (!hasGroups(sizes)) {\n    return itemIndex;\n  }\n  let groupOffset = 0;\n  while (sizes.groupIndices[groupOffset] <= itemIndex + groupOffset) {\n    groupOffset++;\n  }\n  return itemIndex + groupOffset;\n}\nfunction hasGroups(sizes) {\n  return !empty(sizes.groupOffsetTree);\n}\nfunction sizeTreeToRanges(sizeTree) {\n  return walk(sizeTree).map(({ k: startIndex, v: size }, index, sizeArray) => {\n    const nextSize = sizeArray[index + 1];\n    const endIndex = nextSize ? nextSize.k - 1 : Infinity;\n    return { startIndex, endIndex, size };\n  });\n}\nconst SIZE_MAP = {\n  offsetHeight: \"height\",\n  offsetWidth: \"width\"\n};\nconst sizeSystem = system(\n  ([{ log }, { recalcInProgress }]) => {\n    const sizeRanges = stream();\n    const totalCount = stream();\n    const statefulTotalCount = statefulStreamFromEmitter(totalCount, 0);\n    const unshiftWith = stream();\n    const shiftWith = stream();\n    const firstItemIndex = statefulStream(0);\n    const groupIndices = statefulStream([]);\n    const fixedItemSize = statefulStream(void 0);\n    const defaultItemSize = statefulStream(void 0);\n    const itemSize = statefulStream((el, field) => correctItemSize(el, SIZE_MAP[field]));\n    const data = statefulStream(void 0);\n    const gap = statefulStream(0);\n    const initial = initialSizeState();\n    const sizes = statefulStreamFromEmitter(\n      pipe(sizeRanges, withLatestFrom(groupIndices, log, gap), scan(sizeStateReducer, initial), distinctUntilChanged()),\n      initial\n    );\n    const prevGroupIndices = statefulStreamFromEmitter(\n      pipe(\n        groupIndices,\n        distinctUntilChanged(),\n        scan((prev, curr) => ({ prev: prev.current, current: curr }), {\n          prev: [],\n          current: []\n        }),\n        map(({ prev }) => prev)\n      ),\n      []\n    );\n    connect(\n      pipe(\n        groupIndices,\n        filter((indexes) => indexes.length > 0),\n        withLatestFrom(sizes, gap),\n        map(([groupIndices2, sizes2, gap2]) => {\n          const groupOffsetTree = groupIndices2.reduce((tree, index, idx) => {\n            return insert(tree, index, offsetOf(index, sizes2.offsetTree, gap2) || idx);\n          }, newTree());\n          return {\n            ...sizes2,\n            groupIndices: groupIndices2,\n            groupOffsetTree\n          };\n        })\n      ),\n      sizes\n    );\n    connect(\n      pipe(\n        totalCount,\n        withLatestFrom(sizes),\n        filter(([totalCount2, { lastIndex, groupIndices: groupIndices2 }]) => {\n          return totalCount2 < lastIndex && groupIndices2.length === 0;\n        }),\n        map(([totalCount2, { lastIndex, lastSize }]) => {\n          return [\n            {\n              startIndex: totalCount2,\n              endIndex: lastIndex,\n              size: lastSize\n            }\n          ];\n        })\n      ),\n      sizeRanges\n    );\n    connect(fixedItemSize, defaultItemSize);\n    const trackItemSizes = statefulStreamFromEmitter(\n      pipe(\n        fixedItemSize,\n        map((size) => size === void 0)\n      ),\n      true\n    );\n    connect(\n      pipe(\n        defaultItemSize,\n        filter((value) => {\n          return value !== void 0 && empty(getValue(sizes).sizeTree);\n        }),\n        map((size) => [{ startIndex: 0, endIndex: 0, size }])\n      ),\n      sizeRanges\n    );\n    const listRefresh = streamFromEmitter(\n      pipe(\n        sizeRanges,\n        withLatestFrom(sizes),\n        scan(\n          ({ sizes: oldSizes }, [_, newSizes]) => {\n            return {\n              changed: newSizes !== oldSizes,\n              sizes: newSizes\n            };\n          },\n          { changed: false, sizes: initial }\n        ),\n        map((value) => value.changed)\n      )\n    );\n    subscribe(\n      pipe(\n        firstItemIndex,\n        scan(\n          (prev, next) => {\n            return { diff: prev.prev - next, prev: next };\n          },\n          { diff: 0, prev: 0 }\n        ),\n        map((val) => val.diff)\n      ),\n      (offset) => {\n        const { groupIndices: groupIndices2 } = getValue(sizes);\n        if (offset > 0) {\n          publish(recalcInProgress, true);\n          publish(unshiftWith, offset + affectedGroupCount(offset, groupIndices2));\n        } else if (offset < 0) {\n          const prevGroupIndicesValue = getValue(prevGroupIndices);\n          if (prevGroupIndicesValue.length > 0) {\n            offset -= affectedGroupCount(-offset, prevGroupIndicesValue);\n          }\n          publish(shiftWith, offset);\n        }\n      }\n    );\n    subscribe(pipe(firstItemIndex, withLatestFrom(log)), ([index, log2]) => {\n      if (index < 0) {\n        log2(\n          \"`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value\",\n          { firstItemIndex },\n          LogLevel.ERROR\n        );\n      }\n    });\n    const beforeUnshiftWith = streamFromEmitter(unshiftWith);\n    connect(\n      pipe(\n        unshiftWith,\n        withLatestFrom(sizes),\n        map(([unshiftWith2, sizes2]) => {\n          const groupedMode = sizes2.groupIndices.length > 0;\n          const initialRanges = [];\n          const defaultSize = sizes2.lastSize;\n          if (groupedMode) {\n            const firstGroupSize = find(sizes2.sizeTree, 0);\n            let prependedGroupItemsCount = 0;\n            let groupIndex = 0;\n            while (prependedGroupItemsCount < unshiftWith2) {\n              const theGroupIndex = sizes2.groupIndices[groupIndex];\n              const groupItemCount = sizes2.groupIndices.length === groupIndex + 1 ? Infinity : sizes2.groupIndices[groupIndex + 1] - theGroupIndex - 1;\n              initialRanges.push({\n                startIndex: theGroupIndex,\n                endIndex: theGroupIndex,\n                size: firstGroupSize\n              });\n              initialRanges.push({\n                startIndex: theGroupIndex + 1,\n                endIndex: theGroupIndex + 1 + groupItemCount - 1,\n                size: defaultSize\n              });\n              groupIndex++;\n              prependedGroupItemsCount += groupItemCount + 1;\n            }\n            const sizeTreeKV = walk(sizes2.sizeTree);\n            const firstGroupIsExpanded = prependedGroupItemsCount !== unshiftWith2;\n            if (firstGroupIsExpanded) {\n              sizeTreeKV.shift();\n            }\n            return sizeTreeKV.reduce(\n              (acc, { k: index, v: size }) => {\n                let ranges = acc.ranges;\n                if (acc.prevSize !== 0) {\n                  ranges = [\n                    ...acc.ranges,\n                    {\n                      startIndex: acc.prevIndex,\n                      endIndex: index + unshiftWith2 - 1,\n                      size: acc.prevSize\n                    }\n                  ];\n                }\n                return {\n                  ranges,\n                  prevIndex: index + unshiftWith2,\n                  prevSize: size\n                };\n              },\n              {\n                ranges: initialRanges,\n                prevIndex: unshiftWith2,\n                prevSize: 0\n              }\n            ).ranges;\n          }\n          return walk(sizes2.sizeTree).reduce(\n            (acc, { k: index, v: size }) => {\n              return {\n                ranges: [...acc.ranges, { startIndex: acc.prevIndex, endIndex: index + unshiftWith2 - 1, size: acc.prevSize }],\n                prevIndex: index + unshiftWith2,\n                prevSize: size\n              };\n            },\n            {\n              ranges: [],\n              prevIndex: 0,\n              prevSize: defaultSize\n            }\n          ).ranges;\n        })\n      ),\n      sizeRanges\n    );\n    const shiftWithOffset = streamFromEmitter(\n      pipe(\n        shiftWith,\n        withLatestFrom(sizes, gap),\n        map(([shiftWith2, { offsetTree }, gap2]) => {\n          const newFirstItemIndex = -shiftWith2;\n          return offsetOf(newFirstItemIndex, offsetTree, gap2);\n        })\n      )\n    );\n    connect(\n      pipe(\n        shiftWith,\n        withLatestFrom(sizes, gap),\n        map(([shiftWith2, sizes2, gap2]) => {\n          const groupedMode = sizes2.groupIndices.length > 0;\n          if (groupedMode) {\n            if (empty(sizes2.sizeTree)) {\n              return sizes2;\n            }\n            let newSizeTree = newTree();\n            const prevGroupIndicesValue = getValue(prevGroupIndices);\n            let removedItemsCount = 0;\n            let groupIndex = 0;\n            let groupOffset = 0;\n            while (removedItemsCount < -shiftWith2) {\n              groupOffset = prevGroupIndicesValue[groupIndex];\n              const groupItemCount = prevGroupIndicesValue[groupIndex + 1] - groupOffset - 1;\n              groupIndex++;\n              removedItemsCount += groupItemCount + 1;\n            }\n            newSizeTree = walk(sizes2.sizeTree).reduce((acc, { k, v }) => {\n              return insert(acc, Math.max(0, k + shiftWith2), v);\n            }, newSizeTree);\n            const aGroupIsShrunk = removedItemsCount !== -shiftWith2;\n            if (aGroupIsShrunk) {\n              const firstGroupSize = find(sizes2.sizeTree, groupOffset);\n              newSizeTree = insert(newSizeTree, 0, firstGroupSize);\n              const nextItemSize = findMaxKeyValue(sizes2.sizeTree, -shiftWith2 + 1)[1];\n              newSizeTree = insert(newSizeTree, 1, nextItemSize);\n            }\n            return {\n              ...sizes2,\n              sizeTree: newSizeTree,\n              ...createOffsetTree(sizes2.offsetTree, 0, newSizeTree, gap2)\n            };\n          } else {\n            const newSizeTree = walk(sizes2.sizeTree).reduce((acc, { k, v }) => {\n              return insert(acc, Math.max(0, k + shiftWith2), v);\n            }, newTree());\n            return {\n              ...sizes2,\n              sizeTree: newSizeTree,\n              ...createOffsetTree(sizes2.offsetTree, 0, newSizeTree, gap2)\n            };\n          }\n        })\n      ),\n      sizes\n    );\n    return {\n      // input\n      data,\n      totalCount,\n      sizeRanges,\n      groupIndices,\n      defaultItemSize,\n      fixedItemSize,\n      unshiftWith,\n      shiftWith,\n      shiftWithOffset,\n      beforeUnshiftWith,\n      firstItemIndex,\n      gap,\n      // output\n      sizes,\n      listRefresh,\n      statefulTotalCount,\n      trackItemSizes,\n      itemSize\n    };\n  },\n  tup(loggerSystem, recalcSystem),\n  { singleton: true }\n);\nconst SUPPORTS_SCROLL_TO_OPTIONS = typeof document !== \"undefined\" && \"scrollBehavior\" in document.documentElement.style;\nfunction normalizeIndexLocation(location) {\n  const result = typeof location === \"number\" ? { index: location } : location;\n  if (!result.align) {\n    result.align = \"start\";\n  }\n  if (!result.behavior || !SUPPORTS_SCROLL_TO_OPTIONS) {\n    result.behavior = \"auto\";\n  }\n  if (!result.offset) {\n    result.offset = 0;\n  }\n  return result;\n}\nconst scrollToIndexSystem = system(\n  ([\n    { sizes, totalCount, listRefresh, gap },\n    {\n      scrollingInProgress,\n      viewportHeight,\n      scrollTo,\n      smoothScrollTargetReached,\n      headerHeight,\n      footerHeight,\n      fixedHeaderHeight,\n      fixedFooterHeight\n    },\n    { log }\n  ]) => {\n    const scrollToIndex = stream();\n    const topListHeight = statefulStream(0);\n    let unsubscribeNextListRefresh = null;\n    let cleartTimeoutRef = null;\n    let unsubscribeListRefresh = null;\n    function cleanup() {\n      if (unsubscribeNextListRefresh) {\n        unsubscribeNextListRefresh();\n        unsubscribeNextListRefresh = null;\n      }\n      if (unsubscribeListRefresh) {\n        unsubscribeListRefresh();\n        unsubscribeListRefresh = null;\n      }\n      if (cleartTimeoutRef) {\n        clearTimeout(cleartTimeoutRef);\n        cleartTimeoutRef = null;\n      }\n      publish(scrollingInProgress, false);\n    }\n    connect(\n      pipe(\n        scrollToIndex,\n        withLatestFrom(sizes, viewportHeight, totalCount, topListHeight, headerHeight, footerHeight, log),\n        withLatestFrom(gap, fixedHeaderHeight, fixedFooterHeight),\n        map(\n          ([\n            [location, sizes2, viewportHeight2, totalCount2, topListHeight2, headerHeight2, footerHeight2, log2],\n            gap2,\n            fixedHeaderHeight2,\n            fixedFooterHeight2\n          ]) => {\n            const normalLocation = normalizeIndexLocation(location);\n            const { align, behavior, offset } = normalLocation;\n            const lastIndex = totalCount2 - 1;\n            const index = originalIndexFromLocation(normalLocation, sizes2, lastIndex);\n            let top = offsetOf(index, sizes2.offsetTree, gap2) + headerHeight2;\n            if (align === \"end\") {\n              top += fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index)[1] - viewportHeight2 + fixedFooterHeight2;\n              if (index === lastIndex) {\n                top += footerHeight2;\n              }\n            } else if (align === \"center\") {\n              top += (fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index)[1] - viewportHeight2 + fixedFooterHeight2) / 2;\n            } else {\n              top -= topListHeight2;\n            }\n            if (offset) {\n              top += offset;\n            }\n            const retry = (listChanged) => {\n              cleanup();\n              if (listChanged) {\n                log2(\"retrying to scroll to\", { location }, LogLevel.DEBUG);\n                publish(scrollToIndex, location);\n              } else {\n                log2(\"list did not change, scroll successful\", {}, LogLevel.DEBUG);\n              }\n            };\n            cleanup();\n            if (behavior === \"smooth\") {\n              let listChanged = false;\n              unsubscribeListRefresh = subscribe(listRefresh, (changed) => {\n                listChanged = listChanged || changed;\n              });\n              unsubscribeNextListRefresh = handleNext(smoothScrollTargetReached, () => {\n                retry(listChanged);\n              });\n            } else {\n              unsubscribeNextListRefresh = handleNext(pipe(listRefresh, watchChangesFor(150)), retry);\n            }\n            cleartTimeoutRef = setTimeout(() => {\n              cleanup();\n            }, 1200);\n            publish(scrollingInProgress, true);\n            log2(\"scrolling from index to\", { index, top, behavior }, LogLevel.DEBUG);\n            return { top, behavior };\n          }\n        )\n      ),\n      scrollTo\n    );\n    return {\n      scrollToIndex,\n      topListHeight\n    };\n  },\n  tup(sizeSystem, domIOSystem, loggerSystem),\n  { singleton: true }\n);\nfunction watchChangesFor(limit) {\n  return (done) => {\n    const timeoutRef = setTimeout(() => {\n      done(false);\n    }, limit);\n    return (value) => {\n      if (value) {\n        done(true);\n        clearTimeout(timeoutRef);\n      }\n    };\n  };\n}\nconst UP = \"up\";\nconst DOWN = \"down\";\nconst NONE$1 = \"none\";\nconst INITIAL_BOTTOM_STATE = {\n  atBottom: false,\n  notAtBottomBecause: \"NOT_SHOWING_LAST_ITEM\",\n  state: {\n    offsetBottom: 0,\n    scrollTop: 0,\n    viewportHeight: 0,\n    scrollHeight: 0\n  }\n};\nconst DEFAULT_AT_TOP_THRESHOLD = 0;\nconst stateFlagsSystem = system(([{ scrollContainerState, scrollTop, viewportHeight, headerHeight, footerHeight, scrollBy }]) => {\n  const isAtBottom = statefulStream(false);\n  const isAtTop = statefulStream(true);\n  const atBottomStateChange = stream();\n  const atTopStateChange = stream();\n  const atBottomThreshold = statefulStream(4);\n  const atTopThreshold = statefulStream(DEFAULT_AT_TOP_THRESHOLD);\n  const isScrolling = statefulStreamFromEmitter(\n    pipe(\n      merge(pipe(duc(scrollTop), skip(1), mapTo(true)), pipe(duc(scrollTop), skip(1), mapTo(false), debounceTime(100))),\n      distinctUntilChanged()\n    ),\n    false\n  );\n  const isScrollingBy = statefulStreamFromEmitter(\n    pipe(merge(pipe(scrollBy, mapTo(true)), pipe(scrollBy, mapTo(false), debounceTime(200))), distinctUntilChanged()),\n    false\n  );\n  connect(\n    pipe(\n      combineLatest(duc(scrollTop), duc(atTopThreshold)),\n      map(([top, atTopThreshold2]) => top <= atTopThreshold2),\n      distinctUntilChanged()\n    ),\n    isAtTop\n  );\n  connect(pipe(isAtTop, throttleTime(50)), atTopStateChange);\n  const atBottomState = streamFromEmitter(\n    pipe(\n      combineLatest(scrollContainerState, duc(viewportHeight), duc(headerHeight), duc(footerHeight), duc(atBottomThreshold)),\n      scan((current, [{ scrollTop: scrollTop2, scrollHeight }, viewportHeight2, _headerHeight, _footerHeight, atBottomThreshold2]) => {\n        const isAtBottom2 = scrollTop2 + viewportHeight2 - scrollHeight > -atBottomThreshold2;\n        const state = {\n          viewportHeight: viewportHeight2,\n          scrollTop: scrollTop2,\n          scrollHeight\n        };\n        if (isAtBottom2) {\n          let atBottomBecause;\n          let scrollTopDelta;\n          if (scrollTop2 > current.state.scrollTop) {\n            atBottomBecause = \"SCROLLED_DOWN\";\n            scrollTopDelta = current.state.scrollTop - scrollTop2;\n          } else {\n            atBottomBecause = \"SIZE_DECREASED\";\n            scrollTopDelta = current.state.scrollTop - scrollTop2 || current.scrollTopDelta;\n          }\n          return {\n            atBottom: true,\n            state,\n            atBottomBecause,\n            scrollTopDelta\n          };\n        }\n        let notAtBottomBecause;\n        if (state.scrollHeight > current.state.scrollHeight) {\n          notAtBottomBecause = \"SIZE_INCREASED\";\n        } else if (viewportHeight2 < current.state.viewportHeight) {\n          notAtBottomBecause = \"VIEWPORT_HEIGHT_DECREASING\";\n        } else if (scrollTop2 < current.state.scrollTop) {\n          notAtBottomBecause = \"SCROLLING_UPWARDS\";\n        } else {\n          notAtBottomBecause = \"NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM\";\n        }\n        return {\n          atBottom: false,\n          notAtBottomBecause,\n          state\n        };\n      }, INITIAL_BOTTOM_STATE),\n      distinctUntilChanged((prev, next) => {\n        return prev && prev.atBottom === next.atBottom;\n      })\n    )\n  );\n  const lastJumpDueToItemResize = statefulStreamFromEmitter(\n    pipe(\n      scrollContainerState,\n      scan(\n        (current, { scrollTop: scrollTop2, scrollHeight, viewportHeight: viewportHeight2 }) => {\n          if (!approximatelyEqual(current.scrollHeight, scrollHeight)) {\n            const atBottom = scrollHeight - (scrollTop2 + viewportHeight2) < 1;\n            if (current.scrollTop !== scrollTop2 && atBottom) {\n              return {\n                scrollHeight,\n                scrollTop: scrollTop2,\n                jump: current.scrollTop - scrollTop2,\n                changed: true\n              };\n            } else {\n              return {\n                scrollHeight,\n                scrollTop: scrollTop2,\n                jump: 0,\n                changed: true\n              };\n            }\n          } else {\n            return {\n              scrollTop: scrollTop2,\n              scrollHeight,\n              jump: 0,\n              changed: false\n            };\n          }\n        },\n        { scrollHeight: 0, jump: 0, scrollTop: 0, changed: false }\n      ),\n      filter((value) => value.changed),\n      map((value) => value.jump)\n    ),\n    0\n  );\n  connect(\n    pipe(\n      atBottomState,\n      map((state) => state.atBottom)\n    ),\n    isAtBottom\n  );\n  connect(pipe(isAtBottom, throttleTime(50)), atBottomStateChange);\n  const scrollDirection = statefulStream(DOWN);\n  connect(\n    pipe(\n      scrollContainerState,\n      map(({ scrollTop: scrollTop2 }) => scrollTop2),\n      distinctUntilChanged(),\n      scan(\n        (acc, scrollTop2) => {\n          if (getValue(isScrollingBy)) {\n            return { direction: acc.direction, prevScrollTop: scrollTop2 };\n          }\n          return { direction: scrollTop2 < acc.prevScrollTop ? UP : DOWN, prevScrollTop: scrollTop2 };\n        },\n        { direction: DOWN, prevScrollTop: 0 }\n      ),\n      map((value) => value.direction)\n    ),\n    scrollDirection\n  );\n  connect(pipe(scrollContainerState, throttleTime(50), mapTo(NONE$1)), scrollDirection);\n  const scrollVelocity = statefulStream(0);\n  connect(\n    pipe(\n      isScrolling,\n      filter((value) => !value),\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      mapTo(0)\n    ),\n    scrollVelocity\n  );\n  connect(\n    pipe(\n      scrollTop,\n      throttleTime(100),\n      withLatestFrom(isScrolling),\n      filter(([_, isScrolling2]) => !!isScrolling2),\n      scan(([_, prev], [next]) => [prev, next], [0, 0]),\n      map(([prev, next]) => next - prev)\n    ),\n    scrollVelocity\n  );\n  return {\n    isScrolling,\n    isAtTop,\n    isAtBottom,\n    atBottomState,\n    atTopStateChange,\n    atBottomStateChange,\n    scrollDirection,\n    atBottomThreshold,\n    atTopThreshold,\n    scrollVelocity,\n    lastJumpDueToItemResize\n  };\n}, tup(domIOSystem));\nconst propsReadySystem = system(\n  ([{ log }]) => {\n    const propsReady = statefulStream(false);\n    const didMount = streamFromEmitter(\n      pipe(\n        propsReady,\n        filter((ready) => ready),\n        distinctUntilChanged()\n      )\n    );\n    subscribe(propsReady, (value) => {\n      value && getValue(log)(\"props updated\", {}, LogLevel.DEBUG);\n    });\n    return { propsReady, didMount };\n  },\n  tup(loggerSystem),\n  { singleton: true }\n);\nfunction getInitialTopMostItemIndexNumber(location, totalCount) {\n  const lastIndex = totalCount - 1;\n  const index = typeof location === \"number\" ? location : location.index === \"LAST\" ? lastIndex : location.index;\n  return index;\n}\nfunction skipFrames(frameCount, callback) {\n  if (frameCount == 0) {\n    callback();\n  } else {\n    requestAnimationFrame(() => skipFrames(frameCount - 1, callback));\n  }\n}\nconst initialTopMostItemIndexSystem = system(\n  ([{ sizes, listRefresh, defaultItemSize }, { scrollTop }, { scrollToIndex }, { didMount }]) => {\n    const scrolledToInitialItem = statefulStream(true);\n    const initialTopMostItemIndex = statefulStream(0);\n    const scrollScheduled = statefulStream(false);\n    connect(\n      pipe(\n        didMount,\n        withLatestFrom(initialTopMostItemIndex),\n        filter(([_, location]) => !!location),\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        mapTo(false)\n      ),\n      scrolledToInitialItem\n    );\n    subscribe(\n      pipe(\n        combineLatest(listRefresh, didMount),\n        withLatestFrom(scrolledToInitialItem, sizes, defaultItemSize, scrollScheduled),\n        filter(([[, didMount2], scrolledToInitialItem2, { sizeTree }, defaultItemSize2, scrollScheduled2]) => {\n          return didMount2 && (!empty(sizeTree) || isDefined(defaultItemSize2)) && !scrolledToInitialItem2 && !scrollScheduled2;\n        }),\n        withLatestFrom(initialTopMostItemIndex)\n      ),\n      ([, initialTopMostItemIndex2]) => {\n        publish(scrollScheduled, true);\n        skipFrames(2, () => {\n          handleNext(scrollTop, () => publish(scrolledToInitialItem, true));\n          publish(scrollToIndex, initialTopMostItemIndex2);\n        });\n      }\n    );\n    return {\n      scrolledToInitialItem,\n      initialTopMostItemIndex\n    };\n  },\n  tup(sizeSystem, domIOSystem, scrollToIndexSystem, propsReadySystem),\n  { singleton: true }\n);\nfunction normalizeFollowOutput(follow) {\n  if (!follow) {\n    return false;\n  }\n  return follow === \"smooth\" ? \"smooth\" : \"auto\";\n}\nconst behaviorFromFollowOutput = (follow, isAtBottom) => {\n  if (typeof follow === \"function\") {\n    return normalizeFollowOutput(follow(isAtBottom));\n  }\n  return isAtBottom && normalizeFollowOutput(follow);\n};\nconst followOutputSystem = system(\n  ([\n    { totalCount, listRefresh },\n    { isAtBottom, atBottomState },\n    { scrollToIndex },\n    { scrolledToInitialItem },\n    { propsReady, didMount },\n    { log },\n    { scrollingInProgress }\n  ]) => {\n    const followOutput = statefulStream(false);\n    const autoscrollToBottom = stream();\n    let pendingScrollHandle = null;\n    function scrollToBottom(followOutputBehavior) {\n      publish(scrollToIndex, {\n        index: \"LAST\",\n        align: \"end\",\n        behavior: followOutputBehavior\n      });\n    }\n    subscribe(\n      pipe(\n        combineLatest(pipe(duc(totalCount), skip(1)), didMount),\n        withLatestFrom(duc(followOutput), isAtBottom, scrolledToInitialItem, scrollingInProgress),\n        map(([[totalCount2, didMount2], followOutput2, isAtBottom2, scrolledToInitialItem2, scrollingInProgress2]) => {\n          let shouldFollow = didMount2 && scrolledToInitialItem2;\n          let followOutputBehavior = \"auto\";\n          if (shouldFollow) {\n            followOutputBehavior = behaviorFromFollowOutput(followOutput2, isAtBottom2 || scrollingInProgress2);\n            shouldFollow = shouldFollow && !!followOutputBehavior;\n          }\n          return { totalCount: totalCount2, shouldFollow, followOutputBehavior };\n        }),\n        filter(({ shouldFollow }) => shouldFollow)\n      ),\n      ({ totalCount: totalCount2, followOutputBehavior }) => {\n        if (pendingScrollHandle) {\n          pendingScrollHandle();\n          pendingScrollHandle = null;\n        }\n        pendingScrollHandle = handleNext(listRefresh, () => {\n          getValue(log)(\"following output to \", { totalCount: totalCount2 }, LogLevel.DEBUG);\n          scrollToBottom(followOutputBehavior);\n          pendingScrollHandle = null;\n        });\n      }\n    );\n    function trapNextSizeIncrease(followOutput2) {\n      const cancel = handleNext(atBottomState, (state) => {\n        if (followOutput2 && !state.atBottom && state.notAtBottomBecause === \"SIZE_INCREASED\" && !pendingScrollHandle) {\n          getValue(log)(\"scrolling to bottom due to increased size\", {}, LogLevel.DEBUG);\n          scrollToBottom(\"auto\");\n        }\n      });\n      setTimeout(cancel, 100);\n    }\n    subscribe(\n      pipe(\n        combineLatest(duc(followOutput), totalCount, propsReady),\n        filter(([follow, , ready]) => follow && ready),\n        scan(\n          ({ value }, [, next]) => {\n            return { refreshed: value === next, value: next };\n          },\n          { refreshed: false, value: 0 }\n        ),\n        filter(({ refreshed }) => refreshed),\n        withLatestFrom(followOutput, totalCount)\n      ),\n      ([, followOutput2]) => {\n        trapNextSizeIncrease(followOutput2 !== false);\n      }\n    );\n    subscribe(autoscrollToBottom, () => {\n      trapNextSizeIncrease(getValue(followOutput) !== false);\n    });\n    subscribe(combineLatest(duc(followOutput), atBottomState), ([followOutput2, state]) => {\n      if (followOutput2 && !state.atBottom && state.notAtBottomBecause === \"VIEWPORT_HEIGHT_DECREASING\") {\n        scrollToBottom(\"auto\");\n      }\n    });\n    return { followOutput, autoscrollToBottom };\n  },\n  tup(sizeSystem, stateFlagsSystem, scrollToIndexSystem, initialTopMostItemIndexSystem, propsReadySystem, loggerSystem, domIOSystem)\n);\nfunction groupCountsToIndicesAndCount(counts) {\n  return counts.reduce(\n    (acc, groupCount) => {\n      acc.groupIndices.push(acc.totalCount);\n      acc.totalCount += groupCount + 1;\n      return acc;\n    },\n    {\n      totalCount: 0,\n      groupIndices: []\n    }\n  );\n}\nconst groupedListSystem = system(([{ totalCount, groupIndices, sizes }, { scrollTop, headerHeight }]) => {\n  const groupCounts = stream();\n  const topItemsIndexes = stream();\n  const groupIndicesAndCount = streamFromEmitter(pipe(groupCounts, map(groupCountsToIndicesAndCount)));\n  connect(\n    pipe(\n      groupIndicesAndCount,\n      map((value) => value.totalCount)\n    ),\n    totalCount\n  );\n  connect(\n    pipe(\n      groupIndicesAndCount,\n      map((value) => value.groupIndices)\n    ),\n    groupIndices\n  );\n  connect(\n    pipe(\n      combineLatest(scrollTop, sizes, headerHeight),\n      filter(([_, sizes2]) => hasGroups(sizes2)),\n      map(([scrollTop2, state, headerHeight2]) => findMaxKeyValue(state.groupOffsetTree, Math.max(scrollTop2 - headerHeight2, 0), \"v\")[0]),\n      distinctUntilChanged(),\n      map((index) => [index])\n    ),\n    topItemsIndexes\n  );\n  return { groupCounts, topItemsIndexes };\n}, tup(sizeSystem, domIOSystem));\nfunction tupleComparator(prev, current) {\n  return !!(prev && prev[0] === current[0] && prev[1] === current[1]);\n}\nfunction rangeComparator(prev, next) {\n  return !!(prev && prev.startIndex === next.startIndex && prev.endIndex === next.endIndex);\n}\nconst TOP = \"top\";\nconst BOTTOM = \"bottom\";\nconst NONE = \"none\";\nfunction getOverscan(overscan, end, direction) {\n  if (typeof overscan === \"number\") {\n    return direction === UP && end === TOP || direction === DOWN && end === BOTTOM ? overscan : 0;\n  } else {\n    if (direction === UP) {\n      return end === TOP ? overscan.main : overscan.reverse;\n    } else {\n      return end === BOTTOM ? overscan.main : overscan.reverse;\n    }\n  }\n}\nfunction getViewportIncrease(value, end) {\n  return typeof value === \"number\" ? value : value[end] || 0;\n}\nconst sizeRangeSystem = system(\n  ([{ scrollTop, viewportHeight, deviation, headerHeight, fixedHeaderHeight }]) => {\n    const listBoundary = stream();\n    const topListHeight = statefulStream(0);\n    const increaseViewportBy = statefulStream(0);\n    const overscan = statefulStream(0);\n    const visibleRange = statefulStreamFromEmitter(\n      pipe(\n        combineLatest(\n          duc(scrollTop),\n          duc(viewportHeight),\n          duc(headerHeight),\n          duc(listBoundary, tupleComparator),\n          duc(overscan),\n          duc(topListHeight),\n          duc(fixedHeaderHeight),\n          duc(deviation),\n          duc(increaseViewportBy)\n        ),\n        map(\n          ([\n            scrollTop2,\n            viewportHeight2,\n            headerHeight2,\n            [listTop, listBottom],\n            overscan2,\n            topListHeight2,\n            fixedHeaderHeight2,\n            deviation2,\n            increaseViewportBy2\n          ]) => {\n            const top = scrollTop2 - deviation2;\n            const stickyHeaderHeight = topListHeight2 + fixedHeaderHeight2;\n            const headerVisible = Math.max(headerHeight2 - top, 0);\n            let direction = NONE;\n            const topViewportAddition = getViewportIncrease(increaseViewportBy2, TOP);\n            const bottomViewportAddition = getViewportIncrease(increaseViewportBy2, BOTTOM);\n            listTop -= deviation2;\n            listTop += headerHeight2 + fixedHeaderHeight2;\n            listBottom += headerHeight2 + fixedHeaderHeight2;\n            listBottom -= deviation2;\n            if (listTop > scrollTop2 + stickyHeaderHeight - topViewportAddition) {\n              direction = UP;\n            }\n            if (listBottom < scrollTop2 - headerVisible + viewportHeight2 + bottomViewportAddition) {\n              direction = DOWN;\n            }\n            if (direction !== NONE) {\n              return [\n                Math.max(top - headerHeight2 - getOverscan(overscan2, TOP, direction) - topViewportAddition, 0),\n                top - headerVisible - fixedHeaderHeight2 + viewportHeight2 + getOverscan(overscan2, BOTTOM, direction) + bottomViewportAddition\n              ];\n            }\n            return null;\n          }\n        ),\n        filter((value) => value != null),\n        distinctUntilChanged(tupleComparator)\n      ),\n      [0, 0]\n    );\n    return {\n      // input\n      listBoundary,\n      overscan,\n      topListHeight,\n      increaseViewportBy,\n      // output\n      visibleRange\n    };\n  },\n  tup(domIOSystem),\n  { singleton: true }\n);\nfunction probeItemSet(index, sizes, data) {\n  if (hasGroups(sizes)) {\n    const itemIndex = originalIndexFromItemIndex(index, sizes);\n    const groupIndex = findMaxKeyValue(sizes.groupOffsetTree, itemIndex)[0];\n    return [\n      { index: groupIndex, size: 0, offset: 0 },\n      { index: itemIndex, size: 0, offset: 0, data: data && data[0] }\n    ];\n  }\n  return [{ index, size: 0, offset: 0, data: data && data[0] }];\n}\nconst EMPTY_LIST_STATE = {\n  items: [],\n  topItems: [],\n  offsetTop: 0,\n  offsetBottom: 0,\n  top: 0,\n  bottom: 0,\n  topListHeight: 0,\n  totalCount: 0,\n  firstItemIndex: 0\n};\nfunction transposeItems(items, sizes, firstItemIndex) {\n  if (items.length === 0) {\n    return [];\n  }\n  if (!hasGroups(sizes)) {\n    return items.map((item) => ({ ...item, index: item.index + firstItemIndex, originalIndex: item.index }));\n  }\n  const startIndex = items[0].index;\n  const endIndex = items[items.length - 1].index;\n  const transposedItems = [];\n  const groupRanges = rangesWithin(sizes.groupOffsetTree, startIndex, endIndex);\n  let currentRange = void 0;\n  let currentGroupIndex = 0;\n  for (const item of items) {\n    if (!currentRange || currentRange.end < item.index) {\n      currentRange = groupRanges.shift();\n      currentGroupIndex = sizes.groupIndices.indexOf(currentRange.start);\n    }\n    let transposedItem;\n    if (item.index === currentRange.start) {\n      transposedItem = {\n        type: \"group\",\n        index: currentGroupIndex\n      };\n    } else {\n      transposedItem = {\n        index: item.index - (currentGroupIndex + 1) + firstItemIndex,\n        groupIndex: currentGroupIndex\n      };\n    }\n    transposedItems.push({\n      ...transposedItem,\n      size: item.size,\n      offset: item.offset,\n      originalIndex: item.index,\n      data: item.data\n    });\n  }\n  return transposedItems;\n}\nfunction buildListState(items, topItems, totalCount, gap, sizes, firstItemIndex) {\n  const { lastSize, lastOffset, lastIndex } = sizes;\n  let offsetTop = 0;\n  let bottom = 0;\n  if (items.length > 0) {\n    offsetTop = items[0].offset;\n    const lastItem = items[items.length - 1];\n    bottom = lastItem.offset + lastItem.size;\n  }\n  const itemCount = totalCount - lastIndex;\n  const total = lastOffset + itemCount * lastSize + (itemCount - 1) * gap;\n  const top = offsetTop;\n  const offsetBottom = total - bottom;\n  return {\n    items: transposeItems(items, sizes, firstItemIndex),\n    topItems: transposeItems(topItems, sizes, firstItemIndex),\n    topListHeight: topItems.reduce((height, item) => item.size + height, 0),\n    offsetTop,\n    offsetBottom,\n    top,\n    bottom,\n    totalCount,\n    firstItemIndex\n  };\n}\nconst listStateSystem = system(\n  ([\n    { sizes, totalCount, data, firstItemIndex, gap },\n    groupedListSystem2,\n    { visibleRange, listBoundary, topListHeight: rangeTopListHeight },\n    { scrolledToInitialItem, initialTopMostItemIndex },\n    { topListHeight },\n    stateFlags,\n    { didMount },\n    { recalcInProgress }\n  ]) => {\n    const topItemsIndexes = statefulStream([]);\n    const itemsRendered = stream();\n    connect(groupedListSystem2.topItemsIndexes, topItemsIndexes);\n    const listState = statefulStreamFromEmitter(\n      pipe(\n        combineLatest(\n          didMount,\n          recalcInProgress,\n          duc(visibleRange, tupleComparator),\n          duc(totalCount),\n          duc(sizes),\n          duc(initialTopMostItemIndex),\n          scrolledToInitialItem,\n          duc(topItemsIndexes),\n          duc(firstItemIndex),\n          duc(gap),\n          data\n        ),\n        filter(([mount, recalcInProgress2, , totalCount2, , , , , , , data2]) => {\n          const dataChangeInProgress = data2 && data2.length !== totalCount2;\n          return mount && !recalcInProgress2 && !dataChangeInProgress;\n        }),\n        map(\n          ([\n            ,\n            ,\n            [startOffset, endOffset],\n            totalCount2,\n            sizes2,\n            initialTopMostItemIndex2,\n            scrolledToInitialItem2,\n            topItemsIndexes2,\n            firstItemIndex2,\n            gap2,\n            data2\n          ]) => {\n            const sizesValue = sizes2;\n            const { sizeTree, offsetTree } = sizesValue;\n            if (totalCount2 === 0 || startOffset === 0 && endOffset === 0) {\n              return { ...EMPTY_LIST_STATE, totalCount: totalCount2 };\n            }\n            if (empty(sizeTree)) {\n              return buildListState(\n                probeItemSet(getInitialTopMostItemIndexNumber(initialTopMostItemIndex2, totalCount2), sizesValue, data2),\n                [],\n                totalCount2,\n                gap2,\n                sizesValue,\n                firstItemIndex2\n              );\n            }\n            const topItems = [];\n            if (topItemsIndexes2.length > 0) {\n              const startIndex = topItemsIndexes2[0];\n              const endIndex = topItemsIndexes2[topItemsIndexes2.length - 1];\n              let offset = 0;\n              for (const range of rangesWithin(sizeTree, startIndex, endIndex)) {\n                const size = range.value;\n                const rangeStartIndex = Math.max(range.start, startIndex);\n                const rangeEndIndex = Math.min(range.end, endIndex);\n                for (let i = rangeStartIndex; i <= rangeEndIndex; i++) {\n                  topItems.push({ index: i, size, offset, data: data2 && data2[i] });\n                  offset += size;\n                }\n              }\n            }\n            if (!scrolledToInitialItem2) {\n              return buildListState([], topItems, totalCount2, gap2, sizesValue, firstItemIndex2);\n            }\n            const minStartIndex = topItemsIndexes2.length > 0 ? topItemsIndexes2[topItemsIndexes2.length - 1] + 1 : 0;\n            const offsetPointRanges = rangesWithinOffsets(offsetTree, startOffset, endOffset, minStartIndex);\n            if (offsetPointRanges.length === 0) {\n              return null;\n            }\n            const maxIndex = totalCount2 - 1;\n            const items = tap([], (result) => {\n              for (const range of offsetPointRanges) {\n                const point = range.value;\n                let offset = point.offset;\n                let rangeStartIndex = range.start;\n                const size = point.size;\n                if (point.offset < startOffset) {\n                  rangeStartIndex += Math.floor((startOffset - point.offset + gap2) / (size + gap2));\n                  const itemCount = rangeStartIndex - range.start;\n                  offset += itemCount * size + itemCount * gap2;\n                }\n                if (rangeStartIndex < minStartIndex) {\n                  offset += (minStartIndex - rangeStartIndex) * size;\n                  rangeStartIndex = minStartIndex;\n                }\n                const endIndex = Math.min(range.end, maxIndex);\n                for (let i = rangeStartIndex; i <= endIndex; i++) {\n                  if (offset >= endOffset) {\n                    break;\n                  }\n                  result.push({ index: i, size, offset, data: data2 && data2[i] });\n                  offset += size + gap2;\n                }\n              }\n            });\n            return buildListState(items, topItems, totalCount2, gap2, sizesValue, firstItemIndex2);\n          }\n        ),\n        //@ts-expect-error filter needs to be fixed\n        filter((value) => value !== null),\n        distinctUntilChanged()\n      ),\n      EMPTY_LIST_STATE\n    );\n    connect(\n      pipe(\n        data,\n        filter(isDefined),\n        map((data2) => data2 == null ? void 0 : data2.length)\n      ),\n      totalCount\n    );\n    connect(\n      pipe(\n        listState,\n        map((value) => value.topListHeight)\n      ),\n      topListHeight\n    );\n    connect(topListHeight, rangeTopListHeight);\n    connect(\n      pipe(\n        listState,\n        map((state) => [state.top, state.bottom])\n      ),\n      listBoundary\n    );\n    connect(\n      pipe(\n        listState,\n        map((state) => state.items)\n      ),\n      itemsRendered\n    );\n    const endReached = streamFromEmitter(\n      pipe(\n        listState,\n        filter(({ items }) => items.length > 0),\n        withLatestFrom(totalCount, data),\n        filter(([{ items }, totalCount2]) => items[items.length - 1].originalIndex === totalCount2 - 1),\n        map(([, totalCount2, data2]) => [totalCount2 - 1, data2]),\n        distinctUntilChanged(tupleComparator),\n        map(([count]) => count)\n      )\n    );\n    const startReached = streamFromEmitter(\n      pipe(\n        listState,\n        throttleTime(200),\n        filter(({ items, topItems }) => {\n          return items.length > 0 && items[0].originalIndex === topItems.length;\n        }),\n        map(({ items }) => items[0].index),\n        distinctUntilChanged()\n      )\n    );\n    const rangeChanged = streamFromEmitter(\n      pipe(\n        listState,\n        filter(({ items }) => items.length > 0),\n        map(({ items }) => {\n          let startIndex = 0;\n          let endIndex = items.length - 1;\n          while (items[startIndex].type === \"group\" && startIndex < endIndex) {\n            startIndex++;\n          }\n          while (items[endIndex].type === \"group\" && endIndex > startIndex) {\n            endIndex--;\n          }\n          return {\n            startIndex: items[startIndex].index,\n            endIndex: items[endIndex].index\n          };\n        }),\n        distinctUntilChanged(rangeComparator)\n      )\n    );\n    return { listState, topItemsIndexes, endReached, startReached, rangeChanged, itemsRendered, ...stateFlags };\n  },\n  tup(\n    sizeSystem,\n    groupedListSystem,\n    sizeRangeSystem,\n    initialTopMostItemIndexSystem,\n    scrollToIndexSystem,\n    stateFlagsSystem,\n    propsReadySystem,\n    recalcSystem\n  ),\n  { singleton: true }\n);\nconst initialItemCountSystem = system(\n  ([{ sizes, firstItemIndex, data, gap }, { listState }, { didMount }]) => {\n    const initialItemCount = statefulStream(0);\n    connect(\n      pipe(\n        didMount,\n        withLatestFrom(initialItemCount),\n        filter(([, count]) => count !== 0),\n        withLatestFrom(sizes, firstItemIndex, gap, data),\n        map(([[, count], sizes2, firstItemIndex2, gap2, data2 = []]) => {\n          let includedGroupsCount = 0;\n          if (sizes2.groupIndices.length > 0) {\n            for (const index of sizes2.groupIndices) {\n              if (index - includedGroupsCount >= count) {\n                break;\n              }\n              includedGroupsCount++;\n            }\n          }\n          const adjustedCount = count + includedGroupsCount;\n          const items = Array.from({ length: adjustedCount }).map((_, index) => ({ index, size: 0, offset: 0, data: data2[index] }));\n          return buildListState(items, [], adjustedCount, gap2, sizes2, firstItemIndex2);\n        })\n      ),\n      listState\n    );\n    return { initialItemCount };\n  },\n  tup(sizeSystem, listStateSystem, propsReadySystem),\n  { singleton: true }\n);\nconst scrollSeekSystem = system(\n  ([{ scrollVelocity }]) => {\n    const isSeeking = statefulStream(false);\n    const rangeChanged = stream();\n    const scrollSeekConfiguration = statefulStream(false);\n    connect(\n      pipe(\n        scrollVelocity,\n        withLatestFrom(scrollSeekConfiguration, isSeeking, rangeChanged),\n        filter(([_, config]) => !!config),\n        map(([speed, config, isSeeking2, range]) => {\n          const { exit, enter } = config;\n          if (isSeeking2) {\n            if (exit(speed, range)) {\n              return false;\n            }\n          } else {\n            if (enter(speed, range)) {\n              return true;\n            }\n          }\n          return isSeeking2;\n        }),\n        distinctUntilChanged()\n      ),\n      isSeeking\n    );\n    subscribe(\n      pipe(combineLatest(isSeeking, scrollVelocity, rangeChanged), withLatestFrom(scrollSeekConfiguration)),\n      ([[isSeeking2, velocity, range], config]) => isSeeking2 && config && config.change && config.change(velocity, range)\n    );\n    return { isSeeking, scrollSeekConfiguration, scrollVelocity, scrollSeekRangeChanged: rangeChanged };\n  },\n  tup(stateFlagsSystem),\n  { singleton: true }\n);\nconst topItemCountSystem = system(([{ topItemsIndexes }]) => {\n  const topItemCount = statefulStream(0);\n  connect(\n    pipe(\n      topItemCount,\n      filter((length) => length > 0),\n      map((length) => Array.from({ length }).map((_, index) => index))\n    ),\n    topItemsIndexes\n  );\n  return { topItemCount };\n}, tup(listStateSystem));\nconst totalListHeightSystem = system(\n  ([{ footerHeight, headerHeight, fixedHeaderHeight, fixedFooterHeight }, { listState }]) => {\n    const totalListHeightChanged = stream();\n    const totalListHeight = statefulStreamFromEmitter(\n      pipe(\n        combineLatest(footerHeight, fixedFooterHeight, headerHeight, fixedHeaderHeight, listState),\n        map(([footerHeight2, fixedFooterHeight2, headerHeight2, fixedHeaderHeight2, listState2]) => {\n          return footerHeight2 + fixedFooterHeight2 + headerHeight2 + fixedHeaderHeight2 + listState2.offsetBottom + listState2.bottom;\n        })\n      ),\n      0\n    );\n    connect(duc(totalListHeight), totalListHeightChanged);\n    return { totalListHeight, totalListHeightChanged };\n  },\n  tup(domIOSystem, listStateSystem),\n  { singleton: true }\n);\nfunction simpleMemoize(func) {\n  let called = false;\n  let result;\n  return () => {\n    if (!called) {\n      called = true;\n      result = func();\n    }\n    return result;\n  };\n}\nconst isMobileSafari = simpleMemoize(() => {\n  return /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent);\n});\nconst upwardScrollFixSystem = system(\n  ([\n    { scrollBy, scrollTop, deviation, scrollingInProgress },\n    { isScrolling, isAtBottom, scrollDirection, lastJumpDueToItemResize },\n    { listState },\n    { beforeUnshiftWith, shiftWithOffset, sizes, gap },\n    { log },\n    { recalcInProgress }\n  ]) => {\n    const deviationOffset = streamFromEmitter(\n      pipe(\n        listState,\n        withLatestFrom(lastJumpDueToItemResize),\n        scan(\n          ([, prevItems, prevTotalCount, prevTotalHeight], [{ items, totalCount, bottom, offsetBottom }, lastJumpDueToItemResize2]) => {\n            const totalHeight = bottom + offsetBottom;\n            let newDev = 0;\n            if (prevTotalCount === totalCount) {\n              if (prevItems.length > 0 && items.length > 0) {\n                const atStart = items[0].originalIndex === 0 && prevItems[0].originalIndex === 0;\n                if (!atStart) {\n                  newDev = totalHeight - prevTotalHeight;\n                  if (newDev !== 0) {\n                    newDev += lastJumpDueToItemResize2;\n                  }\n                }\n              }\n            }\n            return [newDev, items, totalCount, totalHeight];\n          },\n          [0, [], 0, 0]\n        ),\n        filter(([amount]) => amount !== 0),\n        withLatestFrom(scrollTop, scrollDirection, scrollingInProgress, isAtBottom, log, recalcInProgress),\n        filter(([, scrollTop2, scrollDirection2, scrollingInProgress2, , , recalcInProgress2]) => {\n          return !recalcInProgress2 && !scrollingInProgress2 && scrollTop2 !== 0 && scrollDirection2 === UP;\n        }),\n        map(([[amount], , , , , log2]) => {\n          log2(\"Upward scrolling compensation\", { amount }, LogLevel.DEBUG);\n          return amount;\n        })\n      )\n    );\n    function scrollByWith(offset) {\n      if (offset > 0) {\n        publish(scrollBy, { top: -offset, behavior: \"auto\" });\n        publish(deviation, 0);\n      } else {\n        publish(deviation, 0);\n        publish(scrollBy, { top: -offset, behavior: \"auto\" });\n      }\n    }\n    subscribe(pipe(deviationOffset, withLatestFrom(deviation, isScrolling)), ([offset, deviationAmount, isScrolling2]) => {\n      if (isScrolling2 && isMobileSafari()) {\n        publish(deviation, deviationAmount - offset);\n      } else {\n        scrollByWith(-offset);\n      }\n    });\n    subscribe(\n      pipe(\n        combineLatest(statefulStreamFromEmitter(isScrolling, false), deviation, recalcInProgress),\n        filter(([is, deviation2, recalc]) => !is && !recalc && deviation2 !== 0),\n        map(([_, deviation2]) => deviation2),\n        throttleTime(1)\n      ),\n      scrollByWith\n    );\n    connect(\n      pipe(\n        shiftWithOffset,\n        map((offset) => {\n          return { top: -offset };\n        })\n      ),\n      scrollBy\n    );\n    subscribe(\n      pipe(\n        beforeUnshiftWith,\n        withLatestFrom(sizes, gap),\n        map(([offset, { lastSize: defaultItemSize, groupIndices, sizeTree }, gap2]) => {\n          function getItemOffset(itemCount) {\n            return itemCount * (defaultItemSize + gap2);\n          }\n          if (groupIndices.length === 0) {\n            return getItemOffset(offset);\n          } else {\n            let amount = 0;\n            const defaultGroupSize = find(sizeTree, 0);\n            let recognizedOffsetItems = 0;\n            let groupIndex = 0;\n            while (recognizedOffsetItems < offset) {\n              recognizedOffsetItems++;\n              amount += defaultGroupSize;\n              let groupItemCount = groupIndices.length === groupIndex + 1 ? Infinity : groupIndices[groupIndex + 1] - groupIndices[groupIndex] - 1;\n              if (recognizedOffsetItems + groupItemCount > offset) {\n                amount -= defaultGroupSize;\n                groupItemCount = offset - recognizedOffsetItems + 1;\n              }\n              recognizedOffsetItems += groupItemCount;\n              amount += getItemOffset(groupItemCount);\n              groupIndex++;\n            }\n            return amount;\n          }\n        })\n      ),\n      (offset) => {\n        publish(deviation, offset);\n        requestAnimationFrame(() => {\n          publish(scrollBy, { top: offset });\n          requestAnimationFrame(() => {\n            publish(deviation, 0);\n            publish(recalcInProgress, false);\n          });\n        });\n      }\n    );\n    return { deviation };\n  },\n  tup(domIOSystem, stateFlagsSystem, listStateSystem, sizeSystem, loggerSystem, recalcSystem)\n);\nconst initialScrollTopSystem = system(\n  ([{ didMount }, { scrollTo }, { listState }]) => {\n    const initialScrollTop = statefulStream(0);\n    subscribe(\n      pipe(\n        didMount,\n        withLatestFrom(initialScrollTop),\n        filter(([, offset]) => offset !== 0),\n        map(([, offset]) => ({ top: offset }))\n      ),\n      (location) => {\n        handleNext(\n          pipe(\n            listState,\n            skip(1),\n            filter((state) => state.items.length > 1)\n          ),\n          () => {\n            requestAnimationFrame(() => {\n              publish(scrollTo, location);\n            });\n          }\n        );\n      }\n    );\n    return {\n      initialScrollTop\n    };\n  },\n  tup(propsReadySystem, domIOSystem, listStateSystem),\n  { singleton: true }\n);\nconst alignToBottomSystem = system(\n  ([{ viewportHeight }, { totalListHeight }]) => {\n    const alignToBottom = statefulStream(false);\n    const paddingTopAddition = statefulStreamFromEmitter(\n      pipe(\n        combineLatest(alignToBottom, viewportHeight, totalListHeight),\n        filter(([enabled]) => enabled),\n        map(([, viewportHeight2, totalListHeight2]) => {\n          return Math.max(0, viewportHeight2 - totalListHeight2);\n        }),\n        throttleTime(0),\n        distinctUntilChanged()\n      ),\n      0\n    );\n    return { alignToBottom, paddingTopAddition };\n  },\n  tup(domIOSystem, totalListHeightSystem),\n  { singleton: true }\n);\nconst windowScrollerSystem = system(([{ scrollTo, scrollContainerState }]) => {\n  const windowScrollContainerState = stream();\n  const windowViewportRect = stream();\n  const windowScrollTo = stream();\n  const useWindowScroll = statefulStream(false);\n  const customScrollParent = statefulStream(void 0);\n  connect(\n    pipe(\n      combineLatest(windowScrollContainerState, windowViewportRect),\n      map(([{ viewportHeight, scrollTop: windowScrollTop, scrollHeight }, { offsetTop }]) => {\n        return {\n          scrollTop: Math.max(0, windowScrollTop - offsetTop),\n          scrollHeight,\n          viewportHeight\n        };\n      })\n    ),\n    scrollContainerState\n  );\n  connect(\n    pipe(\n      scrollTo,\n      withLatestFrom(windowViewportRect),\n      map(([scrollTo2, { offsetTop }]) => {\n        return {\n          ...scrollTo2,\n          top: scrollTo2.top + offsetTop\n        };\n      })\n    ),\n    windowScrollTo\n  );\n  return {\n    // config\n    useWindowScroll,\n    customScrollParent,\n    // input\n    windowScrollContainerState,\n    windowViewportRect,\n    // signals\n    windowScrollTo\n  };\n}, tup(domIOSystem));\nconst defaultCalculateViewLocation = ({\n  itemTop: itemTop2,\n  itemBottom,\n  viewportTop,\n  viewportBottom,\n  locationParams: { behavior, align, ...rest }\n}) => {\n  if (itemTop2 < viewportTop) {\n    return { ...rest, behavior, align: align != null ? align : \"start\" };\n  }\n  if (itemBottom > viewportBottom) {\n    return { ...rest, behavior, align: align != null ? align : \"end\" };\n  }\n  return null;\n};\nconst scrollIntoViewSystem = system(\n  ([\n    { sizes, totalCount, gap },\n    { scrollTop, viewportHeight, headerHeight, fixedHeaderHeight, fixedFooterHeight, scrollingInProgress },\n    { scrollToIndex }\n  ]) => {\n    const scrollIntoView = stream();\n    connect(\n      pipe(\n        scrollIntoView,\n        withLatestFrom(sizes, viewportHeight, totalCount, headerHeight, fixedHeaderHeight, fixedFooterHeight, scrollTop),\n        withLatestFrom(gap),\n        map(([[viewLocation, sizes2, viewportHeight2, totalCount2, headerHeight2, fixedHeaderHeight2, fixedFooterHeight2, scrollTop2], gap2]) => {\n          const { done, behavior, align, calculateViewLocation = defaultCalculateViewLocation, ...rest } = viewLocation;\n          const actualIndex = originalIndexFromLocation(viewLocation, sizes2, totalCount2 - 1);\n          const itemTop2 = offsetOf(actualIndex, sizes2.offsetTree, gap2) + headerHeight2 + fixedHeaderHeight2;\n          const itemBottom = itemTop2 + findMaxKeyValue(sizes2.sizeTree, actualIndex)[1];\n          const viewportTop = scrollTop2 + fixedHeaderHeight2;\n          const viewportBottom = scrollTop2 + viewportHeight2 - fixedFooterHeight2;\n          const location = calculateViewLocation({\n            itemTop: itemTop2,\n            itemBottom,\n            viewportTop,\n            viewportBottom,\n            locationParams: { behavior, align, ...rest }\n          });\n          if (location) {\n            done && handleNext(\n              pipe(\n                scrollingInProgress,\n                filter((value) => value === false),\n                // skips the initial publish of false, and the cleanup call.\n                // but if scrollingInProgress is true, we skip the initial publish.\n                skip(getValue(scrollingInProgress) ? 1 : 2)\n              ),\n              done\n            );\n          } else {\n            done && done();\n          }\n          return location;\n        }),\n        filter((value) => value !== null)\n      ),\n      scrollToIndex\n    );\n    return {\n      scrollIntoView\n    };\n  },\n  tup(sizeSystem, domIOSystem, scrollToIndexSystem, listStateSystem, loggerSystem),\n  { singleton: true }\n);\nconst stateLoadSystem = system(([{ sizes, sizeRanges }, { scrollTop }, { initialTopMostItemIndex }, { didMount }]) => {\n  const getState = stream();\n  const restoreStateFrom = statefulStream(void 0);\n  subscribe(pipe(getState, withLatestFrom(sizes, scrollTop)), ([callback, sizes2, scrollTop2]) => {\n    const ranges = sizeTreeToRanges(sizes2.sizeTree);\n    callback({ ranges, scrollTop: scrollTop2 });\n  });\n  connect(pipe(restoreStateFrom, filter(isDefined), map(locationFromSnapshot)), initialTopMostItemIndex);\n  connect(\n    pipe(\n      didMount,\n      withLatestFrom(restoreStateFrom),\n      filter(([, state]) => state !== void 0),\n      distinctUntilChanged(),\n      map(([, snapshot]) => {\n        return snapshot.ranges;\n      })\n    ),\n    sizeRanges\n  );\n  return {\n    getState,\n    restoreStateFrom\n  };\n}, tup(sizeSystem, domIOSystem, initialTopMostItemIndexSystem, propsReadySystem));\nfunction locationFromSnapshot(snapshot) {\n  return { offset: snapshot.scrollTop, index: 0, align: \"start\" };\n}\nconst featureGroup1System = system(\n  ([\n    sizeRange,\n    initialItemCount,\n    propsReady,\n    scrollSeek,\n    totalListHeight,\n    initialScrollTopSystem2,\n    alignToBottom,\n    windowScroller,\n    scrollIntoView,\n    logger\n  ]) => {\n    return {\n      ...sizeRange,\n      ...initialItemCount,\n      ...propsReady,\n      ...scrollSeek,\n      ...totalListHeight,\n      ...initialScrollTopSystem2,\n      ...alignToBottom,\n      ...windowScroller,\n      ...scrollIntoView,\n      ...logger\n    };\n  },\n  tup(\n    sizeRangeSystem,\n    initialItemCountSystem,\n    propsReadySystem,\n    scrollSeekSystem,\n    totalListHeightSystem,\n    initialScrollTopSystem,\n    alignToBottomSystem,\n    windowScrollerSystem,\n    scrollIntoViewSystem,\n    loggerSystem\n  )\n);\nconst listSystem = system(\n  ([\n    {\n      totalCount,\n      sizeRanges,\n      fixedItemSize,\n      defaultItemSize,\n      trackItemSizes,\n      itemSize,\n      data,\n      firstItemIndex,\n      groupIndices,\n      statefulTotalCount,\n      gap,\n      sizes\n    },\n    { initialTopMostItemIndex, scrolledToInitialItem },\n    domIO,\n    stateLoad,\n    followOutput,\n    { listState, topItemsIndexes, ...flags },\n    { scrollToIndex },\n    _,\n    { topItemCount },\n    { groupCounts },\n    featureGroup1\n  ]) => {\n    connect(flags.rangeChanged, featureGroup1.scrollSeekRangeChanged);\n    connect(\n      pipe(\n        featureGroup1.windowViewportRect,\n        map((value) => value.visibleHeight)\n      ),\n      domIO.viewportHeight\n    );\n    return {\n      // input\n      totalCount,\n      data,\n      firstItemIndex,\n      sizeRanges,\n      initialTopMostItemIndex,\n      scrolledToInitialItem,\n      topItemsIndexes,\n      topItemCount,\n      groupCounts,\n      fixedItemHeight: fixedItemSize,\n      defaultItemHeight: defaultItemSize,\n      gap,\n      ...followOutput,\n      // output\n      statefulTotalCount,\n      listState,\n      scrollToIndex,\n      trackItemSizes,\n      itemSize,\n      groupIndices,\n      // exported from stateFlagsSystem\n      ...flags,\n      // the bag of IO from featureGroup1System\n      ...featureGroup1,\n      ...domIO,\n      sizes,\n      ...stateLoad\n    };\n  },\n  tup(\n    sizeSystem,\n    initialTopMostItemIndexSystem,\n    domIOSystem,\n    stateLoadSystem,\n    followOutputSystem,\n    listStateSystem,\n    scrollToIndexSystem,\n    upwardScrollFixSystem,\n    topItemCountSystem,\n    groupedListSystem,\n    featureGroup1System\n  )\n);\nconst WEBKIT_STICKY = \"-webkit-sticky\";\nconst STICKY = \"sticky\";\nconst positionStickyCssValue = simpleMemoize(() => {\n  if (typeof document === \"undefined\") {\n    return STICKY;\n  }\n  const node = document.createElement(\"div\");\n  node.style.position = WEBKIT_STICKY;\n  return node.style.position === WEBKIT_STICKY ? WEBKIT_STICKY : STICKY;\n});\nfunction useWindowViewportRectRef(callback, customScrollParent) {\n  const viewportInfo = React.useRef(null);\n  const calculateInfo = React.useCallback(\n    (element) => {\n      if (element === null || !element.offsetParent) {\n        return;\n      }\n      const rect = element.getBoundingClientRect();\n      const visibleWidth = rect.width;\n      let visibleHeight, offsetTop;\n      if (customScrollParent) {\n        const customScrollParentRect = customScrollParent.getBoundingClientRect();\n        const deltaTop = rect.top - customScrollParentRect.top;\n        visibleHeight = customScrollParentRect.height - Math.max(0, deltaTop);\n        offsetTop = deltaTop + customScrollParent.scrollTop;\n      } else {\n        visibleHeight = window.innerHeight - Math.max(0, rect.top);\n        offsetTop = rect.top + window.pageYOffset;\n      }\n      viewportInfo.current = {\n        offsetTop,\n        visibleHeight,\n        visibleWidth\n      };\n      callback(viewportInfo.current);\n    },\n    [callback, customScrollParent]\n  );\n  const { callbackRef, ref } = useSizeWithElRef(calculateInfo);\n  const scrollAndResizeEventHandler = React.useCallback(() => {\n    calculateInfo(ref.current);\n  }, [calculateInfo, ref]);\n  React.useEffect(() => {\n    if (customScrollParent) {\n      customScrollParent.addEventListener(\"scroll\", scrollAndResizeEventHandler);\n      const observer = new ResizeObserver(scrollAndResizeEventHandler);\n      observer.observe(customScrollParent);\n      return () => {\n        customScrollParent.removeEventListener(\"scroll\", scrollAndResizeEventHandler);\n        observer.unobserve(customScrollParent);\n      };\n    } else {\n      window.addEventListener(\"scroll\", scrollAndResizeEventHandler);\n      window.addEventListener(\"resize\", scrollAndResizeEventHandler);\n      return () => {\n        window.removeEventListener(\"scroll\", scrollAndResizeEventHandler);\n        window.removeEventListener(\"resize\", scrollAndResizeEventHandler);\n      };\n    }\n  }, [scrollAndResizeEventHandler, customScrollParent]);\n  return callbackRef;\n}\nconst VirtuosoMockContext = React.createContext(void 0);\nconst VirtuosoGridMockContext = React.createContext(void 0);\nfunction identity(value) {\n  return value;\n}\nconst listComponentPropsSystem = /* @__PURE__ */ system(() => {\n  const itemContent = statefulStream((index) => `Item ${index}`);\n  const context = statefulStream(null);\n  const groupContent = statefulStream((index) => `Group ${index}`);\n  const components = statefulStream({});\n  const computeItemKey = statefulStream(identity);\n  const headerFooterTag = statefulStream(\"div\");\n  const scrollerRef = statefulStream(noop);\n  const distinctProp = (propName, defaultValue = null) => {\n    return statefulStreamFromEmitter(\n      pipe(\n        components,\n        map((components2) => components2[propName]),\n        distinctUntilChanged()\n      ),\n      defaultValue\n    );\n  };\n  return {\n    context,\n    itemContent,\n    groupContent,\n    components,\n    computeItemKey,\n    headerFooterTag,\n    scrollerRef,\n    FooterComponent: distinctProp(\"Footer\"),\n    HeaderComponent: distinctProp(\"Header\"),\n    TopItemListComponent: distinctProp(\"TopItemList\"),\n    ListComponent: distinctProp(\"List\", \"div\"),\n    ItemComponent: distinctProp(\"Item\", \"div\"),\n    GroupComponent: distinctProp(\"Group\", \"div\"),\n    ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n    EmptyPlaceholder: distinctProp(\"EmptyPlaceholder\"),\n    ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\")\n  };\n});\nconst combinedSystem$2 = /* @__PURE__ */ system(([listSystem2, propsSystem]) => {\n  return { ...listSystem2, ...propsSystem };\n}, tup(listSystem, listComponentPropsSystem));\nconst DefaultScrollSeekPlaceholder$1 = ({ height }) => /* @__PURE__ */ React.createElement(\"div\", { style: { height } });\nconst GROUP_STYLE = { position: positionStickyCssValue(), zIndex: 1, overflowAnchor: \"none\" };\nconst ITEM_STYLE = { overflowAnchor: \"none\" };\nconst Items$1 = /* @__PURE__ */ React.memo(function VirtuosoItems({ showTopList = false }) {\n  const listState = useEmitterValue$2(\"listState\");\n  const sizeRanges = usePublisher$2(\"sizeRanges\");\n  const useWindowScroll = useEmitterValue$2(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n  const windowScrollContainerStateCallback = usePublisher$2(\"windowScrollContainerState\");\n  const _scrollContainerStateCallback = usePublisher$2(\"scrollContainerState\");\n  const scrollContainerStateCallback = customScrollParent || useWindowScroll ? windowScrollContainerStateCallback : _scrollContainerStateCallback;\n  const itemContent = useEmitterValue$2(\"itemContent\");\n  const context = useEmitterValue$2(\"context\");\n  const groupContent = useEmitterValue$2(\"groupContent\");\n  const trackItemSizes = useEmitterValue$2(\"trackItemSizes\");\n  const itemSize = useEmitterValue$2(\"itemSize\");\n  const log = useEmitterValue$2(\"log\");\n  const listGap = usePublisher$2(\"gap\");\n  const { callbackRef } = useChangedListContentsSizes(\n    sizeRanges,\n    itemSize,\n    trackItemSizes,\n    showTopList ? noop : scrollContainerStateCallback,\n    log,\n    listGap,\n    customScrollParent\n  );\n  const [deviation, setDeviation] = React.useState(0);\n  useEmitter$2(\"deviation\", (value) => {\n    if (deviation !== value) {\n      setDeviation(value);\n    }\n  });\n  const EmptyPlaceholder = useEmitterValue$2(\"EmptyPlaceholder\");\n  const ScrollSeekPlaceholder = useEmitterValue$2(\"ScrollSeekPlaceholder\") || DefaultScrollSeekPlaceholder$1;\n  const ListComponent = useEmitterValue$2(\"ListComponent\");\n  const ItemComponent = useEmitterValue$2(\"ItemComponent\");\n  const GroupComponent = useEmitterValue$2(\"GroupComponent\");\n  const computeItemKey = useEmitterValue$2(\"computeItemKey\");\n  const isSeeking = useEmitterValue$2(\"isSeeking\");\n  const hasGroups2 = useEmitterValue$2(\"groupIndices\").length > 0;\n  const paddingTopAddition = useEmitterValue$2(\"paddingTopAddition\");\n  const scrolledToInitialItem = useEmitterValue$2(\"scrolledToInitialItem\");\n  const containerStyle = showTopList ? {} : {\n    boxSizing: \"border-box\",\n    paddingTop: listState.offsetTop + paddingTopAddition,\n    paddingBottom: listState.offsetBottom,\n    marginTop: deviation,\n    ...scrolledToInitialItem ? {} : { visibility: \"hidden\" }\n  };\n  if (!showTopList && listState.totalCount === 0 && EmptyPlaceholder) {\n    return React.createElement(EmptyPlaceholder, contextPropIfNotDomElement(EmptyPlaceholder, context));\n  }\n  return React.createElement(\n    ListComponent,\n    {\n      ...contextPropIfNotDomElement(ListComponent, context),\n      ref: callbackRef,\n      style: containerStyle,\n      \"data-test-id\": showTopList ? \"virtuoso-top-item-list\" : \"virtuoso-item-list\"\n    },\n    (showTopList ? listState.topItems : listState.items).map((item) => {\n      const index = item.originalIndex;\n      const key = computeItemKey(index + listState.firstItemIndex, item.data, context);\n      if (isSeeking) {\n        return React.createElement(ScrollSeekPlaceholder, {\n          ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n          key,\n          index: item.index,\n          height: item.size,\n          type: item.type || \"item\",\n          ...item.type === \"group\" ? {} : { groupIndex: item.groupIndex }\n        });\n      }\n      if (item.type === \"group\") {\n        return React.createElement(\n          GroupComponent,\n          {\n            ...contextPropIfNotDomElement(GroupComponent, context),\n            key,\n            \"data-index\": index,\n            \"data-known-size\": item.size,\n            \"data-item-index\": item.index,\n            style: GROUP_STYLE\n          },\n          groupContent(item.index, context)\n        );\n      } else {\n        return React.createElement(\n          ItemComponent,\n          {\n            ...contextPropIfNotDomElement(ItemComponent, context),\n            key,\n            \"data-index\": index,\n            \"data-known-size\": item.size,\n            \"data-item-index\": item.index,\n            \"data-item-group-index\": item.groupIndex,\n            item: item.data,\n            style: ITEM_STYLE\n          },\n          hasGroups2 ? itemContent(item.index, item.groupIndex, item.data, context) : itemContent(item.index, item.data, context)\n        );\n      }\n    })\n  );\n});\nconst scrollerStyle = {\n  height: \"100%\",\n  outline: \"none\",\n  overflowY: \"auto\",\n  position: \"relative\",\n  WebkitOverflowScrolling: \"touch\"\n};\nconst viewportStyle = {\n  width: \"100%\",\n  height: \"100%\",\n  position: \"absolute\",\n  top: 0\n};\nconst topItemListStyle = {\n  width: \"100%\",\n  position: positionStickyCssValue(),\n  top: 0,\n  zIndex: 1\n};\nfunction contextPropIfNotDomElement(element, context) {\n  if (typeof element === \"string\") {\n    return void 0;\n  }\n  return { context };\n}\nconst Header$1 = /* @__PURE__ */ React.memo(function VirtuosoHeader() {\n  const Header2 = useEmitterValue$2(\"HeaderComponent\");\n  const headerHeight = usePublisher$2(\"headerHeight\");\n  const headerFooterTag = useEmitterValue$2(\"headerFooterTag\");\n  const ref = useSize((el) => headerHeight(correctItemSize(el, \"height\")));\n  const context = useEmitterValue$2(\"context\");\n  return Header2 ? React.createElement(headerFooterTag, { ref }, React.createElement(Header2, contextPropIfNotDomElement(Header2, context))) : null;\n});\nconst Footer$1 = /* @__PURE__ */ React.memo(function VirtuosoFooter() {\n  const Footer2 = useEmitterValue$2(\"FooterComponent\");\n  const footerHeight = usePublisher$2(\"footerHeight\");\n  const headerFooterTag = useEmitterValue$2(\"headerFooterTag\");\n  const ref = useSize((el) => footerHeight(correctItemSize(el, \"height\")));\n  const context = useEmitterValue$2(\"context\");\n  return Footer2 ? React.createElement(headerFooterTag, { ref }, React.createElement(Footer2, contextPropIfNotDomElement(Footer2, context))) : null;\n});\nfunction buildScroller({ usePublisher: usePublisher2, useEmitter: useEmitter2, useEmitterValue: useEmitterValue2 }) {\n  const Scroller2 = React.memo(function VirtuosoScroller({ style, children, ...props }) {\n    const scrollContainerStateCallback = usePublisher2(\"scrollContainerState\");\n    const ScrollerComponent = useEmitterValue2(\"ScrollerComponent\");\n    const smoothScrollTargetReached = usePublisher2(\"smoothScrollTargetReached\");\n    const scrollerRefCallback = useEmitterValue2(\"scrollerRef\");\n    const context = useEmitterValue2(\"context\");\n    const { scrollerRef, scrollByCallback, scrollToCallback } = useScrollTop(\n      scrollContainerStateCallback,\n      smoothScrollTargetReached,\n      ScrollerComponent,\n      scrollerRefCallback\n    );\n    useEmitter2(\"scrollTo\", scrollToCallback);\n    useEmitter2(\"scrollBy\", scrollByCallback);\n    return React.createElement(\n      ScrollerComponent,\n      {\n        ref: scrollerRef,\n        style: { ...scrollerStyle, ...style },\n        \"data-test-id\": \"virtuoso-scroller\",\n        \"data-virtuoso-scroller\": true,\n        tabIndex: 0,\n        ...props,\n        ...contextPropIfNotDomElement(ScrollerComponent, context)\n      },\n      children\n    );\n  });\n  return Scroller2;\n}\nfunction buildWindowScroller({ usePublisher: usePublisher2, useEmitter: useEmitter2, useEmitterValue: useEmitterValue2 }) {\n  const Scroller2 = React.memo(function VirtuosoWindowScroller({ style, children, ...props }) {\n    const scrollContainerStateCallback = usePublisher2(\"windowScrollContainerState\");\n    const ScrollerComponent = useEmitterValue2(\"ScrollerComponent\");\n    const smoothScrollTargetReached = usePublisher2(\"smoothScrollTargetReached\");\n    const totalListHeight = useEmitterValue2(\"totalListHeight\");\n    const deviation = useEmitterValue2(\"deviation\");\n    const customScrollParent = useEmitterValue2(\"customScrollParent\");\n    const context = useEmitterValue2(\"context\");\n    const { scrollerRef, scrollByCallback, scrollToCallback } = useScrollTop(\n      scrollContainerStateCallback,\n      smoothScrollTargetReached,\n      ScrollerComponent,\n      noop,\n      customScrollParent\n    );\n    useIsomorphicLayoutEffect$1(() => {\n      scrollerRef.current = customScrollParent ? customScrollParent : window;\n      return () => {\n        scrollerRef.current = null;\n      };\n    }, [scrollerRef, customScrollParent]);\n    useEmitter2(\"windowScrollTo\", scrollToCallback);\n    useEmitter2(\"scrollBy\", scrollByCallback);\n    return React.createElement(\n      ScrollerComponent,\n      {\n        style: { position: \"relative\", ...style, ...totalListHeight !== 0 ? { height: totalListHeight + deviation } : {} },\n        \"data-virtuoso-scroller\": true,\n        ...props,\n        ...contextPropIfNotDomElement(ScrollerComponent, context)\n      },\n      children\n    );\n  });\n  return Scroller2;\n}\nconst Viewport$2 = ({ children }) => {\n  const ctx = React.useContext(VirtuosoMockContext);\n  const viewportHeight = usePublisher$2(\"viewportHeight\");\n  const fixedItemHeight = usePublisher$2(\"fixedItemHeight\");\n  const viewportRef = useSize(compose(viewportHeight, (el) => correctItemSize(el, \"height\")));\n  React.useEffect(() => {\n    if (ctx) {\n      viewportHeight(ctx.viewportHeight);\n      fixedItemHeight(ctx.itemHeight);\n    }\n  }, [ctx, viewportHeight, fixedItemHeight]);\n  return /* @__PURE__ */ React.createElement(\"div\", { style: viewportStyle, ref: viewportRef, \"data-viewport-type\": \"element\" }, children);\n};\nconst WindowViewport$2 = ({ children }) => {\n  const ctx = React.useContext(VirtuosoMockContext);\n  const windowViewportRect = usePublisher$2(\"windowViewportRect\");\n  const fixedItemHeight = usePublisher$2(\"fixedItemHeight\");\n  const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent);\n  React.useEffect(() => {\n    if (ctx) {\n      fixedItemHeight(ctx.itemHeight);\n      windowViewportRect({ offsetTop: 0, visibleHeight: ctx.viewportHeight, visibleWidth: 100 });\n    }\n  }, [ctx, windowViewportRect, fixedItemHeight]);\n  return /* @__PURE__ */ React.createElement(\"div\", { ref: viewportRef, style: viewportStyle, \"data-viewport-type\": \"window\" }, children);\n};\nconst TopItemListContainer = ({ children }) => {\n  const TopItemList = useEmitterValue$2(\"TopItemListComponent\");\n  const headerHeight = useEmitterValue$2(\"headerHeight\");\n  const style = { ...topItemListStyle, marginTop: `${headerHeight}px` };\n  const context = useEmitterValue$2(\"context\");\n  return React.createElement(TopItemList || \"div\", { style, context }, children);\n};\nconst ListRoot = /* @__PURE__ */ React.memo(function VirtuosoRoot(props) {\n  const useWindowScroll = useEmitterValue$2(\"useWindowScroll\");\n  const showTopList = useEmitterValue$2(\"topItemsIndexes\").length > 0;\n  const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller$2 : Scroller$2;\n  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport$2 : Viewport$2;\n  return /* @__PURE__ */ React.createElement(TheScroller, { ...props }, showTopList && /* @__PURE__ */ React.createElement(TopItemListContainer, null, /* @__PURE__ */ React.createElement(Items$1, { showTopList: true })), /* @__PURE__ */ React.createElement(TheViewport, null, /* @__PURE__ */ React.createElement(Header$1, null), /* @__PURE__ */ React.createElement(Items$1, null), /* @__PURE__ */ React.createElement(Footer$1, null)));\n});\nconst {\n  Component: List,\n  usePublisher: usePublisher$2,\n  useEmitterValue: useEmitterValue$2,\n  useEmitter: useEmitter$2\n} = /* @__PURE__ */ systemToComponent(\n  combinedSystem$2,\n  {\n    required: {},\n    optional: {\n      restoreStateFrom: \"restoreStateFrom\",\n      context: \"context\",\n      followOutput: \"followOutput\",\n      itemContent: \"itemContent\",\n      groupContent: \"groupContent\",\n      overscan: \"overscan\",\n      increaseViewportBy: \"increaseViewportBy\",\n      totalCount: \"totalCount\",\n      groupCounts: \"groupCounts\",\n      topItemCount: \"topItemCount\",\n      firstItemIndex: \"firstItemIndex\",\n      initialTopMostItemIndex: \"initialTopMostItemIndex\",\n      components: \"components\",\n      atBottomThreshold: \"atBottomThreshold\",\n      atTopThreshold: \"atTopThreshold\",\n      computeItemKey: \"computeItemKey\",\n      defaultItemHeight: \"defaultItemHeight\",\n      fixedItemHeight: \"fixedItemHeight\",\n      itemSize: \"itemSize\",\n      scrollSeekConfiguration: \"scrollSeekConfiguration\",\n      headerFooterTag: \"headerFooterTag\",\n      data: \"data\",\n      initialItemCount: \"initialItemCount\",\n      initialScrollTop: \"initialScrollTop\",\n      alignToBottom: \"alignToBottom\",\n      useWindowScroll: \"useWindowScroll\",\n      customScrollParent: \"customScrollParent\",\n      scrollerRef: \"scrollerRef\",\n      logLevel: \"logLevel\"\n    },\n    methods: {\n      scrollToIndex: \"scrollToIndex\",\n      scrollIntoView: \"scrollIntoView\",\n      scrollTo: \"scrollTo\",\n      scrollBy: \"scrollBy\",\n      autoscrollToBottom: \"autoscrollToBottom\",\n      getState: \"getState\"\n    },\n    events: {\n      isScrolling: \"isScrolling\",\n      endReached: \"endReached\",\n      startReached: \"startReached\",\n      rangeChanged: \"rangeChanged\",\n      atBottomStateChange: \"atBottomStateChange\",\n      atTopStateChange: \"atTopStateChange\",\n      totalListHeightChanged: \"totalListHeightChanged\",\n      itemsRendered: \"itemsRendered\",\n      groupIndices: \"groupIndices\"\n    }\n  },\n  ListRoot\n);\nconst Scroller$2 = /* @__PURE__ */ buildScroller({ usePublisher: usePublisher$2, useEmitterValue: useEmitterValue$2, useEmitter: useEmitter$2 });\nconst WindowScroller$2 = /* @__PURE__ */ buildWindowScroller({ usePublisher: usePublisher$2, useEmitterValue: useEmitterValue$2, useEmitter: useEmitter$2 });\nconst Virtuoso = List;\nconst GroupedVirtuoso = List;\nconst INITIAL_GRID_STATE = {\n  items: [],\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0,\n  bottom: 0,\n  itemHeight: 0,\n  itemWidth: 0\n};\nconst PROBE_GRID_STATE = {\n  items: [{ index: 0 }],\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0,\n  bottom: 0,\n  itemHeight: 0,\n  itemWidth: 0\n};\nconst { round, ceil, floor, min, max } = Math;\nfunction buildProbeGridState(items) {\n  return {\n    ...PROBE_GRID_STATE,\n    items\n  };\n}\nfunction buildItems(startIndex, endIndex, data) {\n  return Array.from({ length: endIndex - startIndex + 1 }).map(\n    (_, i) => ({ index: i + startIndex, data: data == null ? void 0 : data[i + startIndex] })\n  );\n}\nfunction gapComparator(prev, next) {\n  return prev && prev.column === next.column && prev.row === next.row;\n}\nfunction dimensionComparator(prev, next) {\n  return prev && prev.width === next.width && prev.height === next.height;\n}\nconst gridSystem = /* @__PURE__ */ system(\n  ([\n    { overscan, visibleRange, listBoundary },\n    { scrollTop, viewportHeight, scrollBy, scrollTo, smoothScrollTargetReached, scrollContainerState, footerHeight, headerHeight },\n    stateFlags,\n    scrollSeek,\n    { propsReady, didMount },\n    { windowViewportRect, windowScrollTo, useWindowScroll, customScrollParent, windowScrollContainerState },\n    log\n  ]) => {\n    const totalCount = statefulStream(0);\n    const initialItemCount = statefulStream(0);\n    const gridState = statefulStream(INITIAL_GRID_STATE);\n    const viewportDimensions = statefulStream({ height: 0, width: 0 });\n    const itemDimensions = statefulStream({ height: 0, width: 0 });\n    const scrollToIndex = stream();\n    const scrollHeight = stream();\n    const deviation = statefulStream(0);\n    const data = statefulStream(void 0);\n    const gap = statefulStream({ row: 0, column: 0 });\n    connect(\n      pipe(\n        didMount,\n        withLatestFrom(initialItemCount, data),\n        filter(([didMount2, count]) => didMount2 && count !== 0),\n        map(([, count, data2]) => {\n          return {\n            items: buildItems(0, count - 1, data2),\n            top: 0,\n            bottom: 0,\n            offsetBottom: 0,\n            offsetTop: 0,\n            itemHeight: 0,\n            itemWidth: 0\n          };\n        })\n      ),\n      gridState\n    );\n    connect(\n      pipe(\n        combineLatest(\n          duc(totalCount),\n          visibleRange,\n          duc(gap, gapComparator),\n          duc(itemDimensions, dimensionComparator),\n          duc(viewportDimensions, dimensionComparator),\n          data\n        ),\n        map(([totalCount2, [startOffset, endOffset], gap2, item, viewport, data2]) => {\n          const { row: rowGap, column: columnGap } = gap2;\n          const { height: itemHeight, width: itemWidth } = item;\n          const { width: viewportWidth } = viewport;\n          if (totalCount2 === 0 || viewportWidth === 0) {\n            return INITIAL_GRID_STATE;\n          }\n          if (itemWidth === 0) {\n            return buildProbeGridState(buildItems(0, 0, data2));\n          }\n          const perRow = itemsPerRow(viewportWidth, itemWidth, columnGap);\n          let startIndex = perRow * floor((startOffset + rowGap) / (itemHeight + rowGap));\n          let endIndex = perRow * ceil((endOffset + rowGap) / (itemHeight + rowGap)) - 1;\n          endIndex = min(totalCount2 - 1, max(endIndex, perRow - 1));\n          startIndex = min(endIndex, max(0, startIndex));\n          const items = buildItems(startIndex, endIndex, data2);\n          const { top, bottom } = gridLayout(viewport, gap2, item, items);\n          const rowCount = ceil(totalCount2 / perRow);\n          const totalHeight = rowCount * itemHeight + (rowCount - 1) * rowGap;\n          const offsetBottom = totalHeight - bottom;\n          return { items, offsetTop: top, offsetBottom, top, bottom, itemHeight, itemWidth };\n        })\n      ),\n      gridState\n    );\n    connect(\n      pipe(\n        data,\n        filter(isDefined),\n        map((data2) => data2.length)\n      ),\n      totalCount\n    );\n    connect(\n      pipe(\n        viewportDimensions,\n        map(({ height }) => height)\n      ),\n      viewportHeight\n    );\n    connect(\n      pipe(\n        combineLatest(viewportDimensions, itemDimensions, gridState, gap),\n        map(([viewportDimensions2, item, { items }, gap2]) => {\n          const { top, bottom } = gridLayout(viewportDimensions2, gap2, item, items);\n          return [top, bottom];\n        }),\n        distinctUntilChanged(tupleComparator)\n      ),\n      listBoundary\n    );\n    const hasScrolled = statefulStream(false);\n    connect(\n      pipe(\n        scrollTop,\n        withLatestFrom(hasScrolled),\n        map(([scrollTop2, hasScrolled2]) => {\n          return hasScrolled2 || scrollTop2 !== 0;\n        })\n      ),\n      hasScrolled\n    );\n    const endReached = streamFromEmitter(\n      pipe(\n        duc(gridState),\n        filter(({ items }) => items.length > 0),\n        withLatestFrom(totalCount, hasScrolled),\n        filter(([{ items }, totalCount2, hasScrolled2]) => hasScrolled2 && items[items.length - 1].index === totalCount2 - 1),\n        map(([, totalCount2]) => totalCount2 - 1),\n        distinctUntilChanged()\n      )\n    );\n    const startReached = streamFromEmitter(\n      pipe(\n        duc(gridState),\n        filter(({ items }) => {\n          return items.length > 0 && items[0].index === 0;\n        }),\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        mapTo(0),\n        distinctUntilChanged()\n      )\n    );\n    const rangeChanged = streamFromEmitter(\n      pipe(\n        duc(gridState),\n        filter(({ items }) => items.length > 0),\n        map(({ items }) => {\n          return {\n            startIndex: items[0].index,\n            endIndex: items[items.length - 1].index\n          };\n        }),\n        distinctUntilChanged(rangeComparator)\n      )\n    );\n    connect(rangeChanged, scrollSeek.scrollSeekRangeChanged);\n    connect(\n      pipe(\n        scrollToIndex,\n        withLatestFrom(viewportDimensions, itemDimensions, totalCount, gap),\n        map(([location, viewport, item, totalCount2, gap2]) => {\n          const normalLocation = normalizeIndexLocation(location);\n          const { align, behavior, offset } = normalLocation;\n          let index = normalLocation.index;\n          if (index === \"LAST\") {\n            index = totalCount2 - 1;\n          }\n          index = max(0, index, min(totalCount2 - 1, index));\n          let top = itemTop(viewport, gap2, item, index);\n          if (align === \"end\") {\n            top = round(top - viewport.height + item.height);\n          } else if (align === \"center\") {\n            top = round(top - viewport.height / 2 + item.height / 2);\n          }\n          if (offset) {\n            top += offset;\n          }\n          return { top, behavior };\n        })\n      ),\n      scrollTo\n    );\n    const totalListHeight = statefulStreamFromEmitter(\n      pipe(\n        gridState,\n        map((gridState2) => {\n          return gridState2.offsetBottom + gridState2.bottom;\n        })\n      ),\n      0\n    );\n    connect(\n      pipe(\n        windowViewportRect,\n        map((viewportInfo) => ({ width: viewportInfo.visibleWidth, height: viewportInfo.visibleHeight }))\n      ),\n      viewportDimensions\n    );\n    return {\n      // input\n      data,\n      totalCount,\n      viewportDimensions,\n      itemDimensions,\n      scrollTop,\n      scrollHeight,\n      overscan,\n      scrollBy,\n      scrollTo,\n      scrollToIndex,\n      smoothScrollTargetReached,\n      windowViewportRect,\n      windowScrollTo,\n      useWindowScroll,\n      customScrollParent,\n      windowScrollContainerState,\n      deviation,\n      scrollContainerState,\n      footerHeight,\n      headerHeight,\n      initialItemCount,\n      gap,\n      ...scrollSeek,\n      // output\n      gridState,\n      totalListHeight,\n      ...stateFlags,\n      startReached,\n      endReached,\n      rangeChanged,\n      propsReady,\n      ...log\n    };\n  },\n  tup(sizeRangeSystem, domIOSystem, stateFlagsSystem, scrollSeekSystem, propsReadySystem, windowScrollerSystem, loggerSystem)\n);\nfunction gridLayout(viewport, gap, item, items) {\n  const { height: itemHeight } = item;\n  if (itemHeight === void 0 || items.length === 0) {\n    return { top: 0, bottom: 0 };\n  }\n  const top = itemTop(viewport, gap, item, items[0].index);\n  const bottom = itemTop(viewport, gap, item, items[items.length - 1].index) + itemHeight;\n  return { top, bottom };\n}\nfunction itemTop(viewport, gap, item, index) {\n  const perRow = itemsPerRow(viewport.width, item.width, gap.column);\n  const rowCount = floor(index / perRow);\n  const top = rowCount * item.height + max(0, rowCount - 1) * gap.row;\n  return top > 0 ? top + gap.row : top;\n}\nfunction itemsPerRow(viewportWidth, itemWidth, gap) {\n  return max(1, floor((viewportWidth + gap) / (floor(itemWidth) + gap)));\n}\nconst gridComponentPropsSystem = /* @__PURE__ */ system(() => {\n  const itemContent = statefulStream((index) => `Item ${index}`);\n  const components = statefulStream({});\n  const context = statefulStream(null);\n  const itemClassName = statefulStream(\"virtuoso-grid-item\");\n  const listClassName = statefulStream(\"virtuoso-grid-list\");\n  const computeItemKey = statefulStream(identity);\n  const headerFooterTag = statefulStream(\"div\");\n  const scrollerRef = statefulStream(noop);\n  const distinctProp = (propName, defaultValue = null) => {\n    return statefulStreamFromEmitter(\n      pipe(\n        components,\n        map((components2) => components2[propName]),\n        distinctUntilChanged()\n      ),\n      defaultValue\n    );\n  };\n  return {\n    context,\n    itemContent,\n    components,\n    computeItemKey,\n    itemClassName,\n    listClassName,\n    headerFooterTag,\n    scrollerRef,\n    FooterComponent: distinctProp(\"Footer\"),\n    HeaderComponent: distinctProp(\"Header\"),\n    ListComponent: distinctProp(\"List\", \"div\"),\n    ItemComponent: distinctProp(\"Item\", \"div\"),\n    ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n    ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\", \"div\")\n  };\n});\nconst combinedSystem$1 = /* @__PURE__ */ system(([gridSystem2, gridComponentPropsSystem2]) => {\n  return { ...gridSystem2, ...gridComponentPropsSystem2 };\n}, tup(gridSystem, gridComponentPropsSystem));\nconst GridItems = /* @__PURE__ */ React.memo(function GridItems2() {\n  const gridState = useEmitterValue$1(\"gridState\");\n  const listClassName = useEmitterValue$1(\"listClassName\");\n  const itemClassName = useEmitterValue$1(\"itemClassName\");\n  const itemContent = useEmitterValue$1(\"itemContent\");\n  const computeItemKey = useEmitterValue$1(\"computeItemKey\");\n  const isSeeking = useEmitterValue$1(\"isSeeking\");\n  const scrollHeightCallback = usePublisher$1(\"scrollHeight\");\n  const ItemComponent = useEmitterValue$1(\"ItemComponent\");\n  const ListComponent = useEmitterValue$1(\"ListComponent\");\n  const ScrollSeekPlaceholder = useEmitterValue$1(\"ScrollSeekPlaceholder\");\n  const context = useEmitterValue$1(\"context\");\n  const itemDimensions = usePublisher$1(\"itemDimensions\");\n  const gridGap = usePublisher$1(\"gap\");\n  const log = useEmitterValue$1(\"log\");\n  const listRef = useSize((el) => {\n    const scrollHeight = el.parentElement.parentElement.scrollHeight;\n    scrollHeightCallback(scrollHeight);\n    const firstItem = el.firstChild;\n    if (firstItem) {\n      itemDimensions(firstItem.getBoundingClientRect());\n    }\n    gridGap({\n      row: resolveGapValue(\"row-gap\", getComputedStyle(el).rowGap, log),\n      column: resolveGapValue(\"column-gap\", getComputedStyle(el).columnGap, log)\n    });\n  });\n  return React.createElement(\n    ListComponent,\n    {\n      ref: listRef,\n      className: listClassName,\n      ...contextPropIfNotDomElement(ListComponent, context),\n      style: { paddingTop: gridState.offsetTop, paddingBottom: gridState.offsetBottom },\n      \"data-test-id\": \"virtuoso-item-list\"\n    },\n    gridState.items.map((item) => {\n      const key = computeItemKey(item.index, item.data, context);\n      return isSeeking ? React.createElement(ScrollSeekPlaceholder, {\n        key,\n        ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n        index: item.index,\n        height: gridState.itemHeight,\n        width: gridState.itemWidth\n      }) : React.createElement(\n        ItemComponent,\n        { ...contextPropIfNotDomElement(ItemComponent, context), className: itemClassName, \"data-index\": item.index, key },\n        itemContent(item.index, item.data, context)\n      );\n    })\n  );\n});\nconst Header = React.memo(function VirtuosoHeader2() {\n  const Header2 = useEmitterValue$1(\"HeaderComponent\");\n  const headerHeight = usePublisher$1(\"headerHeight\");\n  const headerFooterTag = useEmitterValue$1(\"headerFooterTag\");\n  const ref = useSize((el) => headerHeight(correctItemSize(el, \"height\")));\n  const context = useEmitterValue$1(\"context\");\n  return Header2 ? React.createElement(headerFooterTag, { ref }, React.createElement(Header2, contextPropIfNotDomElement(Header2, context))) : null;\n});\nconst Footer = React.memo(function VirtuosoGridFooter() {\n  const Footer2 = useEmitterValue$1(\"FooterComponent\");\n  const footerHeight = usePublisher$1(\"footerHeight\");\n  const headerFooterTag = useEmitterValue$1(\"headerFooterTag\");\n  const ref = useSize((el) => footerHeight(correctItemSize(el, \"height\")));\n  const context = useEmitterValue$1(\"context\");\n  return Footer2 ? React.createElement(headerFooterTag, { ref }, React.createElement(Footer2, contextPropIfNotDomElement(Footer2, context))) : null;\n});\nconst Viewport$1 = ({ children }) => {\n  const ctx = React.useContext(VirtuosoGridMockContext);\n  const itemDimensions = usePublisher$1(\"itemDimensions\");\n  const viewportDimensions = usePublisher$1(\"viewportDimensions\");\n  const viewportRef = useSize((el) => {\n    viewportDimensions(el.getBoundingClientRect());\n  });\n  React.useEffect(() => {\n    if (ctx) {\n      viewportDimensions({ height: ctx.viewportHeight, width: ctx.viewportWidth });\n      itemDimensions({ height: ctx.itemHeight, width: ctx.itemWidth });\n    }\n  }, [ctx, viewportDimensions, itemDimensions]);\n  return /* @__PURE__ */ React.createElement(\"div\", { style: viewportStyle, ref: viewportRef }, children);\n};\nconst WindowViewport$1 = ({ children }) => {\n  const ctx = React.useContext(VirtuosoGridMockContext);\n  const windowViewportRect = usePublisher$1(\"windowViewportRect\");\n  const itemDimensions = usePublisher$1(\"itemDimensions\");\n  const customScrollParent = useEmitterValue$1(\"customScrollParent\");\n  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent);\n  React.useEffect(() => {\n    if (ctx) {\n      itemDimensions({ height: ctx.itemHeight, width: ctx.itemWidth });\n      windowViewportRect({ offsetTop: 0, visibleHeight: ctx.viewportHeight, visibleWidth: ctx.viewportWidth });\n    }\n  }, [ctx, windowViewportRect, itemDimensions]);\n  return /* @__PURE__ */ React.createElement(\"div\", { ref: viewportRef, style: viewportStyle }, children);\n};\nconst GridRoot = /* @__PURE__ */ React.memo(function GridRoot2({ ...props }) {\n  const useWindowScroll = useEmitterValue$1(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue$1(\"customScrollParent\");\n  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller$1 : Scroller$1;\n  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport$1 : Viewport$1;\n  return /* @__PURE__ */ React.createElement(TheScroller, { ...props }, /* @__PURE__ */ React.createElement(TheViewport, null, /* @__PURE__ */ React.createElement(Header, null), /* @__PURE__ */ React.createElement(GridItems, null), /* @__PURE__ */ React.createElement(Footer, null)));\n});\nconst {\n  Component: Grid,\n  usePublisher: usePublisher$1,\n  useEmitterValue: useEmitterValue$1,\n  useEmitter: useEmitter$1\n} = /* @__PURE__ */ systemToComponent(\n  combinedSystem$1,\n  {\n    optional: {\n      context: \"context\",\n      totalCount: \"totalCount\",\n      overscan: \"overscan\",\n      itemContent: \"itemContent\",\n      components: \"components\",\n      computeItemKey: \"computeItemKey\",\n      data: \"data\",\n      initialItemCount: \"initialItemCount\",\n      scrollSeekConfiguration: \"scrollSeekConfiguration\",\n      headerFooterTag: \"headerFooterTag\",\n      listClassName: \"listClassName\",\n      itemClassName: \"itemClassName\",\n      useWindowScroll: \"useWindowScroll\",\n      customScrollParent: \"customScrollParent\",\n      scrollerRef: \"scrollerRef\",\n      logLevel: \"logLevel\"\n    },\n    methods: {\n      scrollTo: \"scrollTo\",\n      scrollBy: \"scrollBy\",\n      scrollToIndex: \"scrollToIndex\"\n    },\n    events: {\n      isScrolling: \"isScrolling\",\n      endReached: \"endReached\",\n      startReached: \"startReached\",\n      rangeChanged: \"rangeChanged\",\n      atBottomStateChange: \"atBottomStateChange\",\n      atTopStateChange: \"atTopStateChange\"\n    }\n  },\n  GridRoot\n);\nconst Scroller$1 = /* @__PURE__ */ buildScroller({ usePublisher: usePublisher$1, useEmitterValue: useEmitterValue$1, useEmitter: useEmitter$1 });\nconst WindowScroller$1 = /* @__PURE__ */ buildWindowScroller({ usePublisher: usePublisher$1, useEmitterValue: useEmitterValue$1, useEmitter: useEmitter$1 });\nfunction resolveGapValue(property, value, log) {\n  if (value !== \"normal\" && !(value == null ? void 0 : value.endsWith(\"px\"))) {\n    log(`${property} was not resolved to pixel value correctly`, value, LogLevel.WARN);\n  }\n  if (value === \"normal\") {\n    return 0;\n  }\n  return parseInt(value != null ? value : \"0\", 10);\n}\nconst VirtuosoGrid = Grid;\nconst tableComponentPropsSystem = /* @__PURE__ */ system(() => {\n  const itemContent = statefulStream((index) => /* @__PURE__ */ React.createElement(\"td\", null, \"Item $\", index));\n  const context = statefulStream(null);\n  const fixedHeaderContent = statefulStream(null);\n  const fixedFooterContent = statefulStream(null);\n  const components = statefulStream({});\n  const computeItemKey = statefulStream(identity);\n  const scrollerRef = statefulStream(noop);\n  const distinctProp = (propName, defaultValue = null) => {\n    return statefulStreamFromEmitter(\n      pipe(\n        components,\n        map((components2) => components2[propName]),\n        distinctUntilChanged()\n      ),\n      defaultValue\n    );\n  };\n  return {\n    context,\n    itemContent,\n    fixedHeaderContent,\n    fixedFooterContent,\n    components,\n    computeItemKey,\n    scrollerRef,\n    TableComponent: distinctProp(\"Table\", \"table\"),\n    TableHeadComponent: distinctProp(\"TableHead\", \"thead\"),\n    TableFooterComponent: distinctProp(\"TableFoot\", \"tfoot\"),\n    TableBodyComponent: distinctProp(\"TableBody\", \"tbody\"),\n    TableRowComponent: distinctProp(\"TableRow\", \"tr\"),\n    ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n    EmptyPlaceholder: distinctProp(\"EmptyPlaceholder\"),\n    ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\"),\n    FillerRow: distinctProp(\"FillerRow\")\n  };\n});\nconst combinedSystem = /* @__PURE__ */ system(([listSystem2, propsSystem]) => {\n  return { ...listSystem2, ...propsSystem };\n}, tup(listSystem, tableComponentPropsSystem));\nconst DefaultScrollSeekPlaceholder = ({ height }) => /* @__PURE__ */ React.createElement(\"tr\", null, /* @__PURE__ */ React.createElement(\"td\", { style: { height } }));\nconst DefaultFillerRow = ({ height }) => /* @__PURE__ */ React.createElement(\"tr\", null, /* @__PURE__ */ React.createElement(\"td\", { style: { height, padding: 0, border: 0 } }));\nconst Items = /* @__PURE__ */ React.memo(function VirtuosoItems2() {\n  const listState = useEmitterValue(\"listState\");\n  const sizeRanges = usePublisher(\"sizeRanges\");\n  const useWindowScroll = useEmitterValue(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue(\"customScrollParent\");\n  const windowScrollContainerStateCallback = usePublisher(\"windowScrollContainerState\");\n  const _scrollContainerStateCallback = usePublisher(\"scrollContainerState\");\n  const scrollContainerStateCallback = customScrollParent || useWindowScroll ? windowScrollContainerStateCallback : _scrollContainerStateCallback;\n  const itemContent = useEmitterValue(\"itemContent\");\n  const trackItemSizes = useEmitterValue(\"trackItemSizes\");\n  const itemSize = useEmitterValue(\"itemSize\");\n  const log = useEmitterValue(\"log\");\n  const { callbackRef, ref } = useChangedListContentsSizes(\n    sizeRanges,\n    itemSize,\n    trackItemSizes,\n    scrollContainerStateCallback,\n    log,\n    void 0,\n    customScrollParent\n  );\n  const [deviation, setDeviation] = React.useState(0);\n  useEmitter(\"deviation\", (value) => {\n    if (deviation !== value) {\n      ref.current.style.marginTop = `${value}px`;\n      setDeviation(value);\n    }\n  });\n  const EmptyPlaceholder = useEmitterValue(\"EmptyPlaceholder\");\n  const ScrollSeekPlaceholder = useEmitterValue(\"ScrollSeekPlaceholder\") || DefaultScrollSeekPlaceholder;\n  const FillerRow = useEmitterValue(\"FillerRow\") || DefaultFillerRow;\n  const TableBodyComponent = useEmitterValue(\"TableBodyComponent\");\n  const TableRowComponent = useEmitterValue(\"TableRowComponent\");\n  const computeItemKey = useEmitterValue(\"computeItemKey\");\n  const isSeeking = useEmitterValue(\"isSeeking\");\n  const paddingTopAddition = useEmitterValue(\"paddingTopAddition\");\n  const firstItemIndex = useEmitterValue(\"firstItemIndex\");\n  const statefulTotalCount = useEmitterValue(\"statefulTotalCount\");\n  const context = useEmitterValue(\"context\");\n  if (statefulTotalCount === 0 && EmptyPlaceholder) {\n    return React.createElement(EmptyPlaceholder, contextPropIfNotDomElement(EmptyPlaceholder, context));\n  }\n  const paddingTop = listState.offsetTop + paddingTopAddition + deviation;\n  const paddingBottom = listState.offsetBottom;\n  const paddingTopEl = paddingTop > 0 ? /* @__PURE__ */ React.createElement(FillerRow, { height: paddingTop, key: \"padding-top\", context }) : null;\n  const paddingBottomEl = paddingBottom > 0 ? /* @__PURE__ */ React.createElement(FillerRow, { height: paddingBottom, key: \"padding-bottom\", context }) : null;\n  const items = listState.items.map((item) => {\n    const index = item.originalIndex;\n    const key = computeItemKey(index + firstItemIndex, item.data, context);\n    if (isSeeking) {\n      return React.createElement(ScrollSeekPlaceholder, {\n        ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n        key,\n        index: item.index,\n        height: item.size,\n        type: item.type || \"item\"\n      });\n    }\n    return React.createElement(\n      TableRowComponent,\n      {\n        ...contextPropIfNotDomElement(TableRowComponent, context),\n        key,\n        \"data-index\": index,\n        \"data-known-size\": item.size,\n        \"data-item-index\": item.index,\n        item: item.data,\n        style: { overflowAnchor: \"none\" }\n      },\n      itemContent(item.index, item.data, context)\n    );\n  });\n  return React.createElement(\n    TableBodyComponent,\n    { ref: callbackRef, \"data-test-id\": \"virtuoso-item-list\", ...contextPropIfNotDomElement(TableBodyComponent, context) },\n    [paddingTopEl, ...items, paddingBottomEl]\n  );\n});\nconst Viewport = ({ children }) => {\n  const ctx = React.useContext(VirtuosoMockContext);\n  const viewportHeight = usePublisher(\"viewportHeight\");\n  const fixedItemHeight = usePublisher(\"fixedItemHeight\");\n  const viewportRef = useSize(compose(viewportHeight, (el) => correctItemSize(el, \"height\")));\n  React.useEffect(() => {\n    if (ctx) {\n      viewportHeight(ctx.viewportHeight);\n      fixedItemHeight(ctx.itemHeight);\n    }\n  }, [ctx, viewportHeight, fixedItemHeight]);\n  return /* @__PURE__ */ React.createElement(\"div\", { style: viewportStyle, ref: viewportRef, \"data-viewport-type\": \"element\" }, children);\n};\nconst WindowViewport = ({ children }) => {\n  const ctx = React.useContext(VirtuosoMockContext);\n  const windowViewportRect = usePublisher(\"windowViewportRect\");\n  const fixedItemHeight = usePublisher(\"fixedItemHeight\");\n  const customScrollParent = useEmitterValue(\"customScrollParent\");\n  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent);\n  React.useEffect(() => {\n    if (ctx) {\n      fixedItemHeight(ctx.itemHeight);\n      windowViewportRect({ offsetTop: 0, visibleHeight: ctx.viewportHeight, visibleWidth: 100 });\n    }\n  }, [ctx, windowViewportRect, fixedItemHeight]);\n  return /* @__PURE__ */ React.createElement(\"div\", { ref: viewportRef, style: viewportStyle, \"data-viewport-type\": \"window\" }, children);\n};\nconst TableRoot = /* @__PURE__ */ React.memo(function TableVirtuosoRoot(props) {\n  const useWindowScroll = useEmitterValue(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue(\"customScrollParent\");\n  const fixedHeaderHeight = usePublisher(\"fixedHeaderHeight\");\n  const fixedFooterHeight = usePublisher(\"fixedFooterHeight\");\n  const fixedHeaderContent = useEmitterValue(\"fixedHeaderContent\");\n  const fixedFooterContent = useEmitterValue(\"fixedFooterContent\");\n  const context = useEmitterValue(\"context\");\n  const theadRef = useSize(compose(fixedHeaderHeight, (el) => correctItemSize(el, \"height\")));\n  const tfootRef = useSize(compose(fixedFooterHeight, (el) => correctItemSize(el, \"height\")));\n  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller : Scroller;\n  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport : Viewport;\n  const TheTable = useEmitterValue(\"TableComponent\");\n  const TheTHead = useEmitterValue(\"TableHeadComponent\");\n  const TheTFoot = useEmitterValue(\"TableFooterComponent\");\n  const theHead = fixedHeaderContent ? React.createElement(\n    TheTHead,\n    {\n      key: \"TableHead\",\n      style: { zIndex: 2, position: \"sticky\", top: 0 },\n      ref: theadRef,\n      ...contextPropIfNotDomElement(TheTHead, context)\n    },\n    fixedHeaderContent()\n  ) : null;\n  const theFoot = fixedFooterContent ? React.createElement(\n    TheTFoot,\n    {\n      key: \"TableFoot\",\n      style: { zIndex: 1, position: \"sticky\", bottom: 0 },\n      ref: tfootRef,\n      ...contextPropIfNotDomElement(TheTFoot, context)\n    },\n    fixedFooterContent()\n  ) : null;\n  return /* @__PURE__ */ React.createElement(TheScroller, { ...props }, /* @__PURE__ */ React.createElement(TheViewport, null, React.createElement(TheTable, { style: { borderSpacing: 0 }, ...contextPropIfNotDomElement(TheTable, context) }, [\n    theHead,\n    /* @__PURE__ */ React.createElement(Items, { key: \"TableBody\" }),\n    theFoot\n  ])));\n});\nconst {\n  Component: Table,\n  usePublisher,\n  useEmitterValue,\n  useEmitter\n} = /* @__PURE__ */ systemToComponent(\n  combinedSystem,\n  {\n    required: {},\n    optional: {\n      context: \"context\",\n      followOutput: \"followOutput\",\n      firstItemIndex: \"firstItemIndex\",\n      itemContent: \"itemContent\",\n      fixedHeaderContent: \"fixedHeaderContent\",\n      fixedFooterContent: \"fixedFooterContent\",\n      overscan: \"overscan\",\n      increaseViewportBy: \"increaseViewportBy\",\n      totalCount: \"totalCount\",\n      topItemCount: \"topItemCount\",\n      initialTopMostItemIndex: \"initialTopMostItemIndex\",\n      components: \"components\",\n      groupCounts: \"groupCounts\",\n      atBottomThreshold: \"atBottomThreshold\",\n      atTopThreshold: \"atTopThreshold\",\n      computeItemKey: \"computeItemKey\",\n      defaultItemHeight: \"defaultItemHeight\",\n      fixedItemHeight: \"fixedItemHeight\",\n      itemSize: \"itemSize\",\n      scrollSeekConfiguration: \"scrollSeekConfiguration\",\n      data: \"data\",\n      initialItemCount: \"initialItemCount\",\n      initialScrollTop: \"initialScrollTop\",\n      alignToBottom: \"alignToBottom\",\n      useWindowScroll: \"useWindowScroll\",\n      customScrollParent: \"customScrollParent\",\n      scrollerRef: \"scrollerRef\",\n      logLevel: \"logLevel\"\n    },\n    methods: {\n      scrollToIndex: \"scrollToIndex\",\n      scrollIntoView: \"scrollIntoView\",\n      scrollTo: \"scrollTo\",\n      scrollBy: \"scrollBy\"\n    },\n    events: {\n      isScrolling: \"isScrolling\",\n      endReached: \"endReached\",\n      startReached: \"startReached\",\n      rangeChanged: \"rangeChanged\",\n      atBottomStateChange: \"atBottomStateChange\",\n      atTopStateChange: \"atTopStateChange\",\n      totalListHeightChanged: \"totalListHeightChanged\",\n      itemsRendered: \"itemsRendered\",\n      groupIndices: \"groupIndices\"\n    }\n  },\n  TableRoot\n);\nconst Scroller = /* @__PURE__ */ buildScroller({ usePublisher, useEmitterValue, useEmitter });\nconst WindowScroller = /* @__PURE__ */ buildWindowScroller({ usePublisher, useEmitterValue, useEmitter });\nconst TableVirtuoso = Table;\nexport {\n  GroupedVirtuoso,\n  LogLevel,\n  TableVirtuoso,\n  Virtuoso,\n  VirtuosoGrid,\n  VirtuosoGridMockContext,\n  VirtuosoMockContext\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}